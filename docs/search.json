[
  {
    "objectID": "Exercise1-1_Variables.html",
    "href": "Exercise1-1_Variables.html",
    "title": "",
    "section": "",
    "text": "‚¨ÖÔ∏è Previous Exercise | üè† Index | ‚û°Ô∏è Next Exercise |"
  },
  {
    "objectID": "Exercise1-1_Variables.html#variables-operators",
    "href": "Exercise1-1_Variables.html#variables-operators",
    "title": "",
    "section": "Variables + Operators",
    "text": "Variables + Operators\nVariables are used in Python to create references to an object (e.g.¬†string, float, DataFrame, etc.). Variables are assigned in Python using =.\n\nüêç <b>Note.</b>\nVariable names should be chosen carefully and should indicate what the variable is used for. Python etiquette generally dictates using lowercase variable names. Underscores are common. Variable names cannot start with a number. Also, there are several names that cannot be used as variables, as they are reserved for built-in Python commands, functions, etc. We will see examples of these throughout this exercise.\n\n\n\n\nNumbers\nNumbers in Python can be either integers (whole numbers) or floats (floating point decimal numbers).\nThe following syntax is used to define an integer:\nx = 1\ny = 42\n\n‚ñ∂Ô∏è Run the cell below.\n\n\n\nCode\n# Define variables x and y as integers.\nx = 1\ny = 42\n\n\nThe following syntax is used to define a float:\na = 1.0\nb = 42.0\nc = 23.782043\n\n‚úèÔ∏è Try it.\nDefine variables a, b, and c according to the values above.\n\n\n\nCode\n# Define variables a, b, and c as floats.\n\n\n\n Arithmetic Operators \n\nJust like a calculator, basic arithmetic can be done on number variables. Python uses the following symbols\n\n\n\nSymbol\nTask\n\n\n\n\n+\nAddition\n\n\n-\nSubtraction\n\n\n*\nMultiplication\n\n\n/\nDivision\n\n\n%\nModular\n\n\n//\nFloor division\n\n\n**\nPower\n\n\n\n\n‚úèÔ∏è Try it. Practice these arithmetic operations by running the code in the cell below. Feel free to add more to test the operators. Use the print() command to output your answers.\n\n\n\nCode\n# Do some math.\n\n\nNotice that the order of operations applies.\n\n Boolean Operators \n\nBoolean operators evaluate a condition between two operands, returning True if the condition is met and False otherwise. True and False are called booleans.\n\n\n\nSymbol\nTask\n\n\n\n\n==\nEquals\n\n\n!=\nDoes not equal\n\n\n<\nLess than\n\n\n>\nGreater than\n\n\n<=\nLess than or equal to\n\n\n>=\nGreater than or equal to\n\n\n\n\n‚ñ∂Ô∏è Run the cell below.\n\n\n\nCode\nprint( b >= w )\nprint( 87 < -2 )\nprint( c != 0 )\nprint( y == x)\n\n\n\n Built-in functions \n\nPython has a number of built-in functions. Here we will introduce a few of the useful built-in functions for numerical variables.\nThe type() function is used to check the data type of a variable. For numerical arguments, either float or int is returned.\n\n‚ñ∂Ô∏è Run the cell below.\n\n\n\nCode\ntype(v)\n\n\nThe isinstance() function is used to determine whether an argument is in a certain class. It returns a boolean value. Multiple classes can be checked at once.\nisinstance(12, int)\n>>> True\n\nisinstance(12.0,int)\n>>> False\n\nisinstance(12.0,(int,float))\n>>> True\nThe commands int() and float() are used to convert between data types.\n\n‚ñ∂Ô∏è Run the cell below.\n\n\n\nCode\nprint( float(y) )\nprint( int(c) )\n\n\nNotice that when converting a float value to an integer, the int() command always rounds down to the nearest whole number.\nTo round a float to the nearest whole number, use the function round(). You can specify the number of decimal places by adding an integer as an argument to the round() function .\n\n‚ñ∂Ô∏è Run the cell below.\n\n\n\nCode\nprint( round(c) )\nprint( round(c,3) )\n\n\nThe complex() function is used to define a complex number. We won‚Äôt be using complex numbers much in this course, but it‚Äôs important to know that python is happy to handle them.\n\n‚ñ∂Ô∏è Run the cell below.\n\n\n\nCode\nd = complex('5+2j')\n\n\nTo return the absolute value of a number, use the abs() function.\n\n‚ñ∂Ô∏è Run the cell below.\n\n\n\nCode\nprint( abs(d) )\nprint( abs(-12) )\n\n\nThe divmod() function returns the quotient and remainder of two input operands in a tuple. (Tuples are another data type that we will cover later.)\ndivmod(64, 4.2)\n>>> (15.0, 0.9999999999999973)\n\n\nThe pow() function is an alternative to the ** operator for raising a number to an exponent, i.e.¬†x^y. An optional third argument is used to return the modulus (%) of the power of a number, i.e.¬†x^y % z.\npow(8,2)\n>>> 64\n\npow(8,2,3)\n>>> 1\n\n\n\nüìö Practice 1. The laws of conservation state that in a closed system, mass, energy, and momentum can be neither created nor destroyed. Thus, the energy coming into the Earth‚Äôs surface (via solar radiation) must be equal to the energy going out from the Earth‚Äôs surface. The energy coming in via solar radiation can be written: R_{\\text{in}} = G_s \\pi {r_{e}}^2 (1 - \\alpha) where r_e is the radius of the Earth; \\alpha is the Earth‚Äôs albedo, a fraction correponding to the amount of incident radiation that is reflected; and G_s is the Solar Constant, or the flux density of the solar radiation at the Earth‚Äôs surface. The Solar Constant can be calculated according to the equation G_s = \\sigma {T_{sun}}^4 \\left( \\frac{4 \\pi {r_{sun}}^2}{4 \\pi d^2} \\right) where \\sigma is the Stefan-Boltzmann constant, T_{sun} is the temperature of the sun, r_{sun} is the radius of the sun, and d is the average distance between the sun and the Earth. The outgoing radiation from the Earth is given by the Stefan-Boltzmann law: R_{\\text{out}} = \\varepsilon \\sigma A_{e} {T_e}^4 where \\varepsilon is the emissivity of the Earth, A_e is the surface area of the Earth approximated as a sphere, and T_e is the temperature of the Earth‚Äôs surface.\n\nGiven \\sigma = 5.67 \\times 10-8 W m-2 K-4, the radius of the sun is 6.957 \\times 105 km, the temperature of the sun is 5778 K, the average distance between the sun and the Earth is 1.5 \\times 108 km, the Earth‚Äôs albedo is 0.3, and the emissivity of the Earth is 1.0,\n\n\n\nCalculate the Solar Constant in W m-2. Print your answer rounded to 3 decimal places.\n\n\nCalculate the temperature of the Earth‚Äôs surface in ¬∞C. Print your answer as both a float and an integer.\n\n\nThe actual global surface temperature of the Earth is about 14.6¬∞C. What accounts for the difference between the answer you calculated above in the actual surface temperature?\n\n\n\nShow your work by including comments in your code and assigning variables.\n\n\n\n\nCode\n# Write your code here. \n\n# Note: Before you start coding, \n#       use comments to work out the problem step-by-step...\n\n\n# Step 1: Determine G_s\n\n\n\n\n# Step 2: ...\n\n\nType your answer to part c here.\n\n\n\n\nStrings\nPieces of text in Python are referred to as strings. Strings are defined with either single or double quotes. The only difference between the two is that it is easier to use an apostrophe with double quotes.\nmytext = 'This is a string.'\nmytext2 = \"This is also a string.\"\nTo use an apostrope or single quotes inside a string defined by single quotes (or to use double quotes), use a single backslash ( \\ ) referred to as an ‚Äúescape‚Äù character.\nq1a = \"What is Newton's 1st law of motion?\"\nq1b = 'What is Newton\\'s 1st law of motion?'\n\nüìö Practice 2. In the cell below, answer the question by defining a new string variable. Use the print() command to output your answer.\n\n\n\nCode\n# Question\nq1 = 'What is Newton\\'s 1st law of motion?'\n\n# Answer the question by defining a new string variable.\n\n# Print your answer.\n\n\n\n Built-in functions \n\nJust like the int() and float commands, the str() command converts a number to a string.\n\n‚ñ∂Ô∏è Run the cell below.\n\n\n\nCode\nystr = str(y)\n\n\nThe + operator can be used to combine two or more strings.\n\n‚ñ∂Ô∏è Run the cell below.\n\n\n\nCode\ns = 'isaac' + ' ' + 'newton'\n\n\nThe commands string.upper() and string.capitalize() can be used to convert all letters in the string to uppercase and capitalize the first letter in the string, respectively.\n\n‚ñ∂Ô∏è Run the cell below.\n\n\n\nCode\nprint( s.upper() )\nprint( s.capitalize() )\n\n\n\n\nCode\n# Define variables\n\n# Combine in a single string.\n\n# Capitalize the first letter\n\n# Capitalize the entire string.\n\n# Print outputs.\n\n\n\n\nCode\nb = 3 + 'a'\n\n\n\n Formatted print statements \n\nPython uses C-style formatting to create new, formatted strings with the % operator. This is useful for printing variables in functions and when asking for user input, both of which we will discuss later. Formatted print statements contain a string argument with one of the following specifiers:\n\n\n\nSymbol\nTask\n\n\n\n\n%s\nStrings\n\n\n%d\nIntegers\n\n\n%f\nFloating point numbers\n\n\n\nThe second argument can contain a variable name or a tuple, which is a list of a fixed size. The arguments are separated by the % operator.\n\n‚ñ∂Ô∏è Run the cell below.\n\n\n\nCode\ncity = 'Santa Barbara'\nyrs = 3\nprint( 'I live in %s.' % city )\nprint( 'I have lived in %s for %d years.' % (city,yrs))\n\n\n\n‚úèÔ∏è Try it. Use the code below to write a formatted string that prints the sentence My name is [YOUR FIRST NAME]. I am [YOUR AGE] years old., inputing your name and age. Replace first with the name of the variable you assigned to your first name in the previous question. Replace age with your age as an integer.\n\n\n\nCode\n# Define the variable info.\ninfo = (first, age)\n# Complete the sentence to be printed\nsentence = \"My name...\"\n# Print\nprint( sentence % info)\n\n\nWhen printing floats, the %f argument specifier can be accompanied by a number of decimal places to print only a certain number of digits.\n\n‚ñ∂Ô∏è Run the cell below.\n\n\n\nCode\nimport math\npi_sqrt = math.sqrt(math.pi)\nprint(\"The square root of pi is %f.\" % pi_sqrt)\nprint(\"The square root of pi is %.2f.\" % pi_sqrt)\n\n\n\nüìö Practice 4. Rewrite your answers to practice questions 1a and 1b using formatted print statements. Each answer should include: 1. What you are solving for; 2. Your solution as an integer, float, and a float rounded to 3 decimal places; and 3. Units. For example:\n\nThe radius of the earth is 6,378 km.\n\nYou should have a total of 6 print statements.\n\n\n\nCode\n# Formatted print statement for 1a.\n\n# Formatted print statement for 1b.\n\n\n\n\nRecall from Exercise 1.0 that the input() function allows for user input within a script or program. Importantly, when Python prompts the user for input, the input is stored as a string, regardless of what it is. Thus, if you write a function (a type of object we will explore in a future exercise) prompting the user for a number, you must be sure to convert the variable storing the input to an integer or float.\nTo demonstrate this, run the following cell, entering the month in which you were born in numerical format (e.g.¬†if you were born in April, your input would be 4) when prompted.\n\n‚ñ∂Ô∏è Run the cell below.\n\n\n\nCode\nmonth_in = input('Month of birth (1-12): ')\ntype(month_in)\n\n\n\nüìö Practice 5. Following the example above, create a variable corresponding to the day on which you were born based on user input. Convert both variables to floats and assign the float versions to new variables. Lastly, use one of the boolean operators to evaluate which variable is greater ‚Äì the day or the month ‚Äì and print the result.\n\n\n\nCode\n# User input variable for day of birth\n\n# Convert birth day and month to floats.\n\n# Evaluate boolean operation + print result.\n\n\n\n\n\n\nCode\n# IGNORE THIS CELL\nfrom IPython.core.display import HTML\ndef css_styling():\n    styles = open(\"./styles/exercises.css\", \"r\").read()\n    return HTML(styles)\ncss_styling()"
  },
  {
    "objectID": "Exercise2-1_Numpy.html",
    "href": "Exercise2-1_Numpy.html",
    "title": "",
    "section": "",
    "text": "‚¨ÖÔ∏è Previous Exercise | üè† Index | ‚û°Ô∏è Next Exercise |"
  },
  {
    "objectID": "Exercise2-1_Numpy.html#introduction-to-numpy",
    "href": "Exercise2-1_Numpy.html#introduction-to-numpy",
    "title": "",
    "section": "Introduction to NumPy",
    "text": "Introduction to NumPy\n\nNumPy, an abbreviation for Numerical Python, is the core library for scientific computing in Python. In addition to manipulation of array-based data, NumPy provides an efficient way to store and operate on very large datasets. In fact, nearly all Python packages for data storage and computation are built on NumPy arrays.\nThis exercise will provide an overview of NumPy, including how arrays are created, NumPy functions to operate on arrays, and array math. While most of the basics of the NumPy package will be covered here, there are many, many more operations, functions, and modules. As always, you should consult the NumPy Docs to explore its additional functionality.\nBefore jumping into NumPy, we should take a brief detour through importing libraries in Python. While most packages we will use ‚Äì including NumPy ‚Äì¬†are developed by third-parties, there are a number of ‚Äústandard‚Äù packages that are built into the Python API. The following table contains a description of a few of the most useful modules worth making note of.\n\n\n\n\n\n\n\n\nModule\nDescription\nSyntax\n\n\n\n\n os \nProvides access to operating system functionality\n import os \n\n\n math \nProvides access to basic mathematical functions\n import math \n\n\n random \nImplements pseudo-random number generators for various distributions\n import random \n\n\n datetime \nSupplies classes for generating and manipulating dates and times\n import datetime as dt \n\n\n\n\nüêç <b>Import syntax.</b> \nAs we saw in Exercise 1.5, modules and packages can be loaded into a script using an <code>import</code> statement: <code>import [module]</code> for the entire module, or <code>from [module] import [identifier]</code> to import a certain class of the module. All modules and packages used in a program should be imported at the beginning of the program.\nMany packages are imported with standard abbreviations (such as dt for the datetime module) using the following syntax:\n\nimport [module] as [name]\n\nThe standard syntax for importing NumPy is:\n\nimport numpy as np\n\n\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\nimport numpy as np\n\n\n\nNumPy Arrays\n\n\nThe n-dimensional array object in NumPy is referred to as an ndarray, a multidimensional container of homogeneous items ‚Äì¬†i.e.¬†all values in the array are the same type and size. These arrays can be one-dimensional (one row or column vector), two-dimensional (m rows x n columns), or three-dimensional (arrays within arrays).\n\n Constructing arrays from lists \n\nThere are two main ways to construct NumPy arrays. The first involves using the np.array() function to generate an array from one or more lists:\nnp.array([8,0,9,1,4])\n>>> array([8, 0, 9, 1, 4])\nRecall that unlike lists, all elements within an array must be of the same type. If the types do not match, NumPy will ‚Äúupcast‚Äù if possible (e.g.¬†convert integers to floats):\nnp.array([8.14,0.12,9,1.77,4])\n>>> array([8.14, 0.12, 9.  , 1.77, 4.  ])\nIn these examples, we have created one-dimensional arrays. By default, elements in a one-dimensional array are cast as rows in a column (i.e.¬†a column vector). If, however, we wanted a row vector instead, we could use double brackets [[]] to create an array with one row and multiple columns:\nnp.array([[8,0,9,1,4]]) # row vector with 5 columns\n>>> array([[8, 0, 9, 1, 4]])\nThis is because NumPy treats the inner element(s) or list(s) as rows. This is easier to see with a multidimensional array:\nnp.array([[3,2,0,1],[9,1,8,7],[4,0,1,6]]) # array with 3 rows x 4 columns\n\n>>> array([[3, 2, 0, 1],\n           [9, 1, 8, 7],\n           [4, 0, 1, 6]])\n\nüìö  <b> Practice 1. </b> \nCreate the following arrays and assign the corresponding variable names:\n\n\na\n\n$ \\begin{matrix}\n        4 &   5 &   0 & 12 & -1 \\\\\n        8 & -21 &  -4 &  6 &  3 \\\\\n       17 &   1 & -13 &  7 &  0\n      \\end{matrix}$\n<li> <code>b</code> </li> \n    $ \\begin{matrix}\n        1.0 & 2.7 & 0 & 0.188 & 4.07 & 0.24\n      \\end{matrix}$\n<li> <code>c</code> </li> \n    $ \\begin{matrix}\n        0.4 \\\\\n        0.8 \\\\\n        1.2 \\\\\n        1.6 \\\\\n        2.0 \\\\\n        2.4\n      \\end{matrix}$\n\n\n\n Constructing arrays using functions \n\nOftentimes, it will be more efficient to construct arrays from scratch using NumPy functions. The np.arange() function is used to generate an array with evenly spaced values within a given interval. np.arange() can be used with one, two, or three parameters to specify the start, stop, and step values. If only one value is passed to the function, it will be interpreted as the stop value:\n# Create an array of the first seven integers \nnp.arange(7)\n>>> array([0, 1, 2, 3, 4, 5, 6])\n\n# Create an array of floats from 1 to 12\nnp.arange(1.,13.)\n>>> array([ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10., 11., 12.])\n\n# Create an array of values between 0 and 20, stepping by 2\nnp.arange(0,20,2)\n>>> array([ 0,  2,  4,  6,  8, 10, 12, 14, 16, 18])\nSimilarly, the np.linspace() function is used to construct an array with evenly spaced numbers over a given interval. However, instead of the step parameter, np.linspace() takes a num parameter to specify the number of samples within the given interval:\n# Create an array of 5 evenly spaced values between 0 and 1\nnp.linspace(0,1,5)\n>>> array([0.  , 0.25, 0.5 , 0.75, 1.  ])\nNote that unlike np.arange(), np.linspace() includes the stop value by default (this can be changed by passing endpoint=True). Finally, it should be noted that while we could have used np.arange() to generate the same array in the above example, it is recommended to use np.linspace() when a non-integer step (e.g.¬†0.25) is desired.\n\nüìö  <b> Practice 2. </b> \n\n\nCreate a new array d of integers the multiples of 3 between 0 and 100.\n\n\nCreate an array f 10 evenly spaced elements between 0 and 2.\n\n\nRe-create array c from Practice 1c using a function. Assign this to variable name g.\n\n\n\nThere are several functions that take a shape argument to generate single-value arrays with specified dimensions passed as a tuple (rows,columns):\n# Create a 1D array of zeros of length 4\nnp.zeros(4)\n>>> array([0., 0., 0., 0.]\n\n# Create a 4 x 3 array filled with zeros\nnp.zeros((4,3))\n>>> array([[0., 0., 0.],\n           [0., 0., 0.],\n           [0., 0., 0.],\n           [0., 0., 0.]])\n\n# Create a 4 x 3 array filled with ones\nnp.ones((4,3))\n>>> array([[1., 1., 1.],\n           [1., 1., 1.],\n           [1., 1., 1.],\n           [1., 1., 1.]])\n\n\n# Create a 4 x 3 array filled with 3.14\nnp.full((4,3),9.87)\n>>> array([[9.87, 9.87, 9.87],\n           [9.87, 9.87, 9.87],\n           [9.87, 9.87, 9.87],\n           [9.87, 9.87, 9.87]])\nThe np.random.rand() function is used to generate n-dimensional arrays filled with random numbers between 0 and 1:\n# Create a 4 x 3 array of uniformly distributed random values\nnp.random.rand(4,3)\n>>> array([[0.17461878, 0.74586348, 0.9770975 ],\n           [0.77861373, 0.28807114, 0.10639001],\n           [0.09845499, 0.36038089, 0.58533369],\n           [0.30983962, 0.74786381, 0.27765305]])\nAs we will see, the np.random.rand() function is very useful for sampling and modeling.\nThe last array-construction function we will consider (but by no means the last in the NumPy API!) is the np.eye() function, which is used to generate the two-dimensional identity matrix:\n# Create a 4 x 4 identity matrix\nnp.eye(4)\n>>> array([[1., 0., 0., 0.],\n           [0., 1., 0., 0.],\n           [0., 0., 1., 0.],\n           [0., 0., 0., 1.]])\nLastly, it‚Äôs worth noting that nearly all of these functions contain an optional dtype parameter, which can be used to specify the data-type of the resulting array (e.g.¬†np.ones((4,3),dtype=int) would return a 4 x 3 array of ones as integers, rather than the default floats).\n\nüìö  <b> Practice 3. </b> Assign the following to variables:\n<ol class=\"alpha\">\n    <li> A 5x3 array of ones. </li>\n    <li> A one-dimensional array of 6 zeros. </li> \n    <li> A 7x7 identity array. </li>\n    <li> A random 10x10 array. </li>\n\n\n\n\nArray Manipulation\n\n\nHaving established how to construct arrays in NumPy, let‚Äôs explore some of the attributes of the ndarray, including how to manipulate arrays. Nearly all data manipulation in Python involves NumPy array manipulation; many other Python data tools like Pandas (Exercise 2.2) are built on the NumPy array. Thus, while many of the examples below may seem trivial, understanding these operations will be critical to understanding more complex operations and Python data manipulation more broadly.\n\n Array attributes \n\nArray attributes are properties that are intrinsic to the array itself. While there are quite a few attributes of NumPy arrays, the ones we will use most often provide information about the size, shape, and type of the arrays:\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\n ndarray.ndim \nNumber of array dimensions\n\n\n ndarray.shape \nTuple of array dimensions (rows, columns)\n\n\n ndarray.size \nTotal number of elements in the array\n\n\n ndarray.dtype \nData-type of array elements\n\n\n\nFor example, let‚Äôs create a random two-dimensional array and explore its attributes using the above methods.\n# Initialize array\na = np.random.rand(4,7)\n\n# Determine array dimensions\na.ndim\n>>> 2\n\n# Determine array shame\na.shape\n>>> (4, 7)\n\n# Determine array size\na.size\n>>> 28\n\n# Determine data-type\na.dtype\n>>> dtype('float64')\n\n‚úèÔ∏è <b> Try it. </b> \nConstruct two array vectors, a column vector and a row vector, from the list <code>[8,0,9,1,4]</code>, as in the first example. Using the <code>ndarray.ndim</code> and <code>ndarray.shape</code> methods, show the difference between constructing an array with single vs. double brackets.\n\n\nüìö  <b> Practice 4. </b> Use array methods and the array you created in Practice 2a (<code>d</code>) to count the number of multiples of 3 between 0 and 100.\n\n\n Indexing + slicing \n\nIndexing arrays is analogous to indexing lists:\n# Initialize a one-dimensional array\nx1 = np.array([8,0,9,1,4])\n\n# Return the value in position 1\nx1[1]\n>>> 0\nWith multidimensional arrays, a tuple of indices can be passed to access the rows and columns of an array: ndarray[row,column]. If a single index is passed, the corresponding row element will be returned:\n# Initialize a two-dimensional array\nx2 = np.array([[3,2,0,1],\n               [9,1,8,7],\n               [4,0,1,6]])\n\n# Return the value of the element in the 2nd row, 3rd column\nx2[1,2]\n>>> 8 \n\n# Return the entire second row\nx2[1]\n>>> array([9, 1, 8, 7])\nSlicing of arrays allows you to access parts of arrays or subarrays. Just like with lists, slicing follows the syntax ndarray[start:stop:step].\n# Return the elements in positions 1-4\nx1[1:]\n>>> array([0, 9, 1, 4])\nFor multidimensional arrays, a tuple of slices is used: ndarray[row_start:row_end:row_step, col_start:col_end:col_step].\n# Return the entire third column\nx2[:,2]\n>>> array([0, 8, 1])\n\n# Return the first two rows and two columns\nx2[:2,:2]\n>>> array([[3, 2],\n           [9, 1]])\n\n# Return all rows and every other column\nx2[:,::2]\n>>> array([[3, 0],\n           [9, 8],\n           [4, 1]])\n\nüìö  <b> Practice 5. </b> Using the array you created in Practice 3d,\n<ol class=\"alpha\">\n    <li> Print all the elements in column 4. </li>\n    <li> Print all the elements in row 7. </li>\n    <li> Extract the 4x4 subarray at the center of the array and assign it as a new variable. </li>\n    <li> Print the last two values in column 10. </li>\n\n\n\nüìö  <b> Practice 6. </b> Create a blank 8x8 matrix and fill it with a checkerboard pattern of 0s and 1s using indexing.\n\n\n Array reduction \n\nArray reduction refers to the computation of summary statistics on an array ‚Äì i.e.¬†reducing an array to a single aggregate value, such as the mean, minimum, maximum, etc. These array reduction methods are similar to those used for lists:\nx2 = np.array([[3,2,0,1],\n               [9,1,8,7],\n               [4,0,1,6]])\n\n# Sum of all values in array\nx2.sum()\n>>> 42\n\n# Maximum value of the array\nx2.max()\n>>> 9\n\n# Minimum value of the array\nx2.min()\n>>> 0\n\n# Mean value of the array\nx2.mean()\n>>> 3.5\n\n# Standard deviation of the array\nx2.std()\n>>> 3.095695936834452\nAll of these methods can be passed with an axis argument, which allows for aggregation across the rows or columns of the array. In NumPy ‚Äì as well as the many libraries built on NumPy, axis 0 always refers to the rows of an array, while axis 1 refers to the columns:\n# Mean of each row (calculated across columns)\nx2.mean(axis=1)\n>>> array([1.5 , 6.25, 2.75])\n\n# Maximum value of each column (calculated across rows)\nx2.max(axis=0)\n>>> array([9, 2, 8, 7])\n\nüêç <b>Functions vs. Methods.</b> \nRecall from Exercise 1.5 that <i>functions</i> and <i>methods</i> in Python are essentially the same thing. The key difference, however, is that functions can be called generically, while methods are always attached to and called on objects. It is also worth noting that while a method may alter the object itself, a function <i>usually</i> simply operates on an object without changing it, and then prints something or returns a value.\nFor each of the array reduction methods demonstrated above, there is a corresponding function. For example, the mean of an array can be calculated using the method ndarray.mean() or the function np.mean(ndarray).\nThese ‚Äì¬†and the many additional ‚Äì aggregation functions in NumPy can be used, not only on arrays, but on any numerical object.\n\n\n Reshaping, resizing, + rearranging arrays \n\nOther useful array operations include reshaping, resizing, and rearranging arrays. The ndarray.reshape() method is used to change the shape of an array:\n# Initialize a one-dimensional array with 16 elements\na = np.arange(1.0,17.0)\n\na\n>>> array([ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10., 11., 12., 13.,\n       14., 15., 16.])\n\n# Reshape array a into a 4x4 array\nb = a.reshape(4,4)\n\nb\n>>> [[ 1.  2.  3.  4.]\n     [ 5.  6.  7.  8.]\n     [ 9. 10. 11. 12.]\n     [13. 14. 15. 16.]]\n\nThere are a few important things to note about the ndarray.reshape() method. First and unsurprisingly, the size of array must be preserved (i.e.¬†the size of the reshaped array must match that of the original array). Secondly, and perhaps more importantly, the ndarray.reshape() method creates a view of the original array a, rather than a copy, which would allow the two variables to exist independently. Because b is a view of a, any changes made to b will also be applied to a:\n# Reset the value in the third row, third column (11.0)\nb[2,2] = 0.0\n\nb\n>>> array([[ 1.,  2.,  3.,  4.],\n           [ 5.,  6.,  7.,  8.],\n           [ 9., 10.,  0., 12.],\n           [13., 14., 15., 16.]])\n\na\n>>> array([ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10.,  0., 12., 13., \n           14., 15., 16.])\nUnlike ndarray.reshape(), the ndarray.resize() method operates in-place on the original array. The ndarray.resize() method is used to add or delete rows and/or columns:\n# Initialize a 2 x 3 array\na = np.array([[1,2,3],[4,5,6]])\n\n# Copy the original array\nsmaller = a.copy()\n# Use ndarray.resize() to reshape to a 2x2 array and delete the last two elements\nsmaller.resize(2,2)\n\nsmaller\n>>> array([[1, 2],\n           [3, 4]])\n\n# Copy the original array\nbigger = a.copy()\n# Use ndarray.resize() to reshape to a 6x6 array by adding zeros\nbigger.resize(6,6)\n\nbigger\n>>> array([[1, 2, 3, 4, 5, 6],\n           [0, 0, 0, 0, 0, 0],\n           [0, 0, 0, 0, 0, 0],\n           [0, 0, 0, 0, 0, 0],\n           [0, 0, 0, 0, 0, 0],\n           [0, 0, 0, 0, 0, 0]])\n\nüêç <b>Copies vs. Views</b> \nThis is just one example of many occasions when it is advisable to create a <b>copy</b> of the original object before manipulating it. Had we not copied <code>a</code> before resizing it to a 2x2 array, the last two elements would have been permanently deleted, as <code>a</code> itself would have been resized. A good rule of thumb is to <b>always create a copy</b> before changing or deleting any data.\n\nOften it is useful to rearrange the elements in an array. The ndarray.transpose() method ‚Äì¬†or simply ndarray.T, transposes the array, switching the rows and columns, while the np.flip(), np.flipud(), and np.fliplr() functions reverse the order of elements in the array along a given axis:\n# Initialize a new 4x5 array\nx = np.array([[4, 2, 0, 1, 5],\n              [9, 4, 1, 3, 0],\n              [6, 0, 8, 5, 9],\n              [7, 3, 2, 7, 4]])\n\n# Transpose rows + columns\nx.T\n>>> array([[4, 9, 6, 7],\n           [2, 4, 0, 3],\n           [0, 1, 8, 2],\n           [1, 3, 5, 7],\n           [5, 0, 9, 4]])\n\n# Flip the array (reverse the order of all elements)\nnp.flip(x)\n>>> array([[4, 7, 2, 3, 7],\n           [9, 5, 8, 0, 6],\n           [0, 3, 1, 4, 9],\n           [5, 1, 0, 2, 4]])\n\n# Flip the array up/down (reverse the order of the rows)\nnp.flipud(x)\n>>> array([[7, 3, 2, 7, 4],\n           [6, 0, 8, 5, 9],\n           [9, 4, 1, 3, 0],\n           [4, 2, 0, 1, 5]])\n\n# Flip the array left/right (reverse the order of the columns)\nnp.fliplr(x)\n>>> array([[5, 1, 0, 2, 4],\n           [0, 3, 1, 4, 9],\n           [9, 5, 8, 0, 6],\n           [4, 7, 2, 3, 7]])\nWhen passed with the axis argument, np.flip() mimics the np.flipud() and np.fliplr() functions:\n# Flip the array over the row axis (same as np.flipud(x))\nnp.flip(x, axis=0)\n>>> array([[7, 3, 2, 7, 4],\n           [6, 0, 8, 5, 9],\n           [9, 4, 1, 3, 0],\n           [4, 2, 0, 1, 5]])\n\n# Flip the array over the column axis (same as np.fliplr(x))\nnp.flip(x, axis=1)\n>>> array([[5, 1, 0, 2, 4],\n           [0, 3, 1, 4, 9],\n           [9, 5, 8, 0, 6],\n           [4, 7, 2, 3, 7]])\n\nüìö  <b> Practice 7. </b>\n<ol class=\"alpha\">\n    <li> Create a 3x3 matrix with values ranging from 0 to 8. </li>\n    <li> Reverse the order of elements in your random 10x10 array from excercise 3d. </li>\n\n\n\n Joining + splitting arrays \n\nSo far, we have considered array manipulation routines that operatee on a single array. We will encounter many scenarios in which it is necessary to combine multiple arrays into one or, conversely, to split a single array into two or more separate objects.\nConcatenation in computer programming refers to the process of joining multiple objects end-to-end. The most common way of concatenating arrays in NumPy is with the np.concatenate() function, which takes a tuple of arrays:\n# Initialize a 3x3 array\nx = np.array([[4,2,0],\n              [9,4,1],\n              [6,0,8]])\n# Initialize a 1x3 array\ny = np.array([[2,8,6]])\n\n# Concatenate x and y\nnp.concatenate((x,y))\n>>> array([[4, 2, 0],\n           [9, 4, 1],\n           [6, 0, 8],\n           [2, 8, 6]])\nNote that, by default, np.concatenate() operates along the row axis (0). To concatenate along the column axis, we must specify axis=1 as an argument:\n# Concatenate x and y along the column axis\nnp.concatenate((x,y), axis=1)\n>>> ---------------------------------------------------------------------------\n    ValueError                                Traceback (most recent call last)\n    <ipython-input-65-6c2205ef28d2> in <module>\n          5 y = np.array([[2,8,6,0]])\n          6 \n    ----> 7 np.concatenate((x,y),axis=1)\n\n    <__array_function__ internals> in concatenate(*args, **kwargs)\n\n    ValueError: all the input array dimensions for the concatenation axis must match exactly, but along \n    dimension 0, the array at index 0 has size 3 and the array at index 1 has size 1\nUh-oh! Unsurprisingly, when we tried to concatenate an array with 1 row to an array with 3 rows, we got a ValueError. For np.concatenate() to work, the dimensions must match. Thus, we must first transpose y before adding it to x as a column:\n# Transpose y and concatenate x and y along the column axis\nnp.concatenate((x,y.T),axis=1)\n>>> array([[4, 2, 0, 2],\n           [9, 4, 1, 8],\n           [6, 0, 8, 6]])\nEquivalently, we could use the np.vstack() or np.hstack() function to concatenate directly along the row or column axis, respectively:\n# Stack rows of x and y (same as np.concatenate((x,y), axis=0)\nnp.vstack((x,y))\n>>> array([[4, 2, 0],\n           [9, 4, 1],\n           [6, 0, 8],\n           [2, 8, 6]])\n\n# Stack columns of x and y (same as np.concatenate((x,y), axis=1)\nnp.hstack((x,y.T))\n>>> array([[4, 2, 0, 2],\n           [9, 4, 1, 8],\n           [6, 0, 8, 6]])\n\nüìö  <b> Practice 8. </b> Create two random 1-D arrays of length 10. Merge them into a 2x10 array and then a 10x2 array.\n\nConversely, splitting allows you to breakdown a single array into multiple arrays. Splitting is implemented with the np.split(), np.vsplit(), and np.hsplit() functions.\n# Initialize a 4x3 array\nz = np.array([[4, 2, 0],\n              [9, 4, 1],\n              [6, 0, 8],\n              [2, 8, 6]])\n\n# Split z into two arrays at row 1\nnp.split(z,[1])\n>>> [array([[4, 2, 0]]), array([[9, 4, 1],\n                                [6, 0, 8],\n                                [2, 8, 6]])]\n\n# OR\nnp.vsplit(z,[1])\n>>> [array([[4, 2, 0]]), array([[9, 4, 1],\n                                [6, 0, 8],\n                                [2, 8, 6]])]\n\n# Split z into two arrays at column 1\nnp.hsplit(z,[1])\n>>> [array([[4],\n            [9],\n            [6],\n            [2]]), \n     array([[2, 0],\n            [4, 1],\n            [0, 8],\n            [8, 6]])]\nMultiple indices can be passed to the np.split() and related functions, with n indices (split points) resulting in n + 1 subarrays.\n\nüìö  <b> Practice 9. </b>\n<ol class=\"alpha\">\n    <li> Split your random 10x10 array from 3d into two 10x5 arrays. </li>\n    <li> Combine the first 10x5 array from (a), the 10x2 array from 8b, and the other 10x5 array from (a). In other words, recombine the 10x10 array from 3d with two new columns in index positions 5 and 6. Your final array should have 10 rows and 12 columns. Verify this by printing the shape of the resulting array. </li>\n\n\n\n\nArray Math\n\n\nOne of the key advantages of NumPy is its ability to perform vectorized operations using universal functions (ufuncs), which perform element-wise operations on arrays very quickly. For example, say we had a very large list of data, and we wanted to perform some mathematical operation on all of the data elements. We could store this data as a list or an ndarray:\n# Create a list of the first 10,000 integers\na = list(range(10000))\n\n# Create a one-dimensional array of the first 10,000 integers\nb = np.arange(10000)\nNow, let‚Äôs multiply each element in our dataset by 2. We can accomplish this by using a for loop for the list a and a ufunc for array b. (The %timeit module is a built-in Python function used to calculate the time it takes to execute short code snippets.)\n# Use a for loop to multiply every element in a by 2\n%timeit [i*2 for i in a]\n# Use a ufunc to multiply every element in b by 2\n%timeit b * 2\n\n>>> 388 ¬µs ¬± 30.6 ¬µs per loop (mean ¬± std. dev. of 7 runs, 1000 loops each)\n    3.58 ¬µs ¬± 41.1 ns per loop (mean ¬± std. dev. of 7 runs, 100000 loops each)\nThe %timeit module is a built-in Python function used to calculate the time it takes to execute short code snippets.\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\n# Create a list of the first 10,000 integers\nlist10 = list(range(10000))\n# Use a for loop to multiply every element in a by 2\n%timeit [i*2 for i in list10]\n\n# Create a one-dimensional array of the first 10,000 integers\narray10 = np.arange(10000)\n# Use a ufunc to multiply every element in b by 2\n%timeit array10 * 2\n\n\nAs you can see, the for loop took about 100 times longer than the exact same element-wise array operation!\n\n Computation on single arrays using ufuncs \n\nUfuncs are fairly straightforward to use, as they rely on Python‚Äôs native operators (e.g.¬†+, -, *, /):\n# Create a 2x4 array of floats\nx  = np.array([[1.,2.,3.,4.],\n               [5.,6.,7.,8.]])\n\n# Do some math\n# Addition\nx + 12\n>>> array([[13., 14., 15., 16.],\n           [17., 18., 19., 20.]])\n\n# Subtraction\nx - 400\n>>> array([[-399., -398., -397., -396.],\n           [-395., -394., -393., -392.]])\n\n# Exponentiation\nx ** 2\n>>> array([[ 1.,  4.,  9., 16.],\n           [25., 36., 49., 64.]])\n\n# Combine operations\n10 ** (x/2)\n>>> array([[3.16227766e+00, 1.00000000e+01, 3.16227766e+01, 1.00000000e+02],\n           [3.16227766e+02, 1.00000000e+03, 3.16227766e+03, 1.00000000e+04]])\nThese arithmetic operators act as wrappers (effectively shortcuts) around specific built-in NumPy functions; for example, the + operator is a convenient shortcut for the np.add() function:\nx + 2\n>>> array([[ 3.,  4.,  5.,  6.],\n           [ 7.,  8.,  9., 10.]])\n\nnp.add(x,2)\n>>> array([[ 3.,  4.,  5.,  6.],\n           [ 7.,  8.,  9., 10.]])\nThe following table contains a list of arithmetic operators implemented by NumPy. Note that these functions work on all numerical objects, not just arrays.\n\n\n\nArithmetic functions in NumPy \n\n\n\n\n\n\n\n\n\nOperator\nufunc\nDescription\n\n\n\n\n +\n np.add() \nAddition\n\n\n -\n np.subtract() \nSubtraction\n\n\n * \n np.multiply() \nMultiplication\n\n\n / \n np.divide() \nDivision\n\n\n // \n np.floor_divide() \nFloor division (returns largest integer)\n\n\n ** \n np.power() \nExponentiation\n\n\n % \n np.mod() \nModulus/remainder\n\n\n **(1/2) \n np.sqrt() \nSquare root-alize\n\n\n\nFurthermore, as a numerical package, NumPy implements many additional mathematical operations for use in Python ‚Äì¬†on arrays or otherwise. The following tables show some of the more commonly used mathematical functions in NumPy. The x is used to denote a numerical object ‚Äì this could be an int, float, list, ndarray, etc.\n\n\n\nLogarithmic functions \n\n\n\n\n\n\n\n\nufunc\nOperation\n\n\n\n\n np.exp(x) \ne^x\n\n\n np.log(x) \n\\ln x\n\n\n np.log10(x) \n\\log x\n\n\n\n\n\n\n Trigonometric functions \n\n\n\n\n\n\n\n\nufunc\nDescription\n\n\n\n\n np.sin(x) \n\\sin{x}\n\n\n np.cos(x) \n\\cos{x}\n\n\n np.tan(x) \n\\tan{x}\n\n\n np.arcsin(x) \n\\sin^{-1}{x}\n\n\n np.arccos(x) \n\\cos^{-1}{x}\n\n\n np.arctan(x) \n\\tan^{-1}{x}\n\n\n\n\n\nNote: NumPy assumes all inputs to trigonometic functions are in units of radians. The np.radians() function can be used to convert from degrees to radians, while the np.degrees() function does the opposite.\n\n\n\n Useful mathematical constants \n\n\n\n\n\n\n\n\nConstants\nDescription\n\n\n\n\n np.e \ne\n\n\n np.pi \n\\pi\n\n\n\n\n Array-to-array math \n\nSo far, we have only considered operations between a single array and an integer, but often it is necessary to perform mathematical operations on multiple arrays. Much like NumPy handles single array operations, array-to-array math in NumPy uses ufuncs to perform element-wise calculations. For arrays of the same dimensions, this is straight forward:\nx  = np.array([[1.,2.,3.,4.],\n               [5.,6.,7.,8.]])\n\ny = np.array([[9.,87.,3.,5.6],\n              [-1.,4.,7.1,8.]])\n\n# Addition\nx + y\n>>> array([[10. , 89. ,  6. ,  9.6],\n           [ 4. , 10. , 14.1, 16. ]])\n\n# Division\nx / y\n>>> array([[ 0.11111111,  0.02298851,  1.        ,  0.71428571],\n           [-5.        ,  1.5       ,  0.98591549,  1.        ]])\nFor arrays whose dimensions do not match, NumPy does something called broadcasting. So long as one dimension of each array matches and one array has a dimension of 1 in one direction, the smaller array is ‚Äúbroadcast‚Äù to the dimensions of the larger array. In this process, the row or column is replicated to match the dimensions of the larger array. This is best illustrated in the following diagram:\n\na = np.array([[1.,2.,3.,4.],\n             [5.,6.,7.,8.]])\n\nb = np.array([10,11,12,13])\n\nc = np.array([[1.],\n             [20.]])\n\n# Row-wise\na + b\n>>> array([[11., 13., 15., 17.],\n           [15., 17., 19., 21.]])\n\n# Column-wise\na + c\n>>> array([[ 2.,  3.,  4.,  5.],\n           [25., 26., 27., 28.]])\n\n# Multiple operations\na + c**2\n>>> array([[  2.,   3.,   4.,   5.],\n           [405., 406., 407., 408.]])\n\nüìö  <b> Practice 10. </b>\n<ol class=\"alpha\">\n    <li> Raise array <code>b</code> to the power of array <code>c</code>. </li>\n    <li> Create a new 5x10 array of random values. Subtract the mean of each row from every value. </li>\n\n\n\n\nMissing Data\n\n\nMost real-world datasets ‚Äì¬†environmental or otherwise ‚Äì¬†have data gaps. Data can be missing for any number of reasons, including observations not being recorded or data corruption. While a cell corresponding to a data gap may just be left blank in a spreadsheet, when imported into Python, there must be some way to handle ‚Äúblank‚Äù or missing values.\nMissing data should not be replaced with zeros, as 0 can be a valid value for many datasets, (e.g.¬†temperature, precipitation, etc.). Instead, the convention is to fill all missing data with the constant NaN. NaN stands for ‚ÄúNot a Number‚Äù and is implemented in NumPy as np.nan.\nNaNs are handled differently by different packages. In NumPy, all computations involving NaN values will return nan:\ndata = np.array([[2.,2.7.,1.89.],\n                 [1.1, 0.0, np.nan],\n                 [3.2, 0.74, 2.1]])\n\ndata.mean()\n>>> nan\nIn this case, we‚Äôd want to use the alternative np.nanmean() function, which ignores NaNs:\ndata.nanmean()\n>>> 1.71625\nNumPy has several other functions ‚Äì including np.nanmin(), np.nanmax(), np.nansum() ‚Äì that are analogous to the regular ufuncs covered above, but allow for computation of arrays containing NaN values.\n\n\n\n\nWrapping up\nThe topics covered in this exercise are but a small window into the wide world of NumPy, but by now you should be familiar with the basic objects and operations in the NumPy library, which are the building blocks of data science in Python. As always ‚Äì especially now that we‚Äôve begun exploring third-party packages ‚Äì refer to the NumPy docs for comprehensive information on all functions, methods, routines, etc. and to check out more of NumPy‚Äôs capabilities.\nNext, we‚Äôll explore one of data scientists‚Äô favorite libraries: üêº.\n\n\n\n\nCode\n# IGNORE THIS CELL\nfrom IPython.core.display import HTML\ndef css_styling():\n    styles = open(\"./styles/exercises.css\", \"r\").read()\n    return HTML(styles)\ncss_styling()"
  },
  {
    "objectID": "Exercise2-2_Pandas.html",
    "href": "Exercise2-2_Pandas.html",
    "title": "",
    "section": "",
    "text": "‚¨ÖÔ∏è Previous Exercise | üè† Index | ‚û°Ô∏è Next Exercise |"
  },
  {
    "objectID": "Exercise2-2_Pandas.html#introduction-to-pandas",
    "href": "Exercise2-2_Pandas.html#introduction-to-pandas",
    "title": "",
    "section": "Introduction to pandas",
    "text": "Introduction to pandas\n\nAs always, we must begin by importing the pandas library. The standard import statement for pandas is:\nimport pandas as pd\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\nimport pandas as pd\n\n\n\nSeries and DataFrame objects\n\n\nThe core components of pandas are the Series and the DataFrame objects. Both of these are essentially enhanced versions of the NumPy array, with a few key differences: 1) pandas DataFrames can be heterogeneous, meaning that the columns can contain different data types; and 2) the rows and columns of DataFrames can be identified with labels (usually strings) in addition to standard integer indexing.\nA Series is essentially a column of data, while a DataFrame is a multidimensional table made up of many Series, not unlike a spreadsheet:\n\nSeries and DataFrames are similar in many respects ‚Äì most common operations can be performed on both objects, though Series are more limited, as they can only ever contain a single column (i.e.¬†you cannot turn a Series into a DataFrame by adding a column).\nBoth Series and DataFrame objects contain an Index object similar to the row index of the ndarray or the index of a list. The pandas Index object can be conceptualized as an immutable array or an ordered multiset. Unless explicitly defined otherwise, the Index of a Series or DataFrame is initialized as the ordered set of positive integers beginning at 0 (see figure above).\n\nCreating Series and DataFrame objects from scratch\nA Series can be easily created from a list or array as follows:\n# Create a Series from a list\nseries = pd.Series([25.8, 16.2, 17.9, 18.8, 23.6, 29.9, 23.6, 22.1])\n\nseries\n\n\n\n\n\n0    25.8\n1    16.2\n2    17.9\n3    18.8\n4    23.6\n5    29.9\n6    23.6\n7    22.1\ndtype: float64\n\n\n\n\nThere are many ways to create a DataFrame, but the most common are to use a list of lists or a dictionary. First, let‚Äôs use a list of lists (or an array):\n# Create a df from a list of lists\ndf = pd.DataFrame([[25.8, 28.1, 16.2, 11.0],[17.9, 14.2, 18.8, 28.0],\n                   [23.6, 18.4, 29.9, 27.8],[23.6, 36.2, 22.1, 14.5]],\n                 columns=['A','B','C','D'])\ndf\n\n\n\n\n\n      A     B     C     D\n0  25.8  28.1  16.2  11.0\n1  17.9  14.2  18.8  28.0\n2  23.6  18.4  29.9  27.8\n3  23.6  36.2  22.1  14.5\n\n\n\n\nMuch like with NumPy arrays, each inner list element in the outer list corresponds to a row. Using the optional columns keyword argument, we can specify the name of each column. If this parameter is not passed, the columns would be displayed with integer index values (like the rows).\nNext, let‚Äôs create a DataFrame from a dict object:\n# Create a df from a dictionary\ndf = pd.DataFrame({'A': [25.8, 17.9, 23.6, 23.6],\n                   'B': [28.1, 14.2, 18.4, 36.2],\n                   'C': [16.2, 18.8, 29.9, 22.1],\n                   'D': [11.0, 28.0, 27.8, 14.5]})\n\ndf\n\n\n\n\n\n      A     B     C     D\n0  25.8  28.1  16.2  11.0\n1  17.9  14.2  18.8  28.0\n2  23.6  18.4  29.9  27.8\n3  23.6  36.2  22.1  14.5\n\n\n\n\nUsing this method, each key corresponds to a column name, and each value is a column.\n\nüìö  <b> Practice 1. </b> \n\n\nUse a list of lists to construct a DataFrame named df1 containing the data in the table below.\n\n\n\n\n\nRiver\n\n\nLength (\\text{km})\n\n\nDrainage area (\\text{km}^2)\n\n\n\n\nAmazon\n\n\n6400\n\n\n7,050,000\n\n\n\n\nCongo\n\n\n4371\n\n\n4,014,500\n\n\n\n\nYangtze\n\n\n6418\n\n\n1,808,500\n\n\n\n\nMississippi\n\n\n3730\n\n\n3,202,230\n\n\n\n\n\n\n\nUse a dict to construct a DataFrame named df2 containing the data in the table below.\n\n\n\n\n\nRiver\n\n\nLength (\\text{km})\n\n\nDrainage area (\\text{km}^2)\n\n\n\n\nZambezi\n\n\n2574\n\n\n1,331,000\n\n\n\n\nMekong\n\n\n4023\n\n\n811,000\n\n\n\n\nMurray\n\n\n2508\n\n\n1,061,469\n\n\n\n\nRh√¥ne\n\n\n813\n\n\n98,000\n\n\n\n\nCubango\n\n\n1056\n\n\n530,000\n\n\n\n\n\n\n\n\n\n\nImporting data\n\n\nWhile you will likely create many DataFrames from scratch throughout your code, in most cases, you‚Äôll have some data you‚Äôd like to import as a starting point. Pandas has several functions to read in data from a variety of formats. For now, we‚Äôll focus on reading in data from plain-text flat files.\nMost environmental datasets are stored as flat files, meaning that the data are unstructured ‚Äì¬†the records follow a uniform format, but they are not indexed and no information about relationships between records is included. Plain-text flat files use delimiters such as commas, tabs, or spaces to separate values. Pandas has a few different functions to import flat files, but perhaps the most useful is the pd.read_csv() function, designed to read CSV files. As its name suggests, a CSV (Comma Separated Values) file is a plain-text file that uses commas to delimit (separate) values. Each line of the file is a record (row).\nLet‚Äôs start by taking a look at the pd.read_csv() function.\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\nhelp(pd.read_csv)\n\n\nAs you can see, pd.read_csv() has quite a few parameters. Don‚Äôt be overwhelmed ‚Äì¬†most of these are optional arguments that allow you to specify exactly how your data file is structured and which part(s) you want to import. In particular, the sep parameter allows the user to specify the type of delimiter used in the file. The default is a comma, but you can actually pass other common delimiters (such as sep='\\t', which is a tab) to import other delimited files. The only required argument is a string specifying the filepath of your file.\nIn this exercise, we‚Äôll be importing a CSV file containing radiation data for October 2019 from a Baseline Surface Radiation Network (BSRN) station in Southern Africa. BSRN is a Global Energy and Water Cycle Experiment project aimed at monitoring changes in the Earth‚Äôs surface radiation field. The network is comprised of 64 stations across various climate zones across the globe, whose data are used as the global baseline for surface radiation by the Global Climate Observing System.\nThe CSV file is located in the data folder on the course GitHub repository. The files should already by in your private repo. If you don‚Äôt see the file, you can copy it over from our course master directory by typing the following command:\n\ncp -R EDS217/data eds-217/data\n\nWhile the file may not display properly on the server, the first 10 lines of the file should look like:\nDATE,H_m,SWD_Wm2,STD_SWD,DIR_Wm2,STD_DIR,DIF_Wm2,STD_DIF,LWD_Wm2,STD_LWD,SWU_Wm2,LWU_Wm2,T_degC,RH,P_hPa\n2019-10-01 00:00:00,2,-3,0,0,0,-3,0,300,0.1,0,383,16.2,30.7,966\n2019-10-01 00:01:00,2,-3,0,0,0,-3,0,300,0.3,0,383,16.4,30.7,966\n2019-10-01 00:02:00,2,-3,0,0,0,-3,0,300,0.2,0,383,16.5,30.5,966\n2019-10-01 00:03:00,2,-3,0,0,0,-3,0,300,0.1,0,383,16.5,30.4,966\n2019-10-01 00:04:00,2,-3,0,0,0,-3,0,300,0.1,0,383,16.8,30.5,966\n2019-10-01 00:05:00,2,-2,0,0,0,-2,0,300,0.2,0,383,16.9,30.5,966\n2019-10-01 00:06:00,2,-2,0,0,0,-2,0,300,0.2,0,383,16.8,30.4,966\n2019-10-01 00:07:00,2,-2,0,0,0,-2,0,300,0.1,0,384,17,31,966\n2019-10-01 00:08:00,2,-2,0,0,0,-2,0,300,0.2,0,384,16.7,30.6,966\nThe first line of the file contains the names of the columns, which are described in the table below.\n\n\n\n\n\n\n\nColumn name\nDescription\n\n\n\n\nDATE\nDate/Time\n\n\nH_m\nHeight of measurement (\\text{m})\n\n\nSWD_Wm2\nIncoming shortwave radiation (\\text{W m}^{-2})\n\n\nSTD_SWD\nStandard deviation of incoming shortwave radiation (\\text{W m}^{-2})\n\n\nDIR_Wm2\nDirect radiation (\\text{W m}^{-2})\n\n\nSTD_DIR\nStandard deviation of direct radiation (\\text{W m}^{-2})\n\n\nDIF_Wm2\nDiffuse radiation (\\text{W m}^{-2})\n\n\nSTD_DIF\nStandard deviation of diffuse radiation (\\text{W m}^{-2})\n\n\nLWD_Wm2\nIncoming longwave radiation (\\text{W m}^{-2})\n\n\nSTD_LWD\nStandard deviation of incoming longwave radiation (\\text{W m}^{-2})\n\n\nSWU_Wm2\nOutgoing shortwave radiation (\\text{W m}^{-2})\n\n\nLWU_Wm2\nOutgoing longwave radiation (\\text{W m}^{-2})\n\n\nT_degC\nAir temperature (^{\\circ}\\text{C})\n\n\nRH\nRelative humidity (\\%)\n\n\nP_hPa\nAir pressure (\\text{hPa})\n\n\n\nWe can import the data into pandas using the following syntax:\nbsrn = pd.read_csv('../data/BSRN_GOB_2019-10.csv')\n\n‚úèÔ∏è <b> Try it. </b> \nCopy and paste the code above to import the data in the CSV file into a pandas <code>DataFrame</code> named <code>bsrn</code>.\n\n\nA bit of housekeeping\n\nBefore we move on into viewing and operating on the DataFrame, it‚Äôs worth noting that data import is rarely ever this straightforward. Most raw data require considerable cleaning before they are ready for analysis. Often some of this must happen outside of Python to format the data for import, but ideally the majority of data preprocessing can be conducted in Python ‚Äì allowing you to perform the same operations on multiple datasets at once and making the process easily repeatable.\n\n\n\n\nExamining your DataFrame\n\n\nNow that we‚Äôve loaded in our data, it would be useful to take a look at it. Given the size of our bsrn DataFrame, however, we can‚Äôt simply print out the entire table. The df.head() method allows us to quickly view the first five rows.\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\nbsrn.describe()\n\n\nSimilarly, df.tail() prints the last five rows.\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\nbsrn.tail()\n\n\nBoth df.head() and df.tail() can also accept an integer argument, e.g.¬†df.head(n), where the first n rows will be printed.\n\n‚úèÔ∏è <b> Try it. </b> \nPrint the first and last 10 rows of <code>bsrn</code> using <code>df.head()</code> and <code>df.tail()</code>.\n\nIn addition to those for viewing your data, pandas has several methods to describe attributes of your DataFrame. For example, df.info() provides basic information about the DataFrame:\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\nbsrn.info()\n\n\nThe df.info() method provides several different pieces of information about the DataFrame that are sometimes useful to retrieve separately. For example, df.index returns the index as an iterable object for use in plotting and the df.columns method returns the column names as an index object which can be used in a for loop or to reset the column names. These and other descriptive DataFrame methods are summarized in the table below.\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\n df.info() \nPrints a concise summary of the DataFrame\n\n\n df.head(n) \nReturns the first n rows of the DataFrame\n\n\n df.tail(n) \nReturns the last n rows of the DataFrame\n\n\n df.index \nReturns the index range (number of rows)\n\n\n df.columns \nReturns the column names\n\n\n df.dtypes \nReturns a Series with the data types of each column indexed by column name\n\n\n df.size \nReturns the total number of values in the DataFrame as an int\n\n\n df.shape \nReturns the shape of the DataFrame as a tuple (rows,columns)\n\n\n df.values \nReturns the DataFrame values as a NumPy array (not recommended)\n\n\n df.describe() \nReturns a DataFrame with summary statistics of each column\n\n\n\n\nüìö  Practice 2. Using the DataFrame <code>bsrn</code>:\n<ol class=\"alpha\">\n    <li> Print a list of column names. </li>\n    <li> How many values are there in the entire DataFrame? </li>\n    <li> What is the data type of the first column? </li>\n\n\n\n\nDataFrame indexing + data selection\n\n\nBecause DataFrames can contain labels as well as indices, indexing in pandas DataFrames is a bit more complicated than we‚Äôve seen with strings, lists, and arrays. Generally speaking, pandas allows indexing by either the integer index or the label, but the syntax is a bit different for each.\nThe index operator, which refers to the square brackets following an object [], does not work quite like we might expect it to.\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\nInstead of a value, we get a KeyError. This is because the Index object in pandas is essentially a dictionary, and we have not passed proper keys.\nInstead, pandas uses df.iloc[] for integer-based indexing to select data by position:\nbsrn.iloc[1434,12]\n\n >>>  19.6\n\ndf.iloc acts just like the index operator works with arrays. In addition to indexing a single value, df.iloc can be used to select multiple rows and columns via slicing: df.iloc[row_start:row_end:row_step, col_start:col_end:col_step].\n# Select 6 rows, last 3 columns\nbsrn.iloc[1434:1440,12:]\n\n\n\n\n\n      T_degC    RH  P_hPa\n1434    19.6  17.6    965\n1435    19.5  17.5    965\n1436    19.4  17.4    965\n1437    19.1  17.5    965\n1438    19.4  17.6    965\n1439    19.3  17.5    965\n\n\n\n\n# First 5 columns, every 40th row\nbsrn.iloc[::40,:5]\n\n\n\n\n\n DATE H_m SWD_Wm2 STD_SWD DIR_Wm2 0 2019-10-01 00:00:00 2 -3.0 0.0 0.0 40 2019-10-01 00:40:00 2 -3.0 0.0 0.0 80 2019-10-01 01:20:00 2 -3.0 0.0 0.0 120 2019-10-01 02:00:00 2 -3.0 0.0 0.0 160 2019-10-01 02:40:00 2 -2.0 0.0 0.0 ‚Ä¶ ‚Ä¶ ‚Ä¶ ‚Ä¶ ‚Ä¶ ‚Ä¶ 44440 2019-10-31 20:40:00 2 -2.0 0.0 0.0 44480 2019-10-31 21:20:00 2 -2.0 0.0 0.0 44520 2019-10-31 22:00:00 2 -2.0 0.0 0.0 44560 2019-10-31 22:40:00 2 -2.0 0.0 0.0 44600 2019-10-31 23:20:00 2 -2.0 0.0 0.0\n\n\n\n[1116 rows x 5 columns] \n\n\nRow indexing\nIn addition to df.iloc, rows of a DataFrame can be accessed using df.loc, which ‚Äúlocates‚Äù rows based on their labels. Unless you have set a custom index (which we will see later), the row ‚Äúlabels‚Äù are the same as the integer index.\nWhen indexing a single row, df.loc (like df.iloc) transforms the row into a Series, with the column names as the index:\n# Classic indexing\nbsrn[1434]\n\n\n\n\n\nDATE       2019-10-01 23:54:00\nH_m                          2\nSWD_Wm2                     -2\nSTD_SWD                      0\nDIR_Wm2                      0\nSTD_DIR                      0\nDIF_Wm2                     -2\nSTD_DIF                      0\nLWD_Wm2                    307\nSTD_LWD                    0.1\nSWU_Wm2                      0\nLWU_Wm2                    385\nT_degC                    19.6\nRH                        17.6\nP_hPa                      965\nName: 1434, dtype: object\n\n\n\n\n\nüêç <b>DataFrames + data types.</b>  Notice that the <code>dtype</code> of the Series is an <code>object</code>. This is because the column contains mixed data types ‚Äì floats, integers, and an <code>object</code> in the first row. Unlike NumPy, pandas allows both rows and columns to contain mixed data types. However, while it is perfectly fine (and, in fact, almost always necessary) to have multiple data types within a single <b><i>row</i></b>, it is best if each <b><i>column</i></b> is comprised of a <b><i>single data type</i></b>.\n\nSlicing using df.loc is similar to df.iloc, with the exception that the stop value is inclusive:\n# Using .loc\nbsrn.loc[1434:1440]\n\n\n\n\n\n DATE H_m SWD_Wm2 STD_SWD DIR_Wm2 ‚Ä¶ SWU_Wm2 LWU_Wm2 T_degC RH P_hPa 1434 2019-10-01 23:54:00 2 -2.0 0.0 0.0 ‚Ä¶ 0 385 19.6 17.6 965 1435 2019-10-01 23:55:00 2 -2.0 0.0 0.0 ‚Ä¶ 0 385 19.5 17.5 965 1436 2019-10-01 23:56:00 2 -2.0 0.0 0.0 ‚Ä¶ 0 386 19.4 17.4 965 1437 2019-10-01 23:57:00 2 -2.0 0.0 0.0 ‚Ä¶ 0 386 19.1 17.5 965 1438 2019-10-01 23:58:00 2 -2.0 0.0 0.0 ‚Ä¶ 0 386 19.4 17.6 965 1439 2019-10-01 23:59:00 2 -2.0 0.0 0.0 ‚Ä¶ 0 386 19.3 17.5 965 1440 2019-10-02 00:00:00 2 -2.0 0.0 0.0 ‚Ä¶ 0 386 19.1 17.5 965\n\n\n\n[7 rows x 15 columns] \n\n\n\nColumn indexing\nIn addition to integer indexing with df.iloc, columns can be accessed in two ways: dot notation . or square brackets []. The former takes advantage of the fact that the columns are effectively ‚Äúattributes‚Äù of the DataFrame and returns a Series:\nbsrn.SWD_Wm2\n\n\n\n\n\n0       -3.0\n1       -3.0\n2       -3.0\n3       -3.0\n4       -3.0\n...\n44635   -2.0\n44636   -2.0\n44637   -2.0\n44638   -2.0\n44639   -2.0\nName: SWD_Wm2, Length: 44640, dtype: float64\n\n\n\n\nThe second way of extracting columns is to pass the column name as a string in square brackets, i.e.¬†df['col']:\nbsrn['SWD_Wm2']\n\n\n\n\n\n0       -3.0\n1       -3.0\n2       -3.0\n3       -3.0\n4       -3.0\n...\n44635   -2.0\n44636   -2.0\n44637   -2.0\n44638   -2.0\n44639   -2.0\nName: SWD_Wm2, Length: 44640, dtype: float64\n\n\n\n\nUsing single brackets, the result is a Series. However, using double brackets, it is possible to return the column as a DataFrame:\nbsrn[['SWD_Wm2']]\n\n\n\n\n\n SWD_Wm2 0 -3.0 1 -3.0 2 -3.0 3 -3.0 4 -3.0 ‚Ä¶ ‚Ä¶ 44635 -2.0 44636 -2.0 44637 -2.0 44638 -2.0 44639 -2.0\n\n\n\n[44640 rows x 1 columns] \n\nThis allows you to add additional columns, which you cannot do with a Series object. Furthermore, with the double bracket notation, a list is being passed to the index operator (outer brackets). Thus, it is possible to extract multiple columns by adding column names to the list:\nbsrn[['SWD_Wm2','LWD_Wm2']]\n\n\n\n\n\n SWD_Wm2 LWD_Wm2 0 -3.0 300.0 1 -3.0 300.0 2 -3.0 300.0 3 -3.0 300.0 4 -3.0 300.0 ‚Ä¶ ‚Ä¶ ‚Ä¶ 44635 -2.0 380.0 44636 -2.0 380.0 44637 -2.0 380.0 44638 -2.0 381.0 44639 -2.0 381.0\n\n\n\n[44640 rows x 2 columns] \n\nWhen accessing a single column, the choice between using dot notation and square brackets is more or less a matter of preference. However, there are occasions when the bracket notation proves particularly useful. For example, you could access each column in a DataFrame by iterating through df.columns, which returns an Index object containing the column names as str objects that can be directly passed to the index operator. Additionally, you may find it useful to use the double bracket syntax to return a DataFrame object, rather than a Series, which can only ever contain a single column of data.\n\nüìö  Practice 3.\n<ol class=\"alpha\">\n    <li> Create a new DataFrame containing the first record for each day and the following columns: the timestamp of the record, incoming shortwave radiation, direct and diffuse radiation, and incoming longwave radiation. (Hint: the BSRN station collects data every minute). </li>\n    <li> Create a new Series containing the temperature values every hour at the top of the hour. </li>\n</ol>\n\n\n\n\nDatetime objects\n\n\nLike the BSRN data we are working with in this exercise, many environmental datasets include timed records. Python has a few different libraries for dealing with timestamps, which are referred to as datetime objects. The standard datetime library is the primary way of manipulating dates and times in Python, but there are additional third-party packages that provide additional support. A few worth exploring are dateutil, an extension of the datetime library useful for parsing timestamps, and pytz, which provides a smooth way of tackling time zones.\nThough we will not review datetime objects in depth here, it is useful to understand the basics of how to deal with datetime objects in Python as you will no doubt encounter them in the future. For now, we will focus on a few pandas functions built on the datetime library to handle datetime objects.\nThe pd.date_range() function allows you to build a DatetimeIndex with a fixed frequency. This can be done by specifying a start date and an end date as follows:\npd.date_range('4/1/2017','4/30/2017')\n\n>>> DatetimeIndex(['2017-01-01', '2017-01-02', '2017-01-03', '2017-01-04',\n                   '2017-01-05', '2017-01-06', '2017-01-07', '2017-01-08',\n                   '2017-01-09', '2017-01-10',\n                   ...\n                   '2020-12-22', '2020-12-23', '2020-12-24', '2020-12-25',\n                   '2020-12-26', '2020-12-27', '2020-12-28', '2020-12-29',\n                   '2020-12-30', '2020-12-31'],\n                  dtype='datetime64[ns]', length=1461, freq='D')\nBecause it was not specified otherwise, the frequency was set as the default, daily. To return a different frequency, we could use the freq parameter:\n# Specify start and end, minute-ly frequency\npd.date_range('1/1/2017','12/31/2020', freq='min')\n\n>>> DatetimeIndex(['2017-01-01 00:00:00', '2017-01-01 00:01:00',\n                   '2017-01-01 00:02:00', '2017-01-01 00:03:00',\n                   '2017-01-01 00:04:00', '2017-01-01 00:05:00',\n                   '2017-01-01 00:06:00', '2017-01-01 00:07:00',\n                   '2017-01-01 00:08:00', '2017-01-01 00:09:00',\n                   ...\n                   '2020-12-30 23:51:00', '2020-12-30 23:52:00',\n                   '2020-12-30 23:53:00', '2020-12-30 23:54:00',\n                   '2020-12-30 23:55:00', '2020-12-30 23:56:00',\n                   '2020-12-30 23:57:00', '2020-12-30 23:58:00',\n                   '2020-12-30 23:59:00', '2020-12-31 00:00:00'],\n                  dtype='datetime64[ns]', length=2102401, freq='T')\n\n# Specify start and end, monthly frequency\npd.date_range('1/1/2017','12/31/2020', freq='M')\n\n>>> DatetimeIndex(['2017-01-31', '2017-02-28', '2017-03-31', '2017-04-30',\n                   '2017-05-31', '2017-06-30', '2017-07-31', '2017-08-31',\n                   '2017-09-30', '2017-10-31', '2017-11-30', '2017-12-31',\n                   '2018-01-31', '2018-02-28', '2018-03-31', '2018-04-30',\n                   '2018-05-31', '2018-06-30', '2018-07-31', '2018-08-31',\n                   '2018-09-30', '2018-10-31', '2018-11-30', '2018-12-31',\n                   '2019-01-31', '2019-02-28', '2019-03-31', '2019-04-30',\n                   '2019-05-31', '2019-06-30', '2019-07-31', '2019-08-31',\n                   '2019-09-30', '2019-10-31', '2019-11-30', '2019-12-31',\n                   '2020-01-31', '2020-02-29', '2020-03-31', '2020-04-30',\n                   '2020-05-31', '2020-06-30', '2020-07-31', '2020-08-31',\n                   '2020-09-30', '2020-10-31', '2020-11-30', '2020-12-31'],\n                  dtype='datetime64[ns]', freq='M')\nThere are many other parameters for the pd.date_range() function, as well as other pandas functions. More useful to us, however, are the functions for dealing with existing timestamps, such as those in our bsrn DataFrame.\n\nParsing dates in pandas\nLet‚Äôs start by taking a look at bsrn.DATE, which contains the timestamps for each record of our BSRN data.\nbsrn.DATE\n\n\n\n\n\n0        2019-10-01 00:00:00\n1        2019-10-01 00:01:00\n2        2019-10-01 00:02:00\n3        2019-10-01 00:03:00\n4        2019-10-01 00:04:00\n...\n44635    2019-10-31 23:55:00\n44636    2019-10-31 23:56:00\n44637    2019-10-31 23:57:00\n44638    2019-10-31 23:58:00\n44639    2019-10-31 23:59:00\nName: DATE, Length: 44640, dtype: object\n\n\n\n\nWhile the values certainly resemble datetime objects, they are stored in pandas as ‚Äúobjects,‚Äù which basically means that pandas doesn‚Äôt recognize the data type ‚Äì¬†it doesn‚Äôt know how to handle them. Using the pd.to_datetime() function, we can convert this column to datetime objects:\npd.to_datetime(bsrn.DATE)\n\n\n\n\n\n0       2019-10-01 00:00:00\n1       2019-10-01 00:01:00\n2       2019-10-01 00:02:00\n3       2019-10-01 00:03:00\n4       2019-10-01 00:04:00\n...\n44635   2019-10-31 23:55:00\n44636   2019-10-31 23:56:00\n44637   2019-10-31 23:57:00\n44638   2019-10-31 23:58:00\n44639   2019-10-31 23:59:00\nName: DATE, Length: 44640, dtype: datetime64[ns]\n\n\n\n\nNotice that ostensibly nothing has changed, but the dtype is now a datetime object, making it much easier to manipulate not only this column, but the entire DataFrame. For instance, now that we‚Äôve told pandas that this column contains timestamps, we can set this column as the index using df.set_index().\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\n# Convert bsrn.DATE column to datetime objects\nbsrn = pd.read_csv('../data/BSRN_GOB_2019-10.csv')\nbsrn['DATE'] = pd.to_datetime(bsrn.DATE)  # Note: overwriting a column like this is NOT recommended.\n# Set bsrn.DATE as the DataFrame index\nbsrn.set_index('DATE', inplace=True)\n\n\nAs noted in the comment in the cell above, reseting the values in a column as we did in the first line of code is generally not recommended, but in this case, since we knew exactly what the result would be, it‚Äôs acceptable. Also, notice the inplace=True argument passed to df.set_index(). This prevented us from having to copy the DataFrame to a new variable, instead performing the operation in-place.\nLet‚Äôs take a look at our DataFrame again:\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\nbsrn.info()\n\n\nAs expected, the index has been changed to a DatetimeIndex, and there is no longer a 'DATE' column. Had we wanted to keep the timestamps as a column as well, we could have passed drop=False to df.set_index(), telling pandas not to drop (or delete) the 'DATE' column. We can look at the DatetimeIndex just as before using df.index.\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\nbsrn.describe()\n\n\nNow that we have a DatetimeIndex, we can access specific attributes of the datetime objects like the year, day, hour, etc. To do this, we add the desired time period using dot notation: df.index.attribute. For a full list of attributes, see the pd.DatetimeIndex documentation. For example:\n# Get the hour of each record\nbsrn.index.hour\n\n\n\n\n\nInt64Index([ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n...\n23, 23, 23, 23, 23, 23, 23, 23, 23, 23],\ndtype='int64', name='DATE', length=44640)\n\n\n\n\nThe result is a pandas Index object with the same length as the original DataFrame. To return only the unique values, we use the Series.unique() function, which can be used on any Series object (including a column of a DataFrame):\n# Get the unique hour values\nbsrn.index.hour.unique()\n\n\n\n\n\nInt64Index([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,\n17, 18, 19, 20, 21, 22, 23],\ndtype='int64', name='DATE')\n\n\n\n\n\nüêç <b>Method chaining.</b>  This process of stringing multiple methods together in a single line of code is called <b>method chaining</b>, a hallmark of object-oriented programming. Method chaining is a means of concatenating functions in order to quickly complete a series of data transformations. In pandas, we often use method chaining in aggregation processes to perfrom calculations on groups or selections of data. Methods are appended using dot notation to the end of a command. Any code that is expressed using method chaining could also be written using a series of commands (and vice versa). Method chaining is common in JavaScript, and while it is not widely used in Python, it is commonly applied in pandas.\n\nDealing with datetime objects can be tricky and often requires a bit of trial and error before the timestamps are in the desired format. If you know the format of your dataset and its timestamp records, you can parse the datetimes and set the index when reading in the data. For example, we could have imported our data as follows:\nbsrn = pd.read_csv('../data/BSRN_GOB_2019-10.csv',index_col=0,parse_dates=True)\nThis would have accomplished what we ultimately did in three lines in a single line of code. But remember, working with most raw datasets is rarely this straightforward ‚Äì¬†even the file we are using in this exercise was preprocessed to streamline the import process!\n\n\n\nA few useful operations\n\n\nNow that our DataFrame is a bit cleaner ‚Äì each of the columns contains a single, numeric data type ‚Äì we are ready to start working with our data. Next, we‚Äôll explore DataFrame reduction operations, how to add and delete data, and concatenation in pandas.\n\nDataFrame reduction\nMuch like NumPy, pandas has several useful methods for reducing data to a single statistic. These are intuitively named and include: df.mean(), df.median(), df.sum(), df.max(), df.min(), and df.std(). Unlike array reduction, however, these basic statistical methods in pandas operate column-wise, returning a Series containing the statistic for each column indexed by column name. For example:\n# Calculate median of each column\nbsrn.median()\n\n\n\n\n\nH_m          2.0\nSWD_Wm2     27.0\nSTD_SWD      0.3\nDIR_Wm2      0.0\nSTD_DIR      0.0\nDIF_Wm2     19.0\nSTD_DIF      0.1\nLWD_Wm2    340.0\nSTD_LWD      0.1\nSWU_Wm2     11.0\nLWU_Wm2    432.0\nT_degC      22.4\nRH          33.1\nP_hPa      965.0\ndtype: float64\n\n\n\n\nTo retrieve the value for just a single column, you can use indexing to call the column as a Series:\n# Calculate median incoming shortwave radiation\nbsrn.SWD_Wm2.median()\n\n >>>  27.0\n\nFurthermore, while it is not apparent in this example, pandas default behaviour is to ignore NaN values when performing computations. This can be changed by passing skipna=False to the reduction method (e.g.¬†df.median(skipna=False)), though skipping NaNs is often quite useful!\n\nüìö  <b> Practice 4. </b> Calculate the mean incoming shortwave, outgoing shortwave, incoming longwave, and outgoing longwave radiation over the entire month.\n\n\n\nAdding data\nMuch like when we converted bsrn.DATE to datetime objects, a column can be added to a DataFrame using square bracket notation with a new column label as a string. The data for the new column can come in the form of a list, Series, or a single value:\ndf = pd.DataFrame([[25.8, 28.1, 16.2, 11.0],\n                   [17.9, 14.2, 18.8, 28.0],\n                   [23.6, 18.4, 29.9, 27.8],\n                   [23.6, 36.2, 22.1, 14.5]],\n                 columns=['A','B','C','D'])\n\n# Add a column from a list\ndf['E'] = [13.0, 40.1, 39.8, 28.2]\n\n# Add a column from a Series\ndf['F'] = pd.Series([18, 22, 30, 24])\n\n# Propagate a single value through all rows\ndf['G'] = 'blue'\n\ndf\n\n\n\n\n\n      A     B     C     D     E   F     G\n0  25.8  28.1  16.2  11.0  13.0  18  blue\n1  17.9  14.2  18.8  28.0  40.1  22  blue\n2  23.6  18.4  29.9  27.8  39.8  30  blue\n3  23.6  36.2  22.1  14.5  28.2  24  blue\n\n\n\n\nNew columns can also be added as the result of an arithmetic operation (e.g.¬†sum, product, etc.) performed on one or more existing columns:\n# Add a new column by converting values in df.A from ¬∞C to ¬∞F\ndf['A_degF'] = (df['A'] * (9/5)) + 32\n\n# Add a new column representing the difference between df.B and df.C\ndf['BC_diff'] = df.B - df.C\n\ndf\n\n\n\n\n\n      A     B     C     D     E   F     G  A_degF  BC_diff\n0  25.8  28.1  16.2  11.0  13.0  18  blue   78.44     11.9\n1  17.9  14.2  18.8  28.0  40.1  22  blue   64.22     -4.6\n2  23.6  18.4  29.9  27.8  39.8  30  blue   74.48    -11.5\n3  23.6  36.2  22.1  14.5  28.2  24  blue   74.48     14.1\n\n\n\n\nFinally, you can use a Boolean expression to add a column, which contains Boolean objects (True or False) based on the condition. For example:\n# Add a column with Booleans for values in df.D greater than or equal to 20.0\ndf['D_20plus'] = df.D >= 20.0\n\ndf\n\n\n\n\n\n      A     B     C     D     E   F     G  A_degF  BC_diff  D_20plus\n0  25.8  28.1  16.2  11.0  13.0  18  blue   78.44     11.9     False\n1  17.9  14.2  18.8  28.0  40.1  22  blue   64.22     -4.6      True\n2  23.6  18.4  29.9  27.8  39.8  30  blue   74.48    -11.5      True\n3  23.6  36.2  22.1  14.5  28.2  24  blue   74.48     14.1     False\n\n\n\n\nThese conditional expressions can also be used to create Boolean masks, which allow you to ‚Äúmask‚Äù the values in the DataFrame that do not meet a condition, only extracting those that do. For example, let‚Äôs use a Boolean mask to apply an mathematical expression on only certain values in column 'D':\n# Subtract 20 from all values in dfD greater than or equal to 20\ndf['D_less20'] = df.D[df.D >= 20.0] - 20.0\n\ndf\n\n\n\n\n\n      A     B     C     D     E   F     G  A_degF  BC_diff  D_20plus  D_less20\n0  25.8  28.1  16.2  11.0  13.0  18  blue   78.44     11.9     False       NaN\n1  17.9  14.2  18.8  28.0  40.1  22  blue   64.22     -4.6      True       8.0\n2  23.6  18.4  29.9  27.8  39.8  30  blue   74.48    -11.5      True       7.8\n3  23.6  36.2  22.1  14.5  28.2  24  blue   74.48     14.1     False       NaN\n\n\n\n\nAll values that do not meet the condition are hidden from the expression, leaving NaNs in the resulting column. Boolean masks come in quite handy in data analysis, as they allow you to extract certain rows from a DataFrame based on their values in one or more columns.\nFurthermore, in addition to simply adding columns, new columns can be inserted in a desired index position using df.insert() with arguments specifying the location, name, and values of the column:\n# Create list of seasons\nseasons = ['winter', 'spring', 'summer', 'fall']\n\n# Insert season as first column\ndf.insert(0, 'SEASON', seasons)\n\ndf\n\n\n\n\n\n   SEASON     A     B     C     D     E   F     G  A_degF  BC_diff  D_20plus  D_less20\n0  winter  25.8  28.1  16.2  11.0  13.0  18  blue   78.44     11.9     False       NaN\n1  spring  17.9  14.2  18.8  28.0  40.1  22  blue   64.22     -4.6      True       8.0\n2  summer  23.6  18.4  29.9  27.8  39.8  30  blue   74.48    -11.5      True       7.8\n3    fall  23.6  36.2  22.1  14.5  28.2  24  blue   74.48     14.1     False       NaN\n\n\n\n\n\n\nRemoving data\nUnlike adding new data columns, removing columns from a DataFrame should be done with caution. In fact, it‚Äôs not a bad idea to create a copy of your DataFrame before performing any operations. This will allow you to return to the original data as needed without having to re-import or re-initialize the DataFrame. If you do need to remove a column, you can use the del command:\n# Delete 'G' from df\ndel df['G']\n\ndf\n\n\n\n\n\n   SEASON     A     B     C     D     E   F  A_degF  BC_diff  D_20plus  D_less20\n0  winter  25.8  28.1  16.2  11.0  13.0  18   78.44     11.9     False       NaN\n1  spring  17.9  14.2  18.8  28.0  40.1  22   64.22     -4.6      True       8.0\n2  summer  23.6  18.4  29.9  27.8  39.8  30   74.48    -11.5      True       7.8\n3    fall  23.6  36.2  22.1  14.5  28.2  24   74.48     14.1     False       NaN\n\n\n\n\nNote that this is an in-place operation, meaning that the column is deleted from the original variable. Alternatively, you can use df.pop() to extract a column. This method allows a column values to be extracted (and deleted) from a DataFrame and assigned to a new variable:\n# Extract column 'F' from df as a new Series\ndf_F = df.pop('F')\n\ndf\n\n\n\n\n\n   SEASON     A     B     C     D     E  A_degF  BC_diff  D_20plus  D_less20\n0  winter  25.8  28.1  16.2  11.0  13.0   78.44     11.9     False       NaN\n1  spring  17.9  14.2  18.8  28.0  40.1   64.22     -4.6      True       8.0\n2  summer  23.6  18.4  29.9  27.8  39.8   74.48    -11.5      True       7.8\n3    fall  23.6  36.2  22.1  14.5  28.2   74.48     14.1     False       NaN\n\n\n\n\n\n\nApplying functions\nIn addition to manipulating individual columns, you can apply a function to an entire Series or DataFrame using the pandas function df.apply(). For example, consider our original DataFrame df, which consists of temperature values in ¬∞C:\ndf = pd.DataFrame([[25.8, 28.1, 16.2, 11.0],[17.9, 14.2, 18.8, 28.0],\n                   [23.6, 18.4, 29.9, 27.8],[23.6, 36.2, 22.1, 14.5]],\n                 columns=['A','B','C','D'])\ndf\n\n\n\n\n\n      A     B     C     D\n0  25.8  28.1  16.2  11.0\n1  17.9  14.2  18.8  28.0\n2  23.6  18.4  29.9  27.8\n3  23.6  36.2  22.1  14.5\n\n\n\n\nWe previously used arithmetic operators to convert column 'A' to ¬∞F, but we could also use a function. First, let‚Äôs define a function convert_CtoF to convert temperature values from Celsius to Fahrenheit:\ndef convert_CtoF(degC):\n    \"\"\" Converts a temperature to from Celsius to Fahrenheit\n    \n    Parameters\n    ----------\n        degC : float\n            Temperature value in ¬∞C\n       \n    Returns\n    -------\n        degF : float\n            Temperature value in ¬∞F\n    \"\"\"\n    \n    degF = (degC *(9./5)) + 32\n    \n    return degF\nUsing df.apply() we can use this function to convert values in column 'A' as follows:\ndf.A.apply(convert_CtoF)\n\n\n\n\n\n0    78.44\n1    64.22\n2    74.48\n3    74.48\nName: A, dtype: float64\n\n\n\n\nWhere this becomes especially useful is for operating on entire DataFrames. You have to be careful with this if your DataFrame contains multiple data types, but it works well when you need to perform an operation on an entire DataFrame. For example, we could convert all of the values in df by iterating through the columns, or, using df.apply(), we could acheive the same result in a single line of code:\ndf.apply(convert_CtoF)\n\n\n\n\n\n       A      B      C      D\n0  78.44  82.58  61.16  51.80\n1  64.22  57.56  65.84  82.40\n2  74.48  65.12  85.82  82.04\n3  74.48  97.16  71.78  58.10\n\n\n\n\n\nüìö  <b> Practice 5. </b>\n<ol class=\"alpha\">\n    <li> Add a column <code style='font-weight:normal'>'NET_SW'</code> to <code style='font-weight:normal'>bsrn</code> with the net shortwave radiation. </li>\n    <li> Add a column <code style='font-weight:normal'>'NET_LW'</code> to <code style='font-weight:normal'>bsrn</code> with the net longwave radiation. </li>\n    <li> Add a column <code style='font-weight:normal'>'NET_RAD'</code> to <code style='font-weight:normal'>bsrn</code> with the net total radiation. Net radiation is given by the following equation: </li>\n    $$R^{}_{N} \\, = \\,  R^{\\, \\downarrow}_{SW} \\, - \\,  R^{\\, \\uparrow}_{SW} \\, + \\, R^{\\, \\downarrow}_{LW} \\, - \\,  R^{\\, \\uparrow}_{LW}$$\n    where $R^{\\, \\downarrow}_{SW}$ and $R^{\\, \\uparrow}_{SW}$ are incoming and outgoing shortwave radiation, respectively, and $R^{\\, \\downarrow}_{LW}$ and $R^{\\, \\uparrow}_{LW}$ are incoming and outgoing longwave radiation, respectively.\n    <li> Create a new DataFrame with the day of the month and daily mean values of shortwave incoming, shortwave outgoing, longwave incoming, longwave outgoing radiation, and net total radiation. (Hint: use masking!).</li>\n</ol>\n\n\n\nCombining DataFrames\nThere are several ways to combine data from multiple Series or DataFrames into a single object in pandas. These functions include pd.append(), pd.join(), and pd.merge(). We will focus on the general pd.concat() function, which is the most versatile way to concatenate pandas objects. To learn more about these other functions, refer to the pandas documentation or see  Chapter 3 of the  Python Data Science Handbook.\nLet‚Äôs start by considering the simplest case of two DataFrames with identical columns:\ndf1 = pd.DataFrame([['Los Angeles', 34.0522, -118.2437],\n                    ['Bamako', 12.6392, 8.0029],\n                    ['Johannesburg', -26.2041, 28.0473],\n                    ['Cairo', 30.0444, 31.2357]],\n                  columns=['CITY', 'LAT', 'LONG'])\n\ndf2 = pd.DataFrame([['Cape Town', -33.9249, 18.4241],\n                    ['Kyoto', 35.0116, 135.7681],\n                    ['London', 51.5074, -0.1278],\n                    ['Cochabamba', -17.4140, -66.1653]],\n                  columns=['CITY', 'LAT', 'LONG'])\nUsing pd.concat([df1,df2]), we can combine the two DataFrames into one. Notice that we must pass the DataFrames as a list, because pd.concat() requires an iterable object as its input.\n# Concatenate df1 and df2\ncity_coords = pd.concat([df1,df2])\n\ncity_coords\n\n\n\n\n\n           CITY      LAT      LONG\n0   Los Angeles  34.0522 -118.2437\n1        Bamako  12.6392    8.0029\n2  Johannesburg -26.2041   28.0473\n3         Cairo  30.0444   31.2357\n0     Cape Town -33.9249   18.4241\n1         Kyoto  35.0116  135.7681\n2        London  51.5074   -0.1278\n3    Cochabamba -17.4140  -66.1653\n\n\n\n\nBy default, pandas concatenates along the row axis, appending the values in df2 to df1 as new rows. However, notice that the original index values have been retained. Since these index labels do not contain useful information, it would be best to reset the index before proceeding. This can be done in one of two ways. First, we could have passed ignore_index=True to the pd.concat() function, telling pandas to ignore the index labels. Since we have already created a new variable, however, let‚Äôs use a more general method: df.reset_index().\n# Reset index in-place and delete old index\ncity_coords.reset_index(inplace=True, drop=True)\n\ncity_coords\n\n\n\n\n\n           CITY      LAT      LONG\n0   Los Angeles  34.0522 -118.2437\n1        Bamako  12.6392    8.0029\n2  Johannesburg -26.2041   28.0473\n3         Cairo  30.0444   31.2357\n4     Cape Town -33.9249   18.4241\n5         Kyoto  35.0116  135.7681\n6        London  51.5074   -0.1278\n7    Cochabamba -17.4140  -66.1653\n\n\n\n\nBy passing the optional inplace and drop parameters, we ensured that pandas would reset the index in-place (the default is to return a new DataFrame) and drop the old index (the default behaviour is to add the former index as a column).\nNow let‚Äôs consider the case of concatenating two DataFrames whose columns do not match. In this case, pandas will keep source rows and columns separate in the concatenated DataFrame, filling empty cells with NaN values:\ndf3 = pd.DataFrame([['USA', 87],['Mali', 350],['South Africa', 1753],['Egypt', 23],\n                    ['South Africa', 25],['Japan', 47],['UK', 11],['Bolivia', 2558]],\n                  columns=['COUNTRY', 'ELEV'])\n\n# Concatenate cities1 and df3\npd.concat([city_coords,df3])\n\n\n\n\n\n           CITY      LAT      LONG       COUNTRY    ELEV\n0   Los Angeles  34.0522 -118.2437           NaN     NaN\n1        Bamako  12.6392    8.0029           NaN     NaN\n2  Johannesburg -26.2041   28.0473           NaN     NaN\n3         Cairo  30.0444   31.2357           NaN     NaN\n4     Cape Town -33.9249   18.4241           NaN     NaN\n5         Kyoto  35.0116  135.7681           NaN     NaN\n6        London  51.5074   -0.1278           NaN     NaN\n7    Cochabamba -17.4140  -66.1653           NaN     NaN\n0           NaN      NaN       NaN           USA    87.0\n1           NaN      NaN       NaN          Mali   350.0\n2           NaN      NaN       NaN  South Africa  1753.0\n3           NaN      NaN       NaN         Egypt    23.0\n4           NaN      NaN       NaN  South Africa    25.0\n5           NaN      NaN       NaN         Japan    47.0\n6           NaN      NaN       NaN            UK    11.0\n7           NaN      NaN       NaN       Bolivia  2558.0\n\n\n\n\nInstead, we must pass axis=1 to the function to specify that we want to add the data in df3 as columns to the new DataFrame:\n# Concatenate along column axis\ncities = pd.concat([city_coords,df3], axis=1)\n\ncities\n\n\n\n\n\n           CITY      LAT      LONG       COUNTRY  ELEV\n0   Los Angeles  34.0522 -118.2437           USA    87\n1        Bamako  12.6392    8.0029          Mali   350\n2  Johannesburg -26.2041   28.0473  South Africa  1753\n3         Cairo  30.0444   31.2357         Egypt    23\n4     Cape Town -33.9249   18.4241  South Africa    25\n5         Kyoto  35.0116  135.7681         Japan    47\n6        London  51.5074   -0.1278            UK    11\n7    Cochabamba -17.4140  -66.1653       Bolivia  2558\n\n\n\n\n\nüìö  <b> Practice 6. </b> \n<ol class=\"alpha\">\n    <li> Concatenate <code>df1</code> and <code>df2</code> into a new DataFrame with all 9 rivers.</li>\n    <li> Create a new DataFrame <code>rivers</code> with the discharge, mouth, source, and continent information and add this to your DataFrame from (a) to produce a DataFrame with all of the data in the table below.</li>\n\n\n\n\n\nRiver\n\n\nLength (\\text{km})\n\n\nDrainage area (\\text{km}^2)\n\n\nDischarge (\\text{m}^3/\\text{s})\n\n\nMouth\n\n\nSource\n\n\nContinent\n\n\n\n\nAmazon\n\n\n6400\n\n\n7,050,000\n\n\n209,000\n\n\nAtlantic Ocean\n\n\nRio Mantaro\n\n\nSouth America\n\n\n\n\nCongo\n\n\n4371\n\n\n4,014,500\n\n\n41,200\n\n\nAtlantic Ocean\n\n\nLualaba River\n\n\nAfrica\n\n\n\n\nYangtze\n\n\n6418\n\n\n1,808,500\n\n\n30,166\n\n\nEast China Sea\n\n\nJianggendiru Glacier\n\n\nAsia\n\n\n\n\nMississippi\n\n\n3730\n\n\n3,202,230\n\n\n16,792\n\n\nGulf of Mexico\n\n\nLake Itasca\n\n\nNorth America\n\n\n\n\nZambezi\n\n\n2574\n\n\n1,331,000\n\n\n3,400\n\n\nIndian Ocean\n\n\nMiombo Woodlands\n\n\nAfrica\n\n\n\n\nMekong\n\n\n4023\n\n\n811,000\n\n\n16,000\n\n\nSouth China Sea\n\n\nLasagongma Spring\n\n\nAsia\n\n\n\n\nMurray\n\n\n2508\n\n\n1,0614,69\n\n\n767\n\n\nSouthern Ocean\n\n\nAustralian Alps\n\n\nOceania\n\n\n\n\nRh√¥ne\n\n\n813\n\n\n98,000\n\n\n1,710\n\n\nMediterranean Sea\n\n\nRh√¥ne Glacier\n\n\nEurope\n\n\n\n\nCubango\n\n\n1056\n\n\n530,000\n\n\n475\n\n\nOkavango Delta\n\n\nBi√© Plateau\n\n\nAfrica\n\n\n\n\n\n\n\n\nData export\n\n\nWhile you will most likely use pandas DataFrames to manipulate data, perform statistical analyses, and visualize results within Python, you may encounter scenarios where it is useful to ‚Äúsave‚Äù a DataFrame with which you‚Äôve been working. Exporting data from pandas is analogous to importing it.\nLet‚Äôs take the example of the cities DataFrame we created in the last example. Now that we‚Äôve compiled GPS coordinates of various cities, let‚Äôs say we wanted to load these data into a GIS software application. We could export this DataFrame using df.to_csv() specifying the file name with the full file path as follows:\ncities.to_csv('./exports/cities.csv')\n\nüìö  <b> Practice 7. </b> \nUsing the example above, export your <code>rivers</code> DataFrame to a CSV file in the <code>exports</code> folder. Make sure you have copied this folder over from your local copy of <code>envdatasci</code> to the <code>exercises</code> folder of your private repository first!\n\n\n\nCongratulations!\nYou made it to the end of your first journey with Pandas. You deserve a warm, fuzzy reward‚Ä¶\n\n\nCode\nfrom IPython.display import YouTubeVideo\nid='Z98ZxYFsIWo'\nYouTubeVideo(id=id,width=600,height=300)\n\n\n\n\n\n\nCode\n# IGNORE THIS CELL\nfrom IPython.core.display import HTML\ndef css_styling():\n    styles = open(\"./styles/exercises.css\", \"r\").read()\n    return HTML(styles)\ncss_styling()"
  },
  {
    "objectID": "answerkeys/Exercise1-4_Key.html#tuples",
    "href": "answerkeys/Exercise1-4_Key.html#tuples",
    "title": "",
    "section": "Tuples",
    "text": "Tuples\nTuples are a type of sequence, similar to list, which you‚Äôve already seen. They primary difference between a tuple and a list is that a tuple is immutable, which means that it‚Äôs value cannot be changed once it is defined. A tuple is implemented using ():\nnum_tuple = (4, 23, 654, 2, 0, -12, 4391)\nstr_tuple = ('energy', 'water', 'carbon')\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\n# Define tuple variables\nnum_tuple = (4, 23, 654, 2, 0, -12, 4391)\nstr_tuple = ('energy', 'water', 'carbon')\n\n\nAs with a list, a tuple may contain mixed data types, but this is not usually recommended.\nBecause they are both sequences, tuples and lists share many of the same methods. For example, just like lists, the len() command returns the length of the tuple.\nlen(str_tuple)\n>>> 3\nThe min() and max() commands can also be used to find the minimum and maximum values in a tuple. For a tuple of strings, this corresponds to the alphabetically first and last elements.\nmin(str_tuple)\n>>> 'carbon'\n\nmax(str_tuple)\n>>> 'water'\n\n‚úèÔ∏è <b> Try it. </b> \nUse the <code>len()</code>, <code>min()</code>, and <code>max()</code> commands to find the length, minimum, and maximum of <code>num_tuple</code>.\n\n\n\nCode\n# Find the length of num_tuple\nprint(len(num_tuple))\n# Minimum value of num_tuple\nprint(min(num_tuple))\n# Maximum value of num_tuple\nprint(max(num_tuple))\n\n\n7\n-12\n4391\n\n\n\n\n\nOther ways to create tuples\nTuples can also be constructed by:\n\n\nUsing a pair of parentheses to indicate an empty tuple: ()\n\nUsing a trailing comma for a tuple with a single element: a, or (a,)\n\nSeparating items with commas: a, b, c or (a, b, c)\n\nusing the tuple() built-in function: tuple(iterable).\n\n\nüêç <b>Note.</b> An <i>iterable</i> is any object that is capable of returning its contents one at a time. Strings are iterable objects, so <code>tuple('abc')</code> returns <code>('a', 'b', 'c')</code>.\n\ntuple('earth')\n>>> ('e', 'a', 'r', 't', 'h')\n\nüìö  <b> Practice 1. </b> \nCreate three separate <b>tuples</b> containing the latitude and longitudes of the following cities: \n\nLos Angeles, CA (34.05, -118.25)\nJohannesburg, South Africa (-26.20, 28.05)\nCairo, Egypt (30.03, 31.23)\nCreate a fourth tuple that is made up of the three tuples (i.e.¬†a ‚Äútuple of tuples‚Äù).\n\n\n\n\nCode\n# Define a three new tuples, one for each city.\n\n# Los Angeles\nlos_angeles = (34.05, -118.25)\n# Johannesburg\njohannesburg = (-26.20, 28.05)\n# cairo\ncairo = (30.03, 31.23)\n# Create a new tuple that is a tuple made up of the three city location tuples:\ntuple_of_tuples = (los_angeles, johannesburg, cairo)\n\n\n\n\nIndexing\nAs you learned with lists, any element of a sequence data type can be referenced by its position within the sequence. To access an element in a sequence by its index, use square brackets [].\nIndividual elements of tuples are accessed in the exact same manner as lists:\nnum_tuple[0]\n>>> 4\nnum_tuple[-2]\n>>> -12\nword_tuple = tuple('antidisestablishmentarianism')\n\nword_tuple[14]\n>>> 's'\n\nword_tuple[::3]\n>>> 'aistlhnrnm'\n\n‚úèÔ∏è <b> Try it. </b> \nUse indexing to create a new tuple from the 2nd element in <code>str_tuple</code>. Find the 3rd element of this new tuple.\n\n\n\nCode\n# new_tuple = \nnew_tuple = tuple(str_tuple[1])\n# 3rd element of new_tuple:\nnew_tuple[2]\n\n\n't'\n\n\n\n\n\n\nImmutability\nAll objects in python are either mutable or immutable. A mutable object is one whose value can change. In contrast, an immutable object has a fixed value. You‚Äôve already been introduced to a few immutable objects including numbers, strings and now, tuples. These objects cannot be altered once created.\n\nüêç <b>Note.</b>  If you attempt to modify the value of an existing tuple, you will get a <code>TypeError</code> exception from the Python interpreter.\n\nnum_tuple[0] = 3\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n<ipython-input> in <module>\n----> 1 num_tuple[0] = 1\n\nTypeError: 'tuple' object does not support item assignment\n    \n\n\n\n\nTuple Operations\nBecause they are immutable, tuples do not have the same robust set of functions that lists have. Attempting to change a tuple (for example, by trying to append elements) will raise an AttributeError, because the append method isn‚Äôt available to tuple objects.\n\ntuple_of_colors = ('red', 'blue', 'green', 'black', 'white')\ntuple_of_colors.append('pink') # <- UH-OH!\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\n<ipython-input-8-857308f688f6> in <module>\n----> 1 tuple_of_colors.append('pink')\n\nAttributeError: 'tuple' object has no attribute 'append'\nInstead of appending data to an existing tuple, when you want to change the contents of a tuple, you need to either create a new one, or modify the variable by re-defining it.\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\ntuple_of_colors = ('red', 'blue', 'green', 'black', 'white')\ntuple_of_colors = tuple_of_colors + tuple('pink')\n\n\n\n\n\n\nDIVING DEEPER: Named Tuples (Python 3.6+)\nTuples are convenient for storing information that you do not want to change. However, remembering which index should be used for each value can lead to errors, especially if the tuple has a lot of fields and is constructed far from where it is used.\nAs an example, we created the coordinate location of Cairo, Egypt as:\ncairo_location = (30.03, 31.23)\nBut wait‚Ä¶ Are those coordinates stored (latitude, longitude) or (longitude, latitude)? You might think it is easy to sort this out for most cities, but for Cairo it‚Äôs really difficult!\nPython has an additional immutable collection data type called a namedtuple which assigns names, as well as the numerical index, to each member. The namedtuple is part of the standard python library but it is not immediately available. In order to use the namedtuple data type, you first need to import it to your working environment. We will be using the import command quite a bit in order to extend what python can do and take advantage of all the tools that people have developed for environmental data science. For now, we need to import namedtuple from the collections library within python. The code for that looks like this:\nfrom collections import namedtuple\nOnce we import the namedtuple, we can create a new kind of custom data type that we can use to store our locations:\nLocation = namedtuple('Location', ['latitude', 'longitude'])\nIn the code above, the first argument to the namedtuple function is the name of the new tuple object type you want to create. We called this new object type a Location. The second argument is a list of the field names that the Location objects will have. In general, Location objects on Earth are defined by two pieces of information: the latitude and the longitude.\nNow that we‚Äôve defined this new Location object type, we can create a new Location object using this code:\ncairo_location = Location(latitude=30.03, longitude=31.23)\nNote that this code isn‚Äôt that different than the code we used to make a tuple:\ncairo_location = tuple(30.03, 31.23)\nThe difference is that we are using our custom namedtuple type called Location, and we are able to specify exactly which values correspond to the latitude and longitude fields. We can retrieve any field in our Location tuple by specifying the field:\ncairo_location.latitude\n>>> 30.03\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\nfrom collections import namedtuple\n\nLocation = namedtuple('Location', ['latitude', 'longitude'])\ncairo_location = Location(latitude=30.03, longitude=31.23)\ncairo_location.latitude, cairo_location.longitude\n\n\n(30.03, 31.23)"
  },
  {
    "objectID": "answerkeys/Exercise1-4_Key.html#sets",
    "href": "answerkeys/Exercise1-4_Key.html#sets",
    "title": "",
    "section": "Sets",
    "text": "Sets\nSets are another collection data type. As opposed to a list or tuple, a set is not a sequence. Although a set is iterable (like the sequences you‚Äôve already met), a set is an unordered collection data type, which means it is not a sequence. However, a set is mutable, which means - like a list - it can be modified after being created. Finally - and most uniquely - a set has no duplicate elements. In this sense, a set in python is very much like a mathematical set.\nWe‚Äôve seen that a list is implemented using [], while a tuple is implemented using (). A set is implemented using {}:\nnum_set = {1, 3, 6, 10, 15, 21, 28}\nstr_set = {'hydrology', 'ecology', 'geology', 'climatology'}\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\n# Define set variables\nnum_set = {1, 3, 6, 10, 15, 21, 28}\nstr_set = {'hydrology', 'ecology', 'geology', 'climatology'}\n\n\nAs with all other collections, you can also create a set using the set() function:\nnum_set = set((1, 3, 6, 10, 15, 21, 28))\n\n‚úèÔ∏è <b> Try it. </b> \nUse the <code>set()</code> function to create a set containing the first four prime numbers.\n\n\n\nCode\n# prime_set = \nprime_set = set((2,3,5,7))\nprint(prime_set)\n\n\n{2, 3, 5, 7}\n\n\n\nMutability\nSets are mutable.\nTo remove an element from a set, use the discard() method:\n\nstr_set.discard('ecology')\n    \nTo add an element from to set, use the add() method:\n\nstr_set.add('oceanography')\n    \nTo add multiple elements to a set at the same time, use the update() method. The items to add should be contained in a list.\n\nstr_set.update(['oceanography', 'microbiology'])\n    \n\nüìö  <b> Practice 2. </b> \nAdd <code>'biogeochemistry'</code> and <code>'meteorology'</code> to <code>str_set</code> and then remove <code>'ecology'</code>.\n\n\n\nCode\n# Add biogeochemistry and meteorology \nstr_set.update(['biogeochemistry','meteorology'])\n# Remove ecology\nstr_set.discard('ecology')\n\n\nMany of the same functions that worked on list and tuple also work for a set.\nlen(str_set)\n>>> 4\nThe min() and max() commands can also be used to find the minimum and maximum values in a tuple. For a tuple of strings, this corresponds to the alphabetically first and last elements.\nmin(str_set)\n>>> 'climatology'\n\nmax(str_tuple)\n>>> 'oceanography'\n\n‚úèÔ∏è <b> Try it. </b> \nUse the <code>len()</code>, <code>min()</code>, and <code>max()</code> commands to find the length, minimum, and maximum of <code>num_set</code>.\n\n\n\nCode\n# Find the length of num_set\nprint(len(num_set))\n# Minimum value of num_set\nprint(min(num_set))\n# Maximum value of num_set\nprint(max(num_set))\n\n\n7\n1\n28\n\n\n\n\nMixed Data Types in Collections and Sequences\nAs a reminder, it‚Äôs usually a good idea to make sure your sets are all of the same basic data type. The reason is because Python doesn‚Äôt know how to compare the magnitude of different data types.\nWhich is larger: ecology, or the number 3? Python doesn‚Äôt know the answer, and neither do I. If you try to use functions like max or min on a mixed data type set you will get a TypeError exception.\n\nmixed_set = {3, 4, 'ecology', 'biology'}\nmax(mixed_set)\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n<ipython-input-49-a4da84ba3cd4> in <module>\n      1 mixed_set = {3, 4, 'ecology', 'biology'}\n----> 2 max(mixed_set)\n\nTypeError: '>' not supported between instances of 'int' and 'str'\n\n\nSet Methods\nGiven their similarity to mathematical sets, there are some specific functions that allow us to compare and combine the contents of different sets.\n\nUnion\nA union of sets contains all the items that are in any of the sets.\nThe union of sets A and B is defined as $ A B $.\n\n\n\nimage\n\n\nodds = {1, 3, 5, 7, 9, 11, 13, 15}\nevens = {2, 4, 6, 8, 10, 12, 14, 16}\n\nintegers = odds.union(evens)\nprint(integers)\n\n>>> {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16}\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\nknows_python = {'Bart', 'Maggie', 'Homer', 'Lisa', 'Professor Frink', 'Nelson'}\nknows_R = {'Homer', 'Nelson', 'Lisa', 'Marge', 'Ralph', 'Milhouse', 'Ms. Krabappel'}\n\n\n\n\nIntersection\nAn intersection of sets contains all the items that are found in all of the sets.\nThe intersection of sets A and B is defined as $ A B $.\n\n\n\nimage\n\n\n\nsquares = {4, 9, 16, 25, 36, 49}\nmultiples_of_nine = {9, 18, 27, 36, 45}\n\nsquares_divisible_by_nine = squares.intersection(multiples_of_nine)\nprint(squares_divisible_by_nine)\n\n>>> {9, 36}\n\n‚úèÔ∏è <b> Try it. </b> \nUse the <code>intersection()</code> method to determine who knows both `python` and `R`.\n\n\n\nCode\n# knows_both\nknows_both = knows_python.intersection(knows_R)\n# or knows_both = knows_R.intersection(knows_python)\nprint(knows_both)\n\n\n{'Nelson', 'Homer', 'Lisa'}\n\n\n\n\nDifference\nAn difference of two sets contains all the items that are in A but not in B.\nThe difference (or relative complement) of set A and B is defined as $ A B $.\n\n\n\nimage\n\n\n\nsquares = {4, 9, 16, 25, 36, 49}\nmultiples_of_nine = {9, 18, 27, 36, 45}\n\nsquares_not_divisible_by_nine = squares.difference(multiples_of_nine)\nprint(squares_not_divisible_by_nine)\n\n>>> {16, 49, 4, 25}\n\nüêç <b>Note.</b> Because a <b>set</b> is an <i>unordered</i> collection, the result of a set function will return elements in an unpredictable order. In the example above, the intersection returned `{16, 49, 4, 25}` rather than `{4, 16, 25, 49}`, which you may have expected.\n\n\n‚úèÔ∏è <b> Try it. </b> \nUse the <code>difference()</code> method to determine who knows <b>R</b>, but does not know <b>Python</b>.\n\n\n\nCode\n# knows_R_not_python\nknows_R_not_python = knows_R.difference(knows_python)\nprint(knows_R_not_python)\n\n\n{'Ralph', 'Milhouse', 'Ms. Krabappel', 'Marge'}\n\n\n\n\nSymmetric Difference\nThis method returns all the items that are unique to each set.\nThe symmetric difference (or disjunctive union) of sets A and B is A \\triangle B (also sometimes written as A \\oplus B)\n\n\n\nimage\n\n\n\nsquares = {4, 9, 16, 25, 36, 49}\nmultiples_of_nine = {9, 18, 27, 36, 45}\n\nsquares_not_divisible_by_nine = squares.symmetric_difference(multiples_of_nine)\nprint(squares_not_divisible_by_nine)\n\n>>> {16, 49, 18, 4, 25, 27, 45}\n\n‚úèÔ∏è <b> Try it. </b> \nUse the <code>symmetric_difference()</code> method to determine who only knows <i>either</i> R or Python.\n\n\n\nCode\n# either\neither = knows_R.symmetric_difference(knows_python)\n# or either = knows_python.symmetric_difference(knows_R)\nprint(either)\n\n\n{'Maggie', 'Ms. Krabappel', 'Ralph', 'Marge', 'Milhouse', 'Professor Frink', 'Bart'}\n\n\n\n\n\nAdditional Set Methods: isdisjoint(), issubset(), issuperset()\nThere are three additional set functions that allow you to determine the relationships between two sets. Each of these functions returns either True or False, which means they are Boolean operators.\nisdisjoint() determines if two sets are disjoint. It returns True if the contents of two sets are completely distinct, and False if they have any overlap\nodds.isdisjoint(evens)\n>>> True\n\nüêç <b>Note.</b> Set <i>A</i> is <b>disjoint</b> from set <i>B</i> if, and only if, the <b>intersection</b> of <i>A</i> and <i>B</i> is <code>None</code>.\n\nissubset() returns True if the content of set A is a subset of set B, and False if it is not a subset.\n\nprimes = {1, 3, 5, 7, 11}\nprimes.issubset(odds)\n>>> True\n\nüêç <b>Note.</b> Set <i>A</i> is a <b>subset</b> of set <i>B</i> if, and only if, the <b>intersection</b> of <i>A</i> and <i>B</i> is <i>A</i>.\n\nissupserset() returns True if the content of set A is a superset of set B, and False if it is not a superset.\n\nodds.issuperset(primes)\n>>> True\n\nüêç <b>Note.</b> Set <i>A</i> is a <b>superset</b> of set <i>B</i> if, and only if, set <i>B</i> is a subset of <i>A</i>."
  },
  {
    "objectID": "answerkeys/Exercise1-4_Key.html#dictionaries",
    "href": "answerkeys/Exercise1-4_Key.html#dictionaries",
    "title": "",
    "section": "Dictionaries",
    "text": "Dictionaries\nThe last collection we will look at today is the dictionary, or dict. This is one of the most powerful data structures in python. It is a mutable, unordered collection, which means that it can be altered, but elements within the structure cannot be referenced by their position and they cannot be sorted. Instead, the dictionary stores elements using keys, which are labels associated with each value in the dictionary. Using the analogy of an actual dictionary, the words of a dictionary would form the keys, while the definitions would be the values. Similarly, using the same analogy, we need to always remember that in Python, dictionaries can‚Äôt be sorted!\nYou can create a dictionary using the {}, which looks like it is the same as set, but instead of simply providing values for each element, you must provide a key as well:\nenvironmental_disciplines = {\n    'ecology':'The relationships between organisms and their environments.',\n    'hydrology':'The properties, distribution & effects of water on the surface, subsurface, & atmosphere.',\n    'geology':'The origin, history, and structure of the earth.',\n    'meteorology':'The phenomena of the atmosphere, especially weather and weather conditions.'\n    }\n\nüêç <b>Note.</b> The use of whitespace and indentation is important in python. In the example above, the dictionary entries are indented relative to the brackets <code>{</code> and <code>}</code>. In addition, there is no space between the <code>'key'</code>, the <code>:</code>, and the <code>'value'</code> for each entry. Finally, notice that there is a <code>,</code> following each dictionary entry. This pattern is the same as all of the other <i>collection</i> data types we've seen so far, including <b>list</b>, <b>set</b>, and <b>tuple</b>.\n\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\nenvironmental_disciplines = {\n    'ecology':'The relationships between organisms and their environments.',\n    'hydrology':'The properties, distribution & effects of water on the surface, subsurface, & atmosphere.',\n    'geology':'The origin, history, and structure of the earth.',\n    'meteorology':'The phenomena of the atmosphere, especially weather and weather conditions.'\n}\n\n\nBecause dictionaries are mutable, it is easy to add additional entries. This is done using the following notation:\n    environmental_disciplines['geomorphology'] =  'The evolution and configuration of landforms.'\n\n‚úèÔ∏è <b> Try it. </b> \n<b>Biogeochemistry</b> is defined as <b>\"the chemical, physical, geological, and biological processes and reactions that govern the composition of the natural environment.\"</b> Add this discpline to the dictionary <code>environmental_disciplines</code>.\n\n\n\nCode\n# Add biogeochemistry to environmental_disciplines\nenvironmental_disciplines['biogeochemistry'] = \"The chemical, physical, geological, and biological processes and reactions that govern the composition of the natural environment.\"\n\n\n\nAccessing elements in Dictionaries\nAccess an element in a dictionary is easy if you know what you are looking for. For example, if I want to know the definition of ecology, I can simply retireve the value of this defition using the key as my index into the dictionary:\nenvironmental_disciplines['ecology']\n>>> 'The relationships between organisms and their environments.'\n\n\nAccessing dictionary keys and values\nEvery dictionary has builtin methods to retrieve its keys and values. These functions are called, appropriately, keys() and values()\n\ndisciplines = environmental_disciplines.keys()\nprint(disciplines)\n>>> dict_keys(['ecology', 'hydrology', 'geology', 'meteorology'])\n\ndefinitions = environmental_disciplines.values()\nprint(definitions)\n>>> dict_values(['The relationships between organisms and their environments.', \n                 'The properties, distribution & effects of water on the surface, subsurface, & \\\n                 atmosphere.', \n                 'The origin, history, and structure of the earth.', \n                 'The phenomena of the atmosphere, especially weather and weather conditions.', \n                 'The chemical, physical, geological, and biological processes and reactions that \\\n                 govern the composition of the natural environment.'])\n\nüêç <b>Note.</b> The <code>keys()</code> and <code>values()</code> functions return a <code>dict_key</code> object and <code>dict_values</code> object, respectively. Each of these objects contains a <b>list</b> of either the keys or values. You can force the result of the <code>keys()</code> or <code>values()</code> function into a <b>list</b> by wrapping either one in a <code>list()</code> command. For example: <code>key_list = list(environmental_disciplines.keys())</code> will return a <b>list</b> of the keys in <code>environmental_disciplines</code>\n\n\n‚úèÔ∏è <b> Try it. </b> \nMake a <b>list</b> of the definitions in the <code>environmental_disciplines</code> dictionary, and determine which definition comes first alphabetically.\n\n\n\nCode\n# List of environmental disciplines\ndefinitions = list(environmental_disciplines.values())\n# First alphabetical definition\nsorted(definitions)[0]\n\n\n'The chemical, physical, geological, and biological processes and reactions that govern the composition of the natural environment.'\n\n\n\n\nLooping through Dictionaries\nPython has an efficient way to loop through all the keys and values of a dictionary at the same time. The items() method returns a tuple containing a (key, value) for each element in a dictionary. In practice this means that we can loop through a dictionary in the following way:\n\nfor discipline, definition in environmental_disciplines.items():\n    print(discipline.capitalize(),'is the study of',definition.lower())\n    \n\"Ecology is the study of the relationships between organisms and their environments.\"\n\"Hydrology is the study of the properties, distribution & effects of water on the surface, subsurface, & atmosphere.\"\n\"Geology is the study of the origin, history, and structure of the earth.\"\n\"Meteorology is the study of the phenomena of the atmosphere, especially weather and weather conditions.\"\n\n‚úèÔ∏è <b> Try it. </b> \nLoop through the <code>environmental_disciplines</code> dictionary and print out each subject and its definition.\n\n\n\nCode\nfor discipline, definition in environmental_disciplines.items():\n    print(discipline.capitalize(),'is the study of',definition.lower())\n\n\nEcology is the study of the relationships between organisms and their environments.\nHydrology is the study of the properties, distribution & effects of water on the surface, subsurface, & atmosphere.\nGeology is the study of the origin, history, and structure of the earth.\nMeteorology is the study of the phenomena of the atmosphere, especially weather and weather conditions.\nBiogeochemistry is the study of the chemical, physical, geological, and biological processes and reactions that govern the composition of the natural environment.\n\n\n\n\nAccessing un-assigned elements in Dictionaries\nAttempting to retrieve an element of a dictionary that doesn‚Äôt exist is the same as requesting an index of a list that doesn‚Äôt exist - Python will raise an Exception. For example, if I attempt to retrieve the definition of a field that hasn‚Äôt been defined, then I get an error.\nenvironmental_disciplines['xenohydrology']\n\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\n<ipython-input-46-d4d91bf18209> in <module>\n----> 1 environmental_disciplines['xenohydrology']\n\nKeyError: 'xenohydrology'\nWhile it‚Äôs easy to determine what indicies are in a list using the len() command, it‚Äôs sometimes hard to know what elements are in a dict (but we‚Äôll learn how soon!). Regardless, to avoid getting an error when requesting an element from a dict, you can use the get() function. The get() function will return None if the element doesn‚Äôt exist:\nunknown_definition = environmental_disciplines.get('xenohydrology')\nprint(unknown_definition)\n>>> None\nThe get() function will also allow you to pass an additional argument. This additional argument specifies a ‚Äúdefault‚Äù value which will be returned for any undefined elements:\nenvironmental_disciplines.get('xenohydrology', 'Discipline not defined.')\n>>> 'Discipline not defined.'\nlist_of_disciplines = ['climatology', 'ecology', 'meteorology', 'geology', 'biogeochemistry']\n\nüìö  <b> Practice 3. </b> \nUsing the list of disciplines given above, write a <code>for</code> loop that either prints the definition of the discipline, or prints 'Discipline not defined.'\n\n\n\nCode\n# List of disciplines\nlist_of_disciplines = ['climatology', 'ecology', 'meteorology', 'geology', 'biogeochemistry']\n\n# Iterate through list of disciplines\nfor discipline in list_of_disciplines:\n    # Get definition\n    definition = environmental_disciplines.get(discipline, 'Discipline not defined.')\n    # Print\n    print(discipline.capitalize() + ':', definition.lower())\n\n\nClimatology: discipline not defined.\nEcology: the relationships between organisms and their environments.\nMeteorology: the phenomena of the atmosphere, especially weather and weather conditions.\nGeology: the origin, history, and structure of the earth.\nBiogeochemistry: the chemical, physical, geological, and biological processes and reactions that govern the composition of the natural environment.\n\n\nThere is a lot more to learn about dictionaries, including methods for deleting elements, merging dictionaries, and learning about additional collection types like OrderedDict that allow you to preserve the arrangement of dictionary elements (essentially making them sequences). We will keep coming back to them throughout the quarter. If you want to learn more, check out the great material in our reading: Dictionaries\n\n\n\n\nCode\nfrom IPython.core.display import HTML\ndef css_styling():\n    styles = open(\"./styles/exercises.css\", \"r\").read()\n    return HTML(styles)\ncss_styling()"
  },
  {
    "objectID": "answerkeys/Exercise1-2_Key.html#lists",
    "href": "answerkeys/Exercise1-2_Key.html#lists",
    "title": "",
    "section": "Lists",
    "text": "Lists\nA list is a Python object used to contain multiple values. Lists are ordered and changeable. They are defined as follows:\nnum_list = [4, 23, 654, 2, 0, -12, 4391]\nstr_list = ['energy', 'water', 'carbon']\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\n# Define list variables\nnum_list = [4, 23, 654, 2, 0, -12, 4391]\nstr_list = ['energy', 'water', 'carbon']\n\n\nWhile you can create lists containing mixed data types, this is not usually recommended.\nThe len() command returns the length of the list.\nlen(str_list)\n>>> 3\nThe min() and max() commands are used to find the minimum and maximum values in a list. For a list of strings, this corresponds to the alphabetically first and last elements.\nmin(str_list)\n>>> 'carbon'\n\nmax(str_list)\n>>> 'water'\n\n‚úèÔ∏è <b> Try it. </b> \nUse the <code>len()</code>, <code>min()</code>, and <code>max()</code> commands to find the length, minimum, and maximum of <code>num_list</code>.\n\n\n\nCode\n# Find the length of num_list\nprint(len(num_list))\n# Minimum value of num_list\nprint(min(num_list))\n# Maximum value of num_list\nprint(max(num_list))\n\n\n7\n-12\n4391\n\n\n\n\n\nIndexing\nThe index is used to reference a value in an iterable object by its position. To access an element in a list by its index, use square brackets [].\n\nüêç <b>Note.</b> Python is zero-indexed. This means that the first element in the list is 0, the second is 1, and so on. The last element in a list with $n$ elements is $n - $1.\n\nnum_list[2]\n>>> 654\nYou can also access an element based on its position from the end of the list.\nnum_list[-2]\n>>> -12\n\n‚úèÔ∏è <b> Try it. </b> \nFind the 2nd element in <code>str_list</code> in two different ways. Remember that Python is zero-indexed!\n\n\n\nCode\n# Option 1\nprint(str_list[1])\n# Option 2\nprint(str_list[-2])\n\n\nwater\nwater\n\n\nAccessing a range of values in a list is called slicing. A slice specifies a start and an endpoint, generating a new list based on the indices. The indices are separated by a :.\n\nüêç <b>Note.</b>  The endpoint index in the slice is <i>exclusive</i>. To slice to the end of the list, omit an endpoint.\n\nnum_list[2:6]\n>>> [654, 2, 0, -12]\n\nnum_list[0:4]   \n>>> [4, 23, 654, 2]\n\nnum_list[:4]    \n>>> [4, 23, 654, 2]\n\nnum_list[-6:-1] \n>>> [23, 654, 2, 0,-12]\nIt is also possible to specify a step size, i.e.¬†[start:stop:step]. A step size of 1 would select every element, 2 would select every other element, etc.\nnum_list[0:4:2]  \n>>> [4, 654]\n\nnum_list[::2]    \n>>>[4, 654, 0, 4391]\nA step of -1 returns the list in reverse.\nnum_list[::-1]\n>>> [4391, -12, 0, 2, 654, 23, 4]\n\nüìö  <b> Practice 1. </b> \nDefine a new list of <b>floats</b> with <b>8 elements</b> called <code>my_list</code>. \n\nFind the 5th element in your list.\nCreate a new list containing every other value in your original list.\nUsing slicing and two different methods of indexing, remove the first and last values in your list.\n\n\n\n\nCode\n# Define a new list called my_list.\nmy_list = [432.0,-401.943582,3.9,0.8712054,57849.097,1.2753,-98437.0,7.78]\n# Find the 5th element.\nprint(my_list[4])\n# New list with every other value.\nodds = my_list[::2]\n# Remove first and last values. \nmy_list[1:-1]\n\n\n57849.097\n\n\n[-401.943582, 3.9, 0.8712054, 57849.097, 1.2753, -98437.0]\n\n\nLike lists, strings can also be indexed using the same notation. This can be useful for many applications, such as selecting files in a certain folder for import based on their names or extension.\nword_str = 'antidisestablishmentarianism'\n\nword_str[14]\n>>> 's'\n\nword_str[::3]\n>>> 'aistlhnrnm'\n\nüìö  <b> Practice 2. </b> \nUse indexing to extract the second letter of the third element ('a') in <code>str_list</code>.\n\n\n\nCode\nstr_list[2][1]\n\n\n'a'\n\n\n\n\n\n\nList Operations\nElements can be added to a list using the command list.append().\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\ncolors = ['red', 'blue', 'green', 'black', 'white']\ncolors.append('pink')\nprint(colors)\n\n\n['red', 'blue', 'green', 'black', 'white', 'pink']\n\n\nYou can add an element to a list in a specific position using the command list.insert().\ncolors.insert(4, 'purple')\nprint(colors)\n>>> ['red', 'blue', 'green', 'black', 'purple', 'white', 'pink']\n\n‚úèÔ∏è <b> Try it. </b> \nAdd <code>'purple'</code> to the list <code>colors</code> between <code>'green'</code> and <code>'black'</code>.\n\n\n\nCode\ncolors.insert(3,'purple')\nprint(colors)\n\n\n['red', 'blue', 'green', 'purple', 'black', 'white', 'pink']\n\n\nThere are multiple ways to remove elements from a list. The commands list.pop() and del remove elements based on indices.\ncolors.pop()       # removes the last element\ncolors.pop(2)      # removes the third element\ndel colors[2]      # removes the third element\ndel colors[2:4]    # removes the third and fourth elements\nThe command list.remove() removes an element based on its value.\ncolors.remove('red')\nprint(colors)\n>>> ['blue', 'green', 'black', 'purple', 'white', 'pink']\n\n‚úèÔ∏è <b> Try it. </b> \nRemove <code>'pink'</code> and <code>'purple'</code> from <code>colors</code>, using <code>del</code> for one of the strings and <code>list.remove()</code> for the other.\n\n\n\nCode\n# Delete 'pink'\ndel colors[-1]\n# Remove 'purple'\ncolors.remove('purple')\n# Print\nprint(colors)\n\n\n['red', 'blue', 'green', 'black', 'white']\n\n\nYou can sort the elements in a list (numerically or alphabetically) in two ways. The first uses the command list.sort().\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\nrand_list = [5.1 , 3.42 , 3.333 , 100.4 , 0.5 , 26.0 , 7.44 , 5.8 , 39.0]\nrand_list.sort()\nprint(rand_list)\n\n\n[0.5, 3.333, 3.42, 5.1, 5.8, 7.44, 26.0, 39.0, 100.4]\n\n\nSetting reverse=True within this command sorts the list in reverse order:\nrand_list = [5.1 , 3.42 , 3.333 , 100.4 , 0.5 , 26.0 , 7.44 , 5.8 , 39.0]\nrand_list.sort(reverse=True)\nprint(rand_list)\n>>> [100.4, 39.0, 26.0, 7.44, 5.8, 5.1, 3.42, 3.333, 0.5]\nSo far, all of the list commands we‚Äôve used have been in-place operators. This means that they perform the operation to the variable in place without requiring a new variable to be assigned. By contrast, standard operators do not change the original list variable. A new variable must be set in order to retain the operation.\n\n‚úèÔ∏è <b> Try it. </b> \nVerify that <code>rand_list</code> was, in fact, sorted in place by using the <code>min()</code> and <code>max()</code> functions to determine the minmum and maximum values in the list and printing the first and last values in the list.\n\n\n\nCode\n# Print the min and max values in rand_list.\nprint(min(rand_list))\nprint(max(rand_list))\n# Print the first and last values in rand_list.\nprint(rand_list[0])\nprint(rand_list[-1])\n\n\n0.5\n100.4\n0.5\n100.4\n\n\nThe other method of sorting a list is to use the sorted() command, which does not change the original list. Instead, the sorted list must be assigned to a new variable.\nrand_list = [5.1 , 3.42 , 3.333 , 100.4 , 0.5 , 26.0 , 7.44 , 5.8 , 39.0]\nsorted_list = sorted(rand_list)\nprint(rand_list[0])\nprint(sorted_list[0])\n>>> 5.1\n    0.5\nTo avoid changing the original variable when using an in-place operator, it is wise to create a copy. There are multiple ways to create copies of lists, but it is important to know the difference between a true copy and a view. A view of a list can be created as follows:\nstr_list = ['energy', 'water', 'carbon']\nstr_list_view = str_list\nAny in-place operation performed on str_list_view will also be applied to str_list. To avoid this, create a copy of str_list using any of the following methods:\nstr_list_copy = str_list.copy()\n# or\nstr_list_copy = str_list[:]\n# or\nstr_list_copy = list(str_list)\n\nüìö  <b> Practice 3. </b> \nCreate a copy of <code>my_list</code>, which you assigned above. \n\nUsing indexing or list operators, remove the first and last elements of your copied list.\nSort both the original list and the copied list in reverse order.\nUse the len() function and a boolean operator to determine which list is longer.\n\n\n\n\nCode\n# Create a copy of mylist.\nmy_list_copy = my_list[1:-1]\n# Sort both lists from largest to smallest.\nmy_list.sort()\nmy_list_copy.sort()\n# Determine which list is longer.\nlen(my_list) > len(my_list_copy)\n\n\nTrue\n\n\nIn addition to adding single elements to a list using list.append() or list.insert(), multiple elements can be added to a list at the same time by adding multiple lists together.\nrainbow  = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet']\nshades = ['coral', 'chartreuse', 'cyan', 'navy']\nprint( rainbow + shades )\n>>> ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet', 'coral', 'chartreuse', 'cyan', 'navy']\n\nüìö  <b> Practice 4. </b> \nAdd <code>rand_list</code> and <code>my_list</code> together in a new list called <code>float_list</code>. Print the result.\n\n\n\nCode\nfloat_list = rand_list + my_list\nprint(float_list)\n\n\n[0.5, 3.333, 3.42, 5.1, 5.8, 7.44, 26.0, 39.0, 100.4, -98437.0, -401.943582, 0.8712054, 1.2753, 3.9, 7.78, 432.0, 57849.097]\n\n\nSingle lists can be repeated by multiplying by an integer.\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\nstr_list2 = str_list * 2\nnum_list4 = num_list * 4\nprint( str_list2 )\nprint( num_list4 )\n\n\n['energy', 'water', 'carbon', 'energy', 'water', 'carbon']\n[4, 23, 654, 2, 0, -12, 4391, 4, 23, 654, 2, 0, -12, 4391, 4, 23, 654, 2, 0, -12, 4391, 4, 23, 654, 2, 0, -12, 4391]\n\n\n\n\nGenerating sequential lists\nSequential lists are valuable tools, particularly for iteration, which we will explore in the next exercise. The range() function is used to create an iterable object based on the size of an integer argument.\nrange(4)\n>>> range(0, 4)\nTo construct a sequential list from the range() object, use the list() function.\nlist(range(4))\n>>> [0, 1, 2, 3]\nUsing multiple integer arguments, the range() function can be used to generate sequential lists between two bounds: range(start, stop [, step]).\n\nüêç <b>Note.</b> \nLike indexing, all Python functions using <span style=\"font-style: italic\"> start </span> and <span style=\"font-style: italic\"> stop </span> arguments, the <span style=\"font-style: italic\"> stop </span> value is <span style=\"font-weight: bold\"> exclusive </span>.\n\nrange_10 = list(range(1,11))\nodds_10 = list(range(1,11,2))\nprint(range_10)\nprint(odds_10)\n>>> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    [1, 3, 5, 7, 9]\n\nüìö  <b> Practice 5. </b> \nUse the <code>range()</code> function to construct a list of all hundreds (e.g. 100, 200, etc.) between 0 and 1000, inclusive.\n\n\n\nCode\n# Construct a list of hundreds from 0 to 1000\nhundreds = list(range(0,1001,100))\n# Print your list\nprint(hundreds)\n\n\n[0, 100, 200, 300, 400, 500, 600, 700, 800, 900, 1000]\n\n\n\n\n\n\nCode\nfrom IPython.core.display import HTML\ndef css_styling():\n    styles = open(\"./styles/exercises.css\", \"r\").read()\n    return HTML(styles)\ncss_styling()"
  },
  {
    "objectID": "answerkeys/Exercise2-2_Key.html#introduction-to-pandas",
    "href": "answerkeys/Exercise2-2_Key.html#introduction-to-pandas",
    "title": "",
    "section": "Introduction to pandas",
    "text": "Introduction to pandas\n\nAs always, we must begin by importing the pandas library. The standard import statement for pandas is:\nimport pandas as pd\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\nimport pandas as pd\n\n\n\nSeries and DataFrame objects\n\n\nThe core components of pandas are the Series and the DataFrame objects. Both of these are essentially enhanced versions of the NumPy array, with a few key differences: 1) pandas DataFrames can be heterogeneous, meaning that the columns can contain different data types; and 2) the rows and columns of DataFrames can be identified with labels (usually strings) in addition to standard integer indexing.\nA Series is essentially a column of data, while a DataFrame is a multidimensional table made up of many Series, not unlike a spreadsheet:\n\nSeries and DataFrames are similar in many respects ‚Äì most common operations can be performed on both objects, though Series are more limited, as they can only ever contain a single column (i.e.¬†you cannot turn a Series into a DataFrame by adding a column).\nBoth Series and DataFrame objects contain an Index object similar to the row index of the ndarray or the index of a list. The pandas Index object can be conceptualized as an immutable array or an ordered multiset. Unless explicitly defined otherwise, the Index of a Series or DataFrame is initialized as the ordered set of positive integers beginning at 0 (see figure above).\n\nCreating Series and DataFrame objects from scratch\nA Series can be easily created from a list or array as follows:\n# Create a Series from a list\nseries = pd.Series([25.8, 16.2, 17.9, 18.8, 23.6, 29.9, 23.6, 22.1])\n\nseries\n\n\n\n\n\n0    25.8\n1    16.2\n2    17.9\n3    18.8\n4    23.6\n5    29.9\n6    23.6\n7    22.1\ndtype: float64\n\n\n\n\nThere are many ways to create a DataFrame, but the most common are to use a list of lists or a dictionary. First, let‚Äôs use a list of lists (or an array):\n# Create a df from a list of lists\ndf = pd.DataFrame([[25.8, 28.1, 16.2, 11.0],[17.9, 14.2, 18.8, 28.0],\n                   [23.6, 18.4, 29.9, 27.8],[23.6, 36.2, 22.1, 14.5]],\n                 columns=['A','B','C','D'])\n\ndf\n\n\n\n\n\n      A     B     C     D\n0  25.8  28.1  16.2  11.0\n1  17.9  14.2  18.8  28.0\n2  23.6  18.4  29.9  27.8\n3  23.6  36.2  22.1  14.5\n\n\n\n\nMuch like with NumPy arrays, each inner list element in the outer list corresponds to a row. Using the optional columns keyword argument, we can specify the name of each column. If this parameter is not passed, the columns would be displayed with integer index values (like the rows).\nNext, let‚Äôs create a DataFrame from a dict object:\n# Create a df from a dictionary\ndf = pd.DataFrame({'A': [25.8, 28.1, 16.2, 11.0],\n                   'B': [17.9, 14.2, 18.8, 28.0],\n                   'C': [23.6, 18.4, 29.9, 27.8],\n                   'D': [23.6, 36.2, 22.1, 14.5]})\n\ndf\n\n\n\n\n\n      A     B     C     D\n0  25.8  28.1  16.2  11.0\n1  17.9  14.2  18.8  28.0\n2  23.6  18.4  29.9  27.8\n3  23.6  36.2  22.1  14.5\n\n\n\n\nUsing this method, each key corresponds to a column name, and each value is a column.\n\nüìö  <b> Practice 1. </b> \n\n\nUse a list of lists to construct a DataFrame named df1 containing the data in the table below.\n\n\n\n\n\nRiver\n\n\nLength (\\text{km})\n\n\nDrainage area (\\text{km}^2)\n\n\n\n\nAmazon\n\n\n6400\n\n\n7,050,000\n\n\n\n\nCongo\n\n\n4371\n\n\n4,014,500\n\n\n\n\nYangtze\n\n\n6418\n\n\n1,808,500\n\n\n\n\nMississippi\n\n\n3730\n\n\n3,202,230\n\n\n\n\n\n\nUse a dict to construct a DataFrame named df2 containing the data in the table below.\n\n\n\n\n\nRiver\n\n\nLength (\\text{km})\n\n\nDrainage area (\\text{km}^2)\n\n\n\n\nZambezi\n\n\n2574\n\n\n1,331,000\n\n\n\n\nMekong\n\n\n4023\n\n\n811,000\n\n\n\n\nMurray\n\n\n2508\n\n\n1,061,469\n\n\n\n\nRh√¥ne\n\n\n813\n\n\n98,000\n\n\n\n\nCubango\n\n\n1056\n\n\n530,000\n\n\n\n\n\n\n\n\n\nCode\n# 1a. Construct df1 from list of lists\ndf1 = pd.DataFrame([['Amazon', 6400, 7050000], \n                    ['Congo', 4371, 4014500],\n                    ['Yangtze', 6418, 1808500],\n                    ['Mississippi', 3730, 3202230]],\n                   columns=['RIVER', 'LENGTH_km', 'DRAINAGE_AREA_km2'])\n\n# 1b. Construct df2 from dict\ndf2 = pd.DataFrame({'RIVER': ['Zambezi', 'Mekong', 'Murray', 'Rhone', 'Cubango'],\n                    'LENGTH_km': [2574, 4023, 2508, 813, 1056],\n                    'DRAINAGE_AREA_km2': [1331000, 811000, 1061469, 98000, 530000]})\n\n\n\n\n\nImporting data\n\n\nWhile you will likely create many DataFrames from scratch throughout your code, in most cases, you‚Äôll have some data you‚Äôd like to import as a starting point. Pandas has several functions to read in data from a variety of formats. For now, we‚Äôll focus on reading in data from plain-text flat files.\nMost environmental datasets are stored as flat files, meaning that the data are unstructured ‚Äì¬†the records follow a uniform format, but they are not indexed and no information about relationships between records is included. Plain-text flat files use delimiters such as commas, tabs, or spaces to separate values. Pandas has a few different functions to import flat files, but perhaps the most useful is the pd.read_csv() function, designed to read CSV files. As its name suggests, a CSV (Comma Separated Values) file is a plain-text file that uses commas to delimit (separate) values. Each line of the file is a record (row).\nLet‚Äôs start by taking a look at the pd.read_csv() function.\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\nhelp(pd.read_csv)\n\n\nHelp on function read_csv in module pandas.io.parsers:\n\nread_csv(filepath_or_buffer: Union[str, pathlib.Path, IO[~AnyStr]], sep=',', delimiter=None, header='infer', names=None, index_col=None, usecols=None, squeeze=False, prefix=None, mangle_dupe_cols=True, dtype=None, engine=None, converters=None, true_values=None, false_values=None, skipinitialspace=False, skiprows=None, skipfooter=0, nrows=None, na_values=None, keep_default_na=True, na_filter=True, verbose=False, skip_blank_lines=True, parse_dates=False, infer_datetime_format=False, keep_date_col=False, date_parser=None, dayfirst=False, cache_dates=True, iterator=False, chunksize=None, compression='infer', thousands=None, decimal: str = '.', lineterminator=None, quotechar='\"', quoting=0, doublequote=True, escapechar=None, comment=None, encoding=None, dialect=None, error_bad_lines=True, warn_bad_lines=True, delim_whitespace=False, low_memory=True, memory_map=False, float_precision=None)\n    Read a comma-separated values (csv) file into DataFrame.\n    \n    Also supports optionally iterating or breaking of the file\n    into chunks.\n    \n    Additional help can be found in the online docs for\n    `IO Tools <https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html>`_.\n    \n    Parameters\n    ----------\n    filepath_or_buffer : str, path object or file-like object\n        Any valid string path is acceptable. The string could be a URL. Valid\n        URL schemes include http, ftp, s3, and file. For file URLs, a host is\n        expected. A local file could be: file://localhost/path/to/table.csv.\n    \n        If you want to pass in a path object, pandas accepts any ``os.PathLike``.\n    \n        By file-like object, we refer to objects with a ``read()`` method, such as\n        a file handler (e.g. via builtin ``open`` function) or ``StringIO``.\n    sep : str, default ','\n        Delimiter to use. If sep is None, the C engine cannot automatically detect\n        the separator, but the Python parsing engine can, meaning the latter will\n        be used and automatically detect the separator by Python's builtin sniffer\n        tool, ``csv.Sniffer``. In addition, separators longer than 1 character and\n        different from ``'\\s+'`` will be interpreted as regular expressions and\n        will also force the use of the Python parsing engine. Note that regex\n        delimiters are prone to ignoring quoted data. Regex example: ``'\\r\\t'``.\n    delimiter : str, default ``None``\n        Alias for sep.\n    header : int, list of int, default 'infer'\n        Row number(s) to use as the column names, and the start of the\n        data.  Default behavior is to infer the column names: if no names\n        are passed the behavior is identical to ``header=0`` and column\n        names are inferred from the first line of the file, if column\n        names are passed explicitly then the behavior is identical to\n        ``header=None``. Explicitly pass ``header=0`` to be able to\n        replace existing names. The header can be a list of integers that\n        specify row locations for a multi-index on the columns\n        e.g. [0,1,3]. Intervening rows that are not specified will be\n        skipped (e.g. 2 in this example is skipped). Note that this\n        parameter ignores commented lines and empty lines if\n        ``skip_blank_lines=True``, so ``header=0`` denotes the first line of\n        data rather than the first line of the file.\n    names : array-like, optional\n        List of column names to use. If the file contains a header row,\n        then you should explicitly pass ``header=0`` to override the column names.\n        Duplicates in this list are not allowed.\n    index_col : int, str, sequence of int / str, or False, default ``None``\n      Column(s) to use as the row labels of the ``DataFrame``, either given as\n      string name or column index. If a sequence of int / str is given, a\n      MultiIndex is used.\n    \n      Note: ``index_col=False`` can be used to force pandas to *not* use the first\n      column as the index, e.g. when you have a malformed file with delimiters at\n      the end of each line.\n    usecols : list-like or callable, optional\n        Return a subset of the columns. If list-like, all elements must either\n        be positional (i.e. integer indices into the document columns) or strings\n        that correspond to column names provided either by the user in `names` or\n        inferred from the document header row(s). For example, a valid list-like\n        `usecols` parameter would be ``[0, 1, 2]`` or ``['foo', 'bar', 'baz']``.\n        Element order is ignored, so ``usecols=[0, 1]`` is the same as ``[1, 0]``.\n        To instantiate a DataFrame from ``data`` with element order preserved use\n        ``pd.read_csv(data, usecols=['foo', 'bar'])[['foo', 'bar']]`` for columns\n        in ``['foo', 'bar']`` order or\n        ``pd.read_csv(data, usecols=['foo', 'bar'])[['bar', 'foo']]``\n        for ``['bar', 'foo']`` order.\n    \n        If callable, the callable function will be evaluated against the column\n        names, returning names where the callable function evaluates to True. An\n        example of a valid callable argument would be ``lambda x: x.upper() in\n        ['AAA', 'BBB', 'DDD']``. Using this parameter results in much faster\n        parsing time and lower memory usage.\n    squeeze : bool, default False\n        If the parsed data only contains one column then return a Series.\n    prefix : str, optional\n        Prefix to add to column numbers when no header, e.g. 'X' for X0, X1, ...\n    mangle_dupe_cols : bool, default True\n        Duplicate columns will be specified as 'X', 'X.1', ...'X.N', rather than\n        'X'...'X'. Passing in False will cause data to be overwritten if there\n        are duplicate names in the columns.\n    dtype : Type name or dict of column -> type, optional\n        Data type for data or columns. E.g. {'a': np.float64, 'b': np.int32,\n        'c': 'Int64'}\n        Use `str` or `object` together with suitable `na_values` settings\n        to preserve and not interpret dtype.\n        If converters are specified, they will be applied INSTEAD\n        of dtype conversion.\n    engine : {'c', 'python'}, optional\n        Parser engine to use. The C engine is faster while the python engine is\n        currently more feature-complete.\n    converters : dict, optional\n        Dict of functions for converting values in certain columns. Keys can either\n        be integers or column labels.\n    true_values : list, optional\n        Values to consider as True.\n    false_values : list, optional\n        Values to consider as False.\n    skipinitialspace : bool, default False\n        Skip spaces after delimiter.\n    skiprows : list-like, int or callable, optional\n        Line numbers to skip (0-indexed) or number of lines to skip (int)\n        at the start of the file.\n    \n        If callable, the callable function will be evaluated against the row\n        indices, returning True if the row should be skipped and False otherwise.\n        An example of a valid callable argument would be ``lambda x: x in [0, 2]``.\n    skipfooter : int, default 0\n        Number of lines at bottom of file to skip (Unsupported with engine='c').\n    nrows : int, optional\n        Number of rows of file to read. Useful for reading pieces of large files.\n    na_values : scalar, str, list-like, or dict, optional\n        Additional strings to recognize as NA/NaN. If dict passed, specific\n        per-column NA values.  By default the following values are interpreted as\n        NaN: '', '#N/A', '#N/A N/A', '#NA', '-1.#IND', '-1.#QNAN', '-NaN', '-nan',\n        '1.#IND', '1.#QNAN', '<NA>', 'N/A', 'NA', 'NULL', 'NaN', 'n/a',\n        'nan', 'null'.\n    keep_default_na : bool, default True\n        Whether or not to include the default NaN values when parsing the data.\n        Depending on whether `na_values` is passed in, the behavior is as follows:\n    \n        * If `keep_default_na` is True, and `na_values` are specified, `na_values`\n          is appended to the default NaN values used for parsing.\n        * If `keep_default_na` is True, and `na_values` are not specified, only\n          the default NaN values are used for parsing.\n        * If `keep_default_na` is False, and `na_values` are specified, only\n          the NaN values specified `na_values` are used for parsing.\n        * If `keep_default_na` is False, and `na_values` are not specified, no\n          strings will be parsed as NaN.\n    \n        Note that if `na_filter` is passed in as False, the `keep_default_na` and\n        `na_values` parameters will be ignored.\n    na_filter : bool, default True\n        Detect missing value markers (empty strings and the value of na_values). In\n        data without any NAs, passing na_filter=False can improve the performance\n        of reading a large file.\n    verbose : bool, default False\n        Indicate number of NA values placed in non-numeric columns.\n    skip_blank_lines : bool, default True\n        If True, skip over blank lines rather than interpreting as NaN values.\n    parse_dates : bool or list of int or names or list of lists or dict, default False\n        The behavior is as follows:\n    \n        * boolean. If True -> try parsing the index.\n        * list of int or names. e.g. If [1, 2, 3] -> try parsing columns 1, 2, 3\n          each as a separate date column.\n        * list of lists. e.g.  If [[1, 3]] -> combine columns 1 and 3 and parse as\n          a single date column.\n        * dict, e.g. {'foo' : [1, 3]} -> parse columns 1, 3 as date and call\n          result 'foo'\n    \n        If a column or index cannot be represented as an array of datetimes,\n        say because of an unparseable value or a mixture of timezones, the column\n        or index will be returned unaltered as an object data type. For\n        non-standard datetime parsing, use ``pd.to_datetime`` after\n        ``pd.read_csv``. To parse an index or column with a mixture of timezones,\n        specify ``date_parser`` to be a partially-applied\n        :func:`pandas.to_datetime` with ``utc=True``. See\n        :ref:`io.csv.mixed_timezones` for more.\n    \n        Note: A fast-path exists for iso8601-formatted dates.\n    infer_datetime_format : bool, default False\n        If True and `parse_dates` is enabled, pandas will attempt to infer the\n        format of the datetime strings in the columns, and if it can be inferred,\n        switch to a faster method of parsing them. In some cases this can increase\n        the parsing speed by 5-10x.\n    keep_date_col : bool, default False\n        If True and `parse_dates` specifies combining multiple columns then\n        keep the original columns.\n    date_parser : function, optional\n        Function to use for converting a sequence of string columns to an array of\n        datetime instances. The default uses ``dateutil.parser.parser`` to do the\n        conversion. Pandas will try to call `date_parser` in three different ways,\n        advancing to the next if an exception occurs: 1) Pass one or more arrays\n        (as defined by `parse_dates`) as arguments; 2) concatenate (row-wise) the\n        string values from the columns defined by `parse_dates` into a single array\n        and pass that; and 3) call `date_parser` once for each row using one or\n        more strings (corresponding to the columns defined by `parse_dates`) as\n        arguments.\n    dayfirst : bool, default False\n        DD/MM format dates, international and European format.\n    cache_dates : bool, default True\n        If True, use a cache of unique, converted dates to apply the datetime\n        conversion. May produce significant speed-up when parsing duplicate\n        date strings, especially ones with timezone offsets.\n    \n        .. versionadded:: 0.25.0\n    iterator : bool, default False\n        Return TextFileReader object for iteration or getting chunks with\n        ``get_chunk()``.\n    chunksize : int, optional\n        Return TextFileReader object for iteration.\n        See the `IO Tools docs\n        <https://pandas.pydata.org/pandas-docs/stable/io.html#io-chunking>`_\n        for more information on ``iterator`` and ``chunksize``.\n    compression : {'infer', 'gzip', 'bz2', 'zip', 'xz', None}, default 'infer'\n        For on-the-fly decompression of on-disk data. If 'infer' and\n        `filepath_or_buffer` is path-like, then detect compression from the\n        following extensions: '.gz', '.bz2', '.zip', or '.xz' (otherwise no\n        decompression). If using 'zip', the ZIP file must contain only one data\n        file to be read in. Set to None for no decompression.\n    thousands : str, optional\n        Thousands separator.\n    decimal : str, default '.'\n        Character to recognize as decimal point (e.g. use ',' for European data).\n    lineterminator : str (length 1), optional\n        Character to break file into lines. Only valid with C parser.\n    quotechar : str (length 1), optional\n        The character used to denote the start and end of a quoted item. Quoted\n        items can include the delimiter and it will be ignored.\n    quoting : int or csv.QUOTE_* instance, default 0\n        Control field quoting behavior per ``csv.QUOTE_*`` constants. Use one of\n        QUOTE_MINIMAL (0), QUOTE_ALL (1), QUOTE_NONNUMERIC (2) or QUOTE_NONE (3).\n    doublequote : bool, default ``True``\n       When quotechar is specified and quoting is not ``QUOTE_NONE``, indicate\n       whether or not to interpret two consecutive quotechar elements INSIDE a\n       field as a single ``quotechar`` element.\n    escapechar : str (length 1), optional\n        One-character string used to escape other characters.\n    comment : str, optional\n        Indicates remainder of line should not be parsed. If found at the beginning\n        of a line, the line will be ignored altogether. This parameter must be a\n        single character. Like empty lines (as long as ``skip_blank_lines=True``),\n        fully commented lines are ignored by the parameter `header` but not by\n        `skiprows`. For example, if ``comment='#'``, parsing\n        ``#empty\\na,b,c\\n1,2,3`` with ``header=0`` will result in 'a,b,c' being\n        treated as the header.\n    encoding : str, optional\n        Encoding to use for UTF when reading/writing (ex. 'utf-8'). `List of Python\n        standard encodings\n        <https://docs.python.org/3/library/codecs.html#standard-encodings>`_ .\n    dialect : str or csv.Dialect, optional\n        If provided, this parameter will override values (default or not) for the\n        following parameters: `delimiter`, `doublequote`, `escapechar`,\n        `skipinitialspace`, `quotechar`, and `quoting`. If it is necessary to\n        override values, a ParserWarning will be issued. See csv.Dialect\n        documentation for more details.\n    error_bad_lines : bool, default True\n        Lines with too many fields (e.g. a csv line with too many commas) will by\n        default cause an exception to be raised, and no DataFrame will be returned.\n        If False, then these \"bad lines\" will dropped from the DataFrame that is\n        returned.\n    warn_bad_lines : bool, default True\n        If error_bad_lines is False, and warn_bad_lines is True, a warning for each\n        \"bad line\" will be output.\n    delim_whitespace : bool, default False\n        Specifies whether or not whitespace (e.g. ``' '`` or ``'    '``) will be\n        used as the sep. Equivalent to setting ``sep='\\s+'``. If this option\n        is set to True, nothing should be passed in for the ``delimiter``\n        parameter.\n    low_memory : bool, default True\n        Internally process the file in chunks, resulting in lower memory use\n        while parsing, but possibly mixed type inference.  To ensure no mixed\n        types either set False, or specify the type with the `dtype` parameter.\n        Note that the entire file is read into a single DataFrame regardless,\n        use the `chunksize` or `iterator` parameter to return the data in chunks.\n        (Only valid with C parser).\n    memory_map : bool, default False\n        If a filepath is provided for `filepath_or_buffer`, map the file object\n        directly onto memory and access the data directly from there. Using this\n        option can improve performance because there is no longer any I/O overhead.\n    float_precision : str, optional\n        Specifies which converter the C engine should use for floating-point\n        values. The options are `None` for the ordinary converter,\n        `high` for the high-precision converter, and `round_trip` for the\n        round-trip converter.\n    \n    Returns\n    -------\n    DataFrame or TextParser\n        A comma-separated values (csv) file is returned as two-dimensional\n        data structure with labeled axes.\n    \n    See Also\n    --------\n    to_csv : Write DataFrame to a comma-separated values (csv) file.\n    read_csv : Read a comma-separated values (csv) file into DataFrame.\n    read_fwf : Read a table of fixed-width formatted lines into DataFrame.\n    \n    Examples\n    --------\n    >>> pd.read_csv('data.csv')  # doctest: +SKIP\n\n\n\nAs you can see, pd.read_csv() has quite a few parameters. Don‚Äôt be overwhelmed ‚Äì¬†most of these are optional arguments that allow you to specify exactly how your data file is structured and which part(s) you want to import. In particular, the sep parameter allows the user to specify the type of delimiter used in the file. The default is a comma, but you can actually pass other common delimiters (such as sep='\\t', which is a tab) to import other delimited files. The only required argument is a string specifying the filepath of your file.\nIn this exercise, we‚Äôll be importing a CSV file containing radiation data for October 2019 from a Baseline Surface Radiation Network (BSRN) station in Southern Africa. BSRN is a Global Energy and Water Cycle Experiment project aimed at monitoring changes in the Earth‚Äôs surface radiation field. The network is comprised of 64 stations across various climate zones across the globe, whose data are used as the global baseline for surface radiation by the Global Climate Observing System.\nThe CSV file is located in the data folder on the course GitHub repository. If you haven‚Äôt already, copy the data folder from the envdatasci folder to your private repo. You can do this by opening up a Terminal in JupyterLab (File > New Launcher, then choose Terminal) and typing the following command:\n\ncp -R envdatasci/data g136-student/data\n\nwhere g136-student is replaced by the name of your repo (g136- + your last name). While the file may not display properly on the server, the first 10 lines of the file should look like:\nDATE,H_m,SWD_Wm2,STD_SWD,DIR_Wm2,STD_DIR,DIF_Wm2,STD_DIF,LWD_Wm2,STD_LWD,SWU_Wm2,LWU_Wm2,T_degC,RH,P_hPa\n2019-10-01 00:00:00,2,-3,0,0,0,-3,0,300,0.1,0,383,16.2,30.7,966\n2019-10-01 00:01:00,2,-3,0,0,0,-3,0,300,0.3,0,383,16.4,30.7,966\n2019-10-01 00:02:00,2,-3,0,0,0,-3,0,300,0.2,0,383,16.5,30.5,966\n2019-10-01 00:03:00,2,-3,0,0,0,-3,0,300,0.1,0,383,16.5,30.4,966\n2019-10-01 00:04:00,2,-3,0,0,0,-3,0,300,0.1,0,383,16.8,30.5,966\n2019-10-01 00:05:00,2,-2,0,0,0,-2,0,300,0.2,0,383,16.9,30.5,966\n2019-10-01 00:06:00,2,-2,0,0,0,-2,0,300,0.2,0,383,16.8,30.4,966\n2019-10-01 00:07:00,2,-2,0,0,0,-2,0,300,0.1,0,384,17,31,966\n2019-10-01 00:08:00,2,-2,0,0,0,-2,0,300,0.2,0,384,16.7,30.6,966\nThe first line of the file contains the names of the columns, which are described in the table below.\n\n\n\n\n\n\n\nColumn name\nDescription\n\n\n\n\nDATE\nDate/Time\n\n\nH_m\nHeight of measurement (\\text{m})\n\n\nSWD_Wm2\nIncoming shortwave radiation (\\text{W m}^{-2})\n\n\nSTD_SWD\nStandard deviation of incoming shortwave radiation (\\text{W m}^{-2})\n\n\nDIR_Wm2\nDirect radiation (\\text{W m}^{-2})\n\n\nSTD_DIR\nStandard deviation of direct radiation (\\text{W m}^{-2})\n\n\nDIF_Wm2\nDiffuse radiation (\\text{W m}^{-2})\n\n\nSTD_DIF\nStandard deviation of diffuse radiation (\\text{W m}^{-2})\n\n\nLWD_Wm2\nIncoming longwave radiation (\\text{W m}^{-2})\n\n\nSTD_LWD\nStandard deviation of incoming longwave radiation (\\text{W m}^{-2})\n\n\nSWU_Wm2\nOutgoing shortwave radiation (\\text{W m}^{-2})\n\n\nLWU_Wm2\nOutgoing longwave radiation (\\text{W m}^{-2})\n\n\nT_degC\nAir temperature (^{\\circ}\\text{C})\n\n\nRH\nRelative humidity (\\%)\n\n\nP_hPa\nAir pressure (\\text{hPa})\n\n\n\nWe can import the data into pandas using the following syntax:\nbsrn = pd.read_csv('../data/BSRN_GOB_2019-10.csv')\n\n‚úèÔ∏è <b> Try it. </b> \nCopy and paste the code above to import the data in the CSV file into a pandas <code>DataFrame</code> named <code>bsrn</code>.\n\n\n\nCode\n# Import data\nbsrn = pd.read_csv('../../data/BSRN_GOB_2019-10.csv')\n\n\n\nA bit of housekeeping\n\nBefore we move on into viewing and operating on the DataFrame, it‚Äôs worth noting that data import is rarely ever this straightforward. Most raw data require considerable cleaning before they are ready for analysis. Often some of this must happen outside of Python to format the data for import, but ideally the majority of data preprocessing can be conducted in Python ‚Äì allowing you to perform the same operations on multiple datasets at once and making the process easily repeatable.\n\n\n\n\nExamining your DataFrame\n\n\nNow that we‚Äôve loaded in our data, it would be useful to take a look at it. Given the size of our bsrn DataFrame, however, we can‚Äôt simply print out the entire table. The df.head() method allows us to quickly view the first five rows.\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\nbsrn.head()\n\n\n\n\n\n\n  \n    \n      \n      DATE\n      H_m\n      SWD_Wm2\n      STD_SWD\n      DIR_Wm2\n      STD_DIR\n      DIF_Wm2\n      STD_DIF\n      LWD_Wm2\n      STD_LWD\n      SWU_Wm2\n      LWU_Wm2\n      T_degC\n      RH\n      P_hPa\n    \n  \n  \n    \n      0\n      2019-10-01 00:00:00\n      2\n      -3.0\n      0.0\n      0.0\n      0.0\n      -3.0\n      0.0\n      300.0\n      0.1\n      0\n      383\n      16.2\n      30.7\n      966\n    \n    \n      1\n      2019-10-01 00:01:00\n      2\n      -3.0\n      0.0\n      0.0\n      0.0\n      -3.0\n      0.0\n      300.0\n      0.3\n      0\n      383\n      16.4\n      30.7\n      966\n    \n    \n      2\n      2019-10-01 00:02:00\n      2\n      -3.0\n      0.0\n      0.0\n      0.0\n      -3.0\n      0.0\n      300.0\n      0.2\n      0\n      383\n      16.5\n      30.5\n      966\n    \n    \n      3\n      2019-10-01 00:03:00\n      2\n      -3.0\n      0.0\n      0.0\n      0.0\n      -3.0\n      0.0\n      300.0\n      0.1\n      0\n      383\n      16.5\n      30.4\n      966\n    \n    \n      4\n      2019-10-01 00:04:00\n      2\n      -3.0\n      0.0\n      0.0\n      0.0\n      -3.0\n      0.0\n      300.0\n      0.1\n      0\n      383\n      16.8\n      30.5\n      966\n    \n  \n\n\n\n\nSimilarly, df.tail() prints the last five rows.\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\nbsrn.tail()\n\n\n\n\n\n\n  \n    \n      \n      DATE\n      H_m\n      SWD_Wm2\n      STD_SWD\n      DIR_Wm2\n      STD_DIR\n      DIF_Wm2\n      STD_DIF\n      LWD_Wm2\n      STD_LWD\n      SWU_Wm2\n      LWU_Wm2\n      T_degC\n      RH\n      P_hPa\n    \n  \n  \n    \n      44635\n      2019-10-31 23:55:00\n      2\n      -2.0\n      0.0\n      0.0\n      0.0\n      -2.0\n      0.0\n      380.0\n      0.1\n      0\n      423\n      23.0\n      35.6\n      964\n    \n    \n      44636\n      2019-10-31 23:56:00\n      2\n      -2.0\n      0.0\n      0.0\n      0.0\n      -2.0\n      0.0\n      380.0\n      0.1\n      0\n      423\n      23.1\n      35.5\n      964\n    \n    \n      44637\n      2019-10-31 23:57:00\n      2\n      -2.0\n      0.0\n      0.0\n      0.0\n      -2.0\n      0.0\n      380.0\n      0.1\n      0\n      423\n      23.0\n      35.3\n      964\n    \n    \n      44638\n      2019-10-31 23:58:00\n      2\n      -2.0\n      0.0\n      0.0\n      0.0\n      -2.0\n      0.0\n      381.0\n      0.2\n      0\n      423\n      23.0\n      35.2\n      964\n    \n    \n      44639\n      2019-10-31 23:59:00\n      2\n      -2.0\n      0.0\n      0.0\n      0.0\n      -2.0\n      0.0\n      381.0\n      0.1\n      0\n      423\n      23.1\n      35.0\n      964\n    \n  \n\n\n\n\nBoth df.head() and df.tail() can also accept an integer argument, e.g.¬†df.head(n), where the first n rows will be printed.\n\n‚úèÔ∏è <b> Try it. </b> \nPrint the first and last 10 rows of <code>bsrn</code> using <code>df.head()</code> and <code>df.tail()</code>.\n\n\n\nCode\n# First 10 rows\nprint(bsrn.head(10))\n\n# Last 10 rows\nprint(bsrn.tail(10))\n\n\n                  DATE  H_m  SWD_Wm2  STD_SWD  DIR_Wm2  STD_DIR  DIF_Wm2  \\\n0  2019-10-01 00:00:00    2     -3.0      0.0      0.0      0.0     -3.0   \n1  2019-10-01 00:01:00    2     -3.0      0.0      0.0      0.0     -3.0   \n2  2019-10-01 00:02:00    2     -3.0      0.0      0.0      0.0     -3.0   \n3  2019-10-01 00:03:00    2     -3.0      0.0      0.0      0.0     -3.0   \n4  2019-10-01 00:04:00    2     -3.0      0.0      0.0      0.0     -3.0   \n5  2019-10-01 00:05:00    2     -2.0      0.0      0.0      0.0     -2.0   \n6  2019-10-01 00:06:00    2     -2.0      0.0      0.0      0.0     -2.0   \n7  2019-10-01 00:07:00    2     -2.0      0.0      0.0      0.0     -2.0   \n8  2019-10-01 00:08:00    2     -2.0      0.0      0.0      0.0     -2.0   \n9  2019-10-01 00:09:00    2     -2.0      0.0      0.0      0.0     -2.0   \n\n   STD_DIF  LWD_Wm2  STD_LWD  SWU_Wm2  LWU_Wm2  T_degC    RH  P_hPa  \n0      0.0    300.0      0.1        0      383    16.2  30.7    966  \n1      0.0    300.0      0.3        0      383    16.4  30.7    966  \n2      0.0    300.0      0.2        0      383    16.5  30.5    966  \n3      0.0    300.0      0.1        0      383    16.5  30.4    966  \n4      0.0    300.0      0.1        0      383    16.8  30.5    966  \n5      0.0    300.0      0.2        0      383    16.9  30.5    966  \n6      0.0    300.0      0.2        0      383    16.8  30.4    966  \n7      0.0    300.0      0.1        0      384    17.0  31.0    966  \n8      0.0    300.0      0.2        0      384    16.7  30.6    966  \n9      0.0    301.0      0.3        0      384    17.1  30.6    966  \n                      DATE  H_m  SWD_Wm2  STD_SWD  DIR_Wm2  STD_DIR  DIF_Wm2  \\\n44630  2019-10-31 23:50:00    2     -2.0      0.0      0.0      0.0     -2.0   \n44631  2019-10-31 23:51:00    2     -2.0      0.0      0.0      0.0     -2.0   \n44632  2019-10-31 23:52:00    2     -2.0      0.0      0.0      0.0     -2.0   \n44633  2019-10-31 23:53:00    2     -2.0      0.0      0.0      0.0     -2.0   \n44634  2019-10-31 23:54:00    2     -2.0      0.0      0.0      0.0     -2.0   \n44635  2019-10-31 23:55:00    2     -2.0      0.0      0.0      0.0     -2.0   \n44636  2019-10-31 23:56:00    2     -2.0      0.0      0.0      0.0     -2.0   \n44637  2019-10-31 23:57:00    2     -2.0      0.0      0.0      0.0     -2.0   \n44638  2019-10-31 23:58:00    2     -2.0      0.0      0.0      0.0     -2.0   \n44639  2019-10-31 23:59:00    2     -2.0      0.0      0.0      0.0     -2.0   \n\n       STD_DIF  LWD_Wm2  STD_LWD  SWU_Wm2  LWU_Wm2  T_degC    RH  P_hPa  \n44630      0.0    381.0      0.2        0      422    22.6  35.8    964  \n44631      0.0    380.0      0.0        0      422    22.5  35.8    964  \n44632      0.0    380.0      0.1        0      422    22.6  35.8    964  \n44633      0.0    380.0      0.1        0      422    22.8  35.8    964  \n44634      0.0    380.0      0.1        0      422    22.9  35.7    964  \n44635      0.0    380.0      0.1        0      423    23.0  35.6    964  \n44636      0.0    380.0      0.1        0      423    23.1  35.5    964  \n44637      0.0    380.0      0.1        0      423    23.0  35.3    964  \n44638      0.0    381.0      0.2        0      423    23.0  35.2    964  \n44639      0.0    381.0      0.1        0      423    23.1  35.0    964  \n\n\nIn addition to those for viewing your data, pandas has several methods to describe attributes of your DataFrame. For example, df.info() provides basic information about the DataFrame:\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\nbsrn.info()\n\n\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 44640 entries, 0 to 44639\nData columns (total 15 columns):\n #   Column   Non-Null Count  Dtype  \n---  ------   --------------  -----  \n 0   DATE     44640 non-null  object \n 1   H_m      44640 non-null  int64  \n 2   SWD_Wm2  44630 non-null  float64\n 3   STD_SWD  44637 non-null  float64\n 4   DIR_Wm2  44623 non-null  float64\n 5   STD_DIR  44623 non-null  float64\n 6   DIF_Wm2  44632 non-null  float64\n 7   STD_DIF  44632 non-null  float64\n 8   LWD_Wm2  44589 non-null  float64\n 9   STD_LWD  44637 non-null  float64\n 10  SWU_Wm2  44640 non-null  int64  \n 11  LWU_Wm2  44640 non-null  int64  \n 12  T_degC   44640 non-null  float64\n 13  RH       44640 non-null  float64\n 14  P_hPa    44640 non-null  int64  \ndtypes: float64(10), int64(4), object(1)\nmemory usage: 5.1+ MB\n\n\nThe df.info() method provides several different pieces of information about the DataFrame that are sometimes useful to retrieve separately. For example, df.index returns the index as an iterable object for use in plotting and the df.columns method returns the column names as an index object which can be used in a for loop or to reset the column names. These and other descriptive DataFrame methods are summarized in the table below.\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\n df.info() \nPrints a concise summary of the DataFrame\n\n\n df.head(n) \nReturns the first n rows of the DataFrame\n\n\n df.tail(n) \nReturns the last n rows of the DataFrame\n\n\n df.index \nReturns the index range (number of rows)\n\n\n df.columns \nReturns the column names\n\n\n df.dtypes \nReturns a Series with the data types of each column indexed by column name\n\n\n df.size \nReturns the total number of values in the DataFrame as an int\n\n\n df.shape \nReturns the shape of the DataFrame as a tuple (rows,columns)\n\n\n df.values \nReturns the DataFrame values as a NumPy array (not recommended)\n\n\n df.describe() \nReturns a DataFrame with summary statistics of each column\n\n\n\n\nüìö  Practice 2. Using the DataFrame <code>bsrn</code>:\n<ol class=\"alpha\">\n    <li> Print a list of column names. </li>\n    <li> How many values are there in the entire DataFrame? </li>\n    <li> What is the data type of the first column? </li>\n\n\n\n\nCode\n# 2a. Print a list of column names\nprint(list(bsrn.columns))\n\n# 2b. Values in entire DataFrame\nprint(bsrn.size)\n\n# 2c. Retrieve data type of first column\nprint(list(bsrn.dtypes)[0]) \n\n\n['DATE', 'H_m', 'SWD_Wm2', 'STD_SWD', 'DIR_Wm2', 'STD_DIR', 'DIF_Wm2', 'STD_DIF', 'LWD_Wm2', 'STD_LWD', 'SWU_Wm2', 'LWU_Wm2', 'T_degC', 'RH', 'P_hPa']\n669600\nobject\n\n\n\n\nDataFrame indexing + data selection\n\n\nBecause DataFrames can contain labels as well as indices, indexing in pandas DataFrames is a bit more complicated than we‚Äôve seen with strings, lists, and arrays. Generally speaking, pandas allows indexing by either the integer index or the label, but the syntax is a bit different for each.\nThe index operator, which refers to the square brackets following an object [], does not work quite like we might expect it to.\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\nbsrn[1434,12]\n\n\nKeyError: (1434, 12)\n\n\nInstead of a value, we get a KeyError. This is because the Index object in pandas is essentially a dictionary, and we have not passed proper keys.\nInstead, pandas uses df.iloc[] for integer-based indexing to select data by position:\nbsrn.iloc[1434,12]\n\n >>>  19.6\n\ndf.iloc acts just like the index operator works with arrays. In addition to indexing a single value, df.iloc can be used to select multiple rows and columns via slicing: df.iloc[row_start:row_end:row_step, col_start:col_end:col_step].\n# Select 6 rows, last 3 columns\nbsrn.iloc[1434:1440,12:]\n\n\n\n\n\n      T_degC    RH  P_hPa\n1434    19.6  17.6    965\n1435    19.5  17.5    965\n1436    19.4  17.4    965\n1437    19.1  17.5    965\n1438    19.4  17.6    965\n1439    19.3  17.5    965\n\n\n\n\n# First 5 columns, every 40th row\nbsrn.iloc[::40,:5]\n\n\n\n\n\n DATE H_m SWD_Wm2 STD_SWD DIR_Wm2 0 2019-10-01 00:00:00 2 -3.0 0.0 0.0 40 2019-10-01 00:40:00 2 -3.0 0.0 0.0 80 2019-10-01 01:20:00 2 -3.0 0.0 0.0 120 2019-10-01 02:00:00 2 -3.0 0.0 0.0 160 2019-10-01 02:40:00 2 -2.0 0.0 0.0 ‚Ä¶ ‚Ä¶ ‚Ä¶ ‚Ä¶ ‚Ä¶ ‚Ä¶ 44440 2019-10-31 20:40:00 2 -2.0 0.0 0.0 44480 2019-10-31 21:20:00 2 -2.0 0.0 0.0 44520 2019-10-31 22:00:00 2 -2.0 0.0 0.0 44560 2019-10-31 22:40:00 2 -2.0 0.0 0.0 44600 2019-10-31 23:20:00 2 -2.0 0.0 0.0\n\n\n\n[1116 rows x 5 columns] \n\n\nRow indexing\nIn addition to df.iloc, rows of a DataFrame can be accessed using df.loc, which ‚Äúlocates‚Äù rows based on their labels. Unless you have set a custom index (which we will see later), the row ‚Äúlabels‚Äù are the same as the integer index.\nWhen indexing a single row, df.loc (like df.iloc) transforms the row into a Series, with the column names as the index:\n# Classic indexing\nbsrn[1434]\n\n\n\n\n\nDATE       2019-10-01 23:54:00\nH_m                          2\nSWD_Wm2                     -2\nSTD_SWD                      0\nDIR_Wm2                      0\nSTD_DIR                      0\nDIF_Wm2                     -2\nSTD_DIF                      0\nLWD_Wm2                    307\nSTD_LWD                    0.1\nSWU_Wm2                      0\nLWU_Wm2                    385\nT_degC                    19.6\nRH                        17.6\nP_hPa                      965\nName: 1434, dtype: object\n\n\n\n\n\nüêç <b>DataFrames + data types.</b>  Notice that the <code>dtype</code> of the Series is an <code>object</code>. This is because the column contains mixed data types ‚Äì floats, integers, and an <code>object</code> in the first row. Unlike NumPy, pandas allows both rows and columns to contain mixed data types. However, while it is perfectly fine (and, in fact, almost always necessary) to have multiple data types within a single <b><i>row</i></b>, it is best if each <b><i>column</i></b> is comprised of a <b><i>single data type</i></b>.\n\nSlicing using df.loc is similar to df.iloc, with the exception that the stop value is inclusive:\n# Using .loc\nbsrn.loc[1434:1440]\n\n\n\n\n\n DATE H_m SWD_Wm2 STD_SWD DIR_Wm2 ‚Ä¶ SWU_Wm2 LWU_Wm2 T_degC RH P_hPa 1434 2019-10-01 23:54:00 2 -2.0 0.0 0.0 ‚Ä¶ 0 385 19.6 17.6 965 1435 2019-10-01 23:55:00 2 -2.0 0.0 0.0 ‚Ä¶ 0 385 19.5 17.5 965 1436 2019-10-01 23:56:00 2 -2.0 0.0 0.0 ‚Ä¶ 0 386 19.4 17.4 965 1437 2019-10-01 23:57:00 2 -2.0 0.0 0.0 ‚Ä¶ 0 386 19.1 17.5 965 1438 2019-10-01 23:58:00 2 -2.0 0.0 0.0 ‚Ä¶ 0 386 19.4 17.6 965 1439 2019-10-01 23:59:00 2 -2.0 0.0 0.0 ‚Ä¶ 0 386 19.3 17.5 965 1440 2019-10-02 00:00:00 2 -2.0 0.0 0.0 ‚Ä¶ 0 386 19.1 17.5 965\n\n\n\n[7 rows x 15 columns] \n\n\n\nColumn indexing\nIn addition to integer indexing with df.iloc, columns can be accessed in two ways: dot notation . or square brackets []. The former takes advantage of the fact that the columns are effectively ‚Äúattributes‚Äù of the DataFrame and returns a Series:\nbsrn.SWD_Wm2\n\n\n\n\n\n0       -3.0\n1       -3.0\n2       -3.0\n3       -3.0\n4       -3.0\n...\n44635   -2.0\n44636   -2.0\n44637   -2.0\n44638   -2.0\n44639   -2.0\nName: SWD_Wm2, Length: 44640, dtype: float64\n\n\n\n\nThe second way of extracting columns is to pass the column name as a string in square brackets, i.e.¬†df['col']:\nbsrn['SWD_Wm2']\n\n\n\n\n\n0       -3.0\n1       -3.0\n2       -3.0\n3       -3.0\n4       -3.0\n...\n44635   -2.0\n44636   -2.0\n44637   -2.0\n44638   -2.0\n44639   -2.0\nName: SWD_Wm2, Length: 44640, dtype: float64\n\n\n\n\nUsing single brackets, the result is a Series. However, using double brackets, it is possible to return the column as a DataFrame:\nbsrn[['SWD_Wm2']]\n\n\n\n\n\n SWD_Wm2 0 -3.0 1 -3.0 2 -3.0 3 -3.0 4 -3.0 ‚Ä¶ ‚Ä¶ 44635 -2.0 44636 -2.0 44637 -2.0 44638 -2.0 44639 -2.0\n\n\n\n[44640 rows x 1 columns] \n\nThis allows you to add additional columns, which you cannot do with a Series object. Furthermore, with the double bracket notation, a list is being passed to the index operator (outer brackets). Thus, it is possible to extract multiple columns by adding column names to the list:\nbsrn[['SWD_Wm2','LWD_Wm2']]\n\n\n\n\n\n SWD_Wm2 LWD_Wm2 0 -3.0 300.0 1 -3.0 300.0 2 -3.0 300.0 3 -3.0 300.0 4 -3.0 300.0 ‚Ä¶ ‚Ä¶ ‚Ä¶ 44635 -2.0 380.0 44636 -2.0 380.0 44637 -2.0 380.0 44638 -2.0 381.0 44639 -2.0 381.0\n\n\n\n[44640 rows x 2 columns] \n\nWhen accessing a single column, the choice between using dot notation and square brackets is more or less a matter of preference. However, there are occasions when the bracket notation proves particularly useful. For example, you could access each column in a DataFrame by iterating through df.columns, which returns an Index object containing the column names as str objects that can be directly passed to the index operator. Additionally, you may find it useful to use the double bracket syntax to return a DataFrame object, rather than a Series, which can only ever contain a single column of data.\n\nüìö  Practice 3.\n<ol class=\"alpha\">\n    <li> Create a new DataFrame containing the first record for each day and the following columns: the timestamp of the record, incoming shortwave radiation, direct and diffuse radiation, and incoming longwave radiation. (Hint: the BSRN station collects data every minute). </li>\n    <li> Create a new Series containing the temperature values every hour at the top of the hour. </li>\n</ol>\n\n\n\nCode\n# Daily radiation data\nbsrn_day = bsrn.iloc[::1440,:9:2]\n\n# Hourly temperatures\ntemp_hr = bsrn.T_degC[::60]\n\n\n\n\n\nDatetime objects\n\n\nLike the BSRN data we are working with in this exercise, many environmental datasets include timed records. Python has a few different libraries for dealing with timestamps, which are referred to as datetime objects. The standard datetime library is the primary way of manipulating dates and times in Python, but there are additional third-party packages that provide additional support. A few worth exploring are dateutil, an extension of the datetime library useful for parsing timestamps, and pytz, which provides a smooth way of tackling time zones.\nThough we will not review datetime objects in depth here, it is useful to understand the basics of how to deal with datetime objects in Python as you will no doubt encounter them in the future. For now, we will focus on a few pandas functions built on the datetime library to handle datetime objects.\nThe pd.date_range() function allows you to build a DatetimeIndex with a fixed frequency. This can be done by specifying a start date and an end date as follows:\npd.date_range('4/1/2017','4/30/2017')\n\n>>> DatetimeIndex(['2017-01-01', '2017-01-02', '2017-01-03', '2017-01-04',\n                   '2017-01-05', '2017-01-06', '2017-01-07', '2017-01-08',\n                   '2017-01-09', '2017-01-10',\n                   ...\n                   '2020-12-22', '2020-12-23', '2020-12-24', '2020-12-25',\n                   '2020-12-26', '2020-12-27', '2020-12-28', '2020-12-29',\n                   '2020-12-30', '2020-12-31'],\n                  dtype='datetime64[ns]', length=1461, freq='D')\nBecause it was not specified otherwise, the frequency was set as the default, daily. To return a different frequency, we could use the freq parameter:\n# Specify start and end, minute-ly frequency\npd.date_range('1/1/2017','12/31/2020', freq='min')\n\n>>> DatetimeIndex(['2017-01-01 00:00:00', '2017-01-01 00:01:00',\n                   '2017-01-01 00:02:00', '2017-01-01 00:03:00',\n                   '2017-01-01 00:04:00', '2017-01-01 00:05:00',\n                   '2017-01-01 00:06:00', '2017-01-01 00:07:00',\n                   '2017-01-01 00:08:00', '2017-01-01 00:09:00',\n                   ...\n                   '2020-12-30 23:51:00', '2020-12-30 23:52:00',\n                   '2020-12-30 23:53:00', '2020-12-30 23:54:00',\n                   '2020-12-30 23:55:00', '2020-12-30 23:56:00',\n                   '2020-12-30 23:57:00', '2020-12-30 23:58:00',\n                   '2020-12-30 23:59:00', '2020-12-31 00:00:00'],\n                  dtype='datetime64[ns]', length=2102401, freq='T')\n\n# Specify start and end, monthly frequency\npd.date_range('1/1/2017','12/31/2020', freq='M')\n\n>>> DatetimeIndex(['2017-01-31', '2017-02-28', '2017-03-31', '2017-04-30',\n                   '2017-05-31', '2017-06-30', '2017-07-31', '2017-08-31',\n                   '2017-09-30', '2017-10-31', '2017-11-30', '2017-12-31',\n                   '2018-01-31', '2018-02-28', '2018-03-31', '2018-04-30',\n                   '2018-05-31', '2018-06-30', '2018-07-31', '2018-08-31',\n                   '2018-09-30', '2018-10-31', '2018-11-30', '2018-12-31',\n                   '2019-01-31', '2019-02-28', '2019-03-31', '2019-04-30',\n                   '2019-05-31', '2019-06-30', '2019-07-31', '2019-08-31',\n                   '2019-09-30', '2019-10-31', '2019-11-30', '2019-12-31',\n                   '2020-01-31', '2020-02-29', '2020-03-31', '2020-04-30',\n                   '2020-05-31', '2020-06-30', '2020-07-31', '2020-08-31',\n                   '2020-09-30', '2020-10-31', '2020-11-30', '2020-12-31'],\n                  dtype='datetime64[ns]', freq='M')\nThere are many other parameters for the pd.date_range() function, as well as other pandas functions. More useful to us, however, are the functions for dealing with existing timestamps, such as those in our bsrn DataFrame.\n\nParsing dates in pandas\nLet‚Äôs start by taking a look at bsrn.DATE, which contains the timestamps for each record of our BSRN data.\nbsrn.DATE\n\n\n\n\n\n0        2019-10-01 00:00:00\n1        2019-10-01 00:01:00\n2        2019-10-01 00:02:00\n3        2019-10-01 00:03:00\n4        2019-10-01 00:04:00\n...\n44635    2019-10-31 23:55:00\n44636    2019-10-31 23:56:00\n44637    2019-10-31 23:57:00\n44638    2019-10-31 23:58:00\n44639    2019-10-31 23:59:00\nName: DATE, Length: 44640, dtype: object\n\n\n\n\nWhile the values certainly resemble datetime objects, they are stored in pandas as ‚Äúobjects,‚Äù which basically means that pandas doesn‚Äôt recognize the data type ‚Äì¬†it doesn‚Äôt know how to handle them. Using the pd.to_datetime() function, we can convert this column to datetime objects:\npd.to_datetime(bsrn.DATE)\n\n\n\n\n\n0       2019-10-01 00:00:00\n1       2019-10-01 00:01:00\n2       2019-10-01 00:02:00\n3       2019-10-01 00:03:00\n4       2019-10-01 00:04:00\n...\n44635   2019-10-31 23:55:00\n44636   2019-10-31 23:56:00\n44637   2019-10-31 23:57:00\n44638   2019-10-31 23:58:00\n44639   2019-10-31 23:59:00\nName: DATE, Length: 44640, dtype: datetime64[ns]\n\n\n\n\nNotice that ostensibly nothing has changed, but the dtype is now a datetime object, making it much easier to manipulate not only this column, but the entire DataFrame. For instance, now that we‚Äôve told pandas that this column contains timestamps, we can set this column as the index using df.set_index().\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\n# Convert bsrn.DATE column to datetime objects\nbsrn['DATE'] = pd.to_datetime(bsrn.DATE)  # Note: overwriting a column like this is NOT recommended.\n\n# Set bsrn.DATE as the DataFrame index\nbsrn.set_index('DATE',inplace=True)\n\n\nAs noted in the comment in the cell above, reseting the values in a column as we did in the first line of code is generally not recommended, but in this case, since we knew exactly what the result would be, it‚Äôs acceptable. Also, notice the inplace=True argument passed to df.set_index(). This prevented us from having to copy the DataFrame to a new variable, instead performing the operation in-place.\nLet‚Äôs take a look at our DataFrame again:\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\nbsrn.info()\n\n\n<class 'pandas.core.frame.DataFrame'>\nDatetimeIndex: 44640 entries, 2019-10-01 00:00:00 to 2019-10-31 23:59:00\nData columns (total 14 columns):\n #   Column   Non-Null Count  Dtype  \n---  ------   --------------  -----  \n 0   H_m      44640 non-null  int64  \n 1   SWD_Wm2  44630 non-null  float64\n 2   STD_SWD  44637 non-null  float64\n 3   DIR_Wm2  44623 non-null  float64\n 4   STD_DIR  44623 non-null  float64\n 5   DIF_Wm2  44632 non-null  float64\n 6   STD_DIF  44632 non-null  float64\n 7   LWD_Wm2  44589 non-null  float64\n 8   STD_LWD  44637 non-null  float64\n 9   SWU_Wm2  44640 non-null  int64  \n 10  LWU_Wm2  44640 non-null  int64  \n 11  T_degC   44640 non-null  float64\n 12  RH       44640 non-null  float64\n 13  P_hPa    44640 non-null  int64  \ndtypes: float64(10), int64(4)\nmemory usage: 5.1 MB\n\n\nAs expected, the index has been changed to a DatetimeIndex, and there is no longer a 'DATE' column. Had we wanted to keep the timestamps as a column as well, we could have passed drop=False to df.set_index(), telling pandas not to drop (or delete) the 'DATE' column. We can look at the DatetimeIndex just as before using df.index.\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\nbsrn.index\n\n\nDatetimeIndex(['2019-10-01 00:00:00', '2019-10-01 00:01:00',\n               '2019-10-01 00:02:00', '2019-10-01 00:03:00',\n               '2019-10-01 00:04:00', '2019-10-01 00:05:00',\n               '2019-10-01 00:06:00', '2019-10-01 00:07:00',\n               '2019-10-01 00:08:00', '2019-10-01 00:09:00',\n               ...\n               '2019-10-31 23:50:00', '2019-10-31 23:51:00',\n               '2019-10-31 23:52:00', '2019-10-31 23:53:00',\n               '2019-10-31 23:54:00', '2019-10-31 23:55:00',\n               '2019-10-31 23:56:00', '2019-10-31 23:57:00',\n               '2019-10-31 23:58:00', '2019-10-31 23:59:00'],\n              dtype='datetime64[ns]', name='DATE', length=44640, freq=None)\n\n\nNow that we have a DatetimeIndex, we can access specific attributes of the datetime objects like the year, day, hour, etc. To do this, we add the desired time period using dot notation: df.index.attribute. For a full list of attributes, see the pd.DatetimeIndex documentation. For example:\n# Get the hour of each record\nbsrn.index.hour\n\n\n\n\n\nInt64Index([ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n...\n23, 23, 23, 23, 23, 23, 23, 23, 23, 23],\ndtype='int64', name='DATE', length=44640)\n\n\n\n\nThe result is a pandas Index object with the same length as the original DataFrame. To return only the unique values, we use the Series.unique() function, which can be used on any Series object (including a column of a DataFrame):\n# Get the unique hour values\nbsrn.index.hour.unique()\n\n\n\n\n\nInt64Index([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,\n17, 18, 19, 20, 21, 22, 23],\ndtype='int64', name='DATE')\n\n\n\n\n\nüêç <b>Method chaining.</b>  This process of stringing multiple methods together in a single line of code is called <b>method chaining</b>, a hallmark of object-oriented programming. Method chaining is a means of concatenating functions in order to quickly complete a series of data transformations. In pandas, we often use method chaining in aggregation processes to perfrom calculations on groups or selections of data. Methods are appended using dot notation to the end of a command. Any code that is expressed using method chaining could also be written using a series of commands (and vice versa). Method chaining is common in JavaScript, and while it is not widely used in Python, it is commonly applied in pandas.\n\nDealing with datetime objects can be tricky and often requires a bit of trial and error before the timestamps are in the desired format. If you know the format of your dataset and its timestamp records, you can parse the datetimes and set the index when reading in the data. For example, we could have imported our data as follows:\nbsrn = pd.read_csv('../data/BSRN_GOB_2019_10.csv',index_col=0,parse_dates=True)\nThis would have accomplished what we ultimately did in three lines in a single line of code. But remember, working with most raw datasets is rarely this straightforward ‚Äì¬†even the file we are using in this exercise was preprocessed to streamline the import process!\n\n\n\nA few useful operations\n\n\nNow that our DataFrame is a bit cleaner ‚Äì each of the columns contains a single, numeric data type ‚Äì we are ready to start working with our data. Next, we‚Äôll explore DataFrame reduction operations, how to add and delete data, and concatenation in pandas.\n\nDataFrame reduction\nMuch like NumPy, pandas has several useful methods for reducing data to a single statistic. These are intuitively named and include: df.mean(), df.median(), df.sum(), df.max(), df.min(), and df.std(). Unlike array reduction, however, these basic statistical methods in pandas operate column-wise, returning a Series containing the statistic for each column indexed by column name. For example:\n# Calculate median of each column\nbsrn.median()\n\n\n\n\n\nH_m          2.0\nSWD_Wm2     27.0\nSTD_SWD      0.3\nDIR_Wm2      0.0\nSTD_DIR      0.0\nDIF_Wm2     19.0\nSTD_DIF      0.1\nLWD_Wm2    340.0\nSTD_LWD      0.1\nSWU_Wm2     11.0\nLWU_Wm2    432.0\nT_degC      22.4\nRH          33.1\nP_hPa      965.0\ndtype: float64\n\n\n\n\nTo retrieve the value for just a single column, you can use indexing to call the column as a Series:\n# Calculate median incoming shortwave radiation\nbsrn.SWD_Wm2.median()\n\n >>>  27.0\n\nFurthermore, while it is not apparent in this example, pandas default behaviour is to ignore NaN values when performing computations. This can be changed by passing skipna=False to the reduction method (e.g.¬†df.median(skipna=False)), though skipping NaNs is often quite useful!\n\nüìö  <b> Practice 4. </b> Calculate the mean incoming shortwave, outgoing shortwave, incoming longwave, and outgoing longwave radiation over the entire month.\n\n\n\nCode\n# 4. Mean SW in, SW out, LW in, LW out\nprint('Mean SW incoming radiation = ', bsrn.SWD_Wm2.mean(), ' W m-2')\nprint('Mean SW outgoing radiation = ', bsrn.SWU_Wm2.mean(), ' W m-2')\nprint('Mean LW incoming radiation = ', bsrn.LWD_Wm2.mean(), ' W m-2')\nprint('Mean LW outgoing radiation = ', bsrn.LWU_Wm2.mean(), ' W m-2')\n\n\nMean SW incoming radiation =  318.0465157965494  W m-2\nMean SW outgoing radiation =  110.44500448028674  W m-2\nMean LW incoming radiation =  342.35069187467764  W m-2\nMean LW outgoing radiation =  455.0540322580645  W m-2\n\n\n\n\nAdding data\nMuch like when we converted bsrn.DATE to datetime objects, a column can be added to a DataFrame using square bracket notation with a new column label as a string. The data for the new column can come in the form of a list, Series, or a single value:\ndf = pd.DataFrame([[25.8, 28.1, 16.2, 11.0],[17.9, 14.2, 18.8, 28.0],\n                   [23.6, 18.4, 29.9, 27.8],[23.6, 36.2, 22.1, 14.5]],\n                 columns=['A','B','C','D'])\n\n# Add a column from a list\ndf['E'] = [13.0, 40.1, 39.8, 28.2]\n\n# Add a column from a Series\ndf['F'] = pd.Series([18, 22, 30, 24])\n\n# Propagate a single value through all rows\ndf['G'] = 'blue'\n\ndf\n\n\n\n\n\n      A     B     C     D     E   F     G\n0  25.8  28.1  16.2  11.0  13.0  18  blue\n1  17.9  14.2  18.8  28.0  40.1  22  blue\n2  23.6  18.4  29.9  27.8  39.8  30  blue\n3  23.6  36.2  22.1  14.5  28.2  24  blue\n\n\n\n\nNew columns can also be added as the result of an arithmetic operation (e.g.¬†sum, product, etc.) performed on one or more existing columns:\n# Add a new column by converting values in df.A from ¬∞C to ¬∞F\ndf['A_degF'] = (df.A * (9/5)) + 32\n\n# Add a new column representing the difference between df.B and df.C\ndf['BC_diff'] = df.B - df.C\n\ndf\n\n\n\n\n\n      A     B     C     D     E   F     G  A_degF  BC_diff\n0  25.8  28.1  16.2  11.0  13.0  18  blue   78.44     11.9\n1  17.9  14.2  18.8  28.0  40.1  22  blue   64.22     -4.6\n2  23.6  18.4  29.9  27.8  39.8  30  blue   74.48    -11.5\n3  23.6  36.2  22.1  14.5  28.2  24  blue   74.48     14.1\n\n\n\n\nFinally, you can use a Boolean expression to add a column, which contains Boolean objects (True or False) based on the condition. For example:\n# Add a column with Booleans for values in df.D greater than or equal to 20.0\ndf['D_20plus'] = df.D >= 20.0\n\ndf\n\n\n\n\n\n      A     B     C     D     E   F     G  A_degF  BC_diff  D_20plus\n0  25.8  28.1  16.2  11.0  13.0  18  blue   78.44     11.9     False\n1  17.9  14.2  18.8  28.0  40.1  22  blue   64.22     -4.6      True\n2  23.6  18.4  29.9  27.8  39.8  30  blue   74.48    -11.5      True\n3  23.6  36.2  22.1  14.5  28.2  24  blue   74.48     14.1     False\n\n\n\n\nThese conditional expressions can also be used to create Boolean masks, which allow you to ‚Äúmask‚Äù the values in the DataFrame that do not meet a condition, only extracting those that do. For example, let‚Äôs use a Boolean mask to apply an mathematical expression on only certain values in column 'D':\n# Subtract 20 from all values in dfD greater than or equal to 20\ndf['D_less20'] = df.D[df.D >= 20.0] - 20.0\n\ndf\n\n\n\n\n\n      A     B     C     D     E   F     G  A_degF  BC_diff  D_20plus  D_less20\n0  25.8  28.1  16.2  11.0  13.0  18  blue   78.44     11.9     False       NaN\n1  17.9  14.2  18.8  28.0  40.1  22  blue   64.22     -4.6      True       8.0\n2  23.6  18.4  29.9  27.8  39.8  30  blue   74.48    -11.5      True       7.8\n3  23.6  36.2  22.1  14.5  28.2  24  blue   74.48     14.1     False       NaN\n\n\n\n\nAll values that do not meet the condition are hidden from the expression, leaving NaNs in the resulting column. Boolean masks come in quite handy in data analysis, as they allow you to extract certain rows from a DataFrame based on their values in one or more columns.\nFurthermore, in addition to simply adding columns, new columns can be inserted in a desired index position using df.insert() with arguments specifying the location, name, and values of the column:\n# Create list of seasons\nseasons = ['winter', 'spring', 'summer', 'fall']\n\n# Insert season as first column\ndf.insert(0, 'SEASON', seasons)\n\ndf\n\n\n\n\n\n   SEASON     A     B     C     D     E   F     G  A_degF  BC_diff  D_20plus  D_less20\n0  winter  25.8  28.1  16.2  11.0  13.0  18  blue   78.44     11.9     False       NaN\n1  spring  17.9  14.2  18.8  28.0  40.1  22  blue   64.22     -4.6      True       8.0\n2  summer  23.6  18.4  29.9  27.8  39.8  30  blue   74.48    -11.5      True       7.8\n3    fall  23.6  36.2  22.1  14.5  28.2  24  blue   74.48     14.1     False       NaN\n\n\n\n\n\n\nRemoving data\nUnlike adding new data columns, removing columns from a DataFrame should be done with caution. In fact, it‚Äôs not a bad idea to create a copy of your DataFrame before performing any operations. This will allow you to return to the original data as needed without having to re-import or re-initialize the DataFrame. If you do need to remove a column, you can use the del command:\n# Delete 'G' from df\ndel df['G']\n\ndf\n\n\n\n\n\n   SEASON     A     B     C     D     E   F  A_degF  BC_diff  D_20plus  D_less20\n0  winter  25.8  28.1  16.2  11.0  13.0  18   78.44     11.9     False       NaN\n1  spring  17.9  14.2  18.8  28.0  40.1  22   64.22     -4.6      True       8.0\n2  summer  23.6  18.4  29.9  27.8  39.8  30   74.48    -11.5      True       7.8\n3    fall  23.6  36.2  22.1  14.5  28.2  24   74.48     14.1     False       NaN\n\n\n\n\nNote that this is an in-place operation, meaning that the column is deleted from the original variable. Alternatively, you can use df.pop() to extract a column. This method allows a column values to be extracted (and deleted) from a DataFrame and assigned to a new variable:\n# Extract column 'F' from df as a new Series\ndf_F = df.pop('F')\n\ndf\n\n\n\n\n\n   SEASON     A     B     C     D     E  A_degF  BC_diff  D_20plus  D_less20\n0  winter  25.8  28.1  16.2  11.0  13.0   78.44     11.9     False       NaN\n1  spring  17.9  14.2  18.8  28.0  40.1   64.22     -4.6      True       8.0\n2  summer  23.6  18.4  29.9  27.8  39.8   74.48    -11.5      True       7.8\n3    fall  23.6  36.2  22.1  14.5  28.2   74.48     14.1     False       NaN\n\n\n\n\n\n\nApplying functions\nIn addition to manipulating individual columns, you can apply a function to an entire Series or DataFrame using the pandas function df.apply(). For example, consider our original DataFrame df, which consists of temperature values in ¬∞C:\ndf = pd.DataFrame([[25.8, 28.1, 16.2, 11.0],[17.9, 14.2, 18.8, 28.0],\n                   [23.6, 18.4, 29.9, 27.8],[23.6, 36.2, 22.1, 14.5]],\n                 columns=['A','B','C','D'])\ndf\n\n\n\n\n\n      A     B     C     D\n0  25.8  28.1  16.2  11.0\n1  17.9  14.2  18.8  28.0\n2  23.6  18.4  29.9  27.8\n3  23.6  36.2  22.1  14.5\n\n\n\n\nWe previously used arithmetic operators to convert column 'A' to ¬∞F, but we could also use a function. First, let‚Äôs define a function convert_CtoF to convert temperature values from Celsius to Fahrenheit:\ndef convert_CtoF(degC):\n    \"\"\" Converts a temperature to from Celsius to Fahrenheit\n    \n    Parameters\n    ----------\n        degC : float\n            Temperature value in ¬∞C\n       \n    Returns\n    -------\n        degF : float\n            Temperature value in ¬∞F\n    \"\"\"\n    \n    degF = (degC *(9./5)) + 32\n    \n    return degF\nUsing df.apply() we can use this function to convert values in column 'A' as follows:\ndf.A.apply(convert_CtoF)\n\n\n\n\n\n0    78.44\n1    64.22\n2    74.48\n3    74.48\nName: A, dtype: float64\n\n\n\n\nWhere this becomes especially useful is for operating on entire DataFrames. You have to be careful with this if your DataFrame contains multiple data types, but it works well when you need to perform an operation on an entire DataFrame. For example, we could convert all of the values in df by iterating through the columns, or, using df.apply(), we could acheive the same result in a single line of code:\ndf.apply(convert_CtoF)\n\n\n\n\n\n       A      B      C      D\n0  78.44  82.58  61.16  51.80\n1  64.22  57.56  65.84  82.40\n2  74.48  65.12  85.82  82.04\n3  74.48  97.16  71.78  58.10\n\n\n\n\n\nüìö  <b> Practice 5. </b>\n<ol class=\"alpha\">\n    <li> Add a column <code style='font-weight:normal'>'NET_SW'</code> to <code style='font-weight:normal'>bsrn</code> with the net shortwave radiation. </li>\n    <li> Add a column <code style='font-weight:normal'>'NET_LW'</code> to <code style='font-weight:normal'>bsrn</code> with the net longwave radiation. </li>\n    <li> Add a column <code style='font-weight:normal'>'NET_RAD'</code> to <code style='font-weight:normal'>bsrn</code> with the net total radiation. Net radiation is given by the following equation: </li>\n    $$R^{}_{N} \\, = \\,  R^{\\, \\downarrow}_{SW} \\, - \\,  R^{\\, \\uparrow}_{SW} \\, + \\, R^{\\, \\downarrow}_{LW} \\, - \\,  R^{\\, \\uparrow}_{LW}$$\n    where $R^{\\, \\downarrow}_{SW}$ and $R^{\\, \\uparrow}_{SW}$ are incoming and outgoing shortwave radiation, respectively, and $R^{\\, \\downarrow}_{LW}$ and $R^{\\, \\uparrow}_{LW}$ are incoming and outgoing longwave radiation, respectively.\n    <li> Create a new DataFrame with the day of the month and daily mean values of shortwave incoming, shortwave outgoing, longwave incoming, longwave outgoing radiation, and net total radiation. (Hint: use masking!).</li>\n</ol>\n\n\n\nCode\n# 5a. Net SW radiation\nbsrn['NET_SW'] = bsrn.SWD_Wm2 - bsrn.SWU_Wm2\n\n# 5b. Net LW radiation\nbsrn['NET_LW'] = bsrn.LWD_Wm2 - bsrn.LWU_Wm2\n\n# 5c. Net total radiation\nbsrn['NET_RAD'] = bsrn.SWD_Wm2 - bsrn.SWU_Wm2 + bsrn.LWD_Wm2 - bsrn.LWU_Wm2\n\n\n# 5d. Mean daily SW in, SW out, LW in, LW out, R_net\n# Initialize empty list\ndaily_rad_list = []\n# Iterate through unique day values\nfor d in bsrn.index.day.unique():\n    # SW in\n    swd = bsrn.SWD_Wm2[bsrn.index.day == d].mean()\n    # SW out\n    swu = bsrn.SWU_Wm2[bsrn.index.day == d].mean()\n    # LW in\n    lwd = bsrn.LWD_Wm2[bsrn.index.day == d].mean()\n    # LW out\n    lwu = bsrn.LWU_Wm2[bsrn.index.day == d].mean()\n    # Net total\n    rnet = swd - swu + lwd - lwu\n    # Add all values to a list of lists\n    daily_rad_list.append([d, swd, swu, lwd, lwu, rnet])\n\n# Convert to DataFrame\ndaily_rad = pd.DataFrame(daily_rad_list, columns=['DAY', 'SW_in', 'SW_out', 'LW_in', 'LW_out', 'R_NET'])\ndaily_rad\n\n\n\n\n\n\n  \n    \n      \n      DAY\n      SW_in\n      SW_out\n      LW_in\n      LW_out\n      R_NET\n    \n  \n  \n    \n      0\n      1\n      325.336345\n      115.334028\n      321.219903\n      458.834028\n      72.388192\n    \n    \n      1\n      2\n      322.732453\n      113.939583\n      318.131341\n      448.486111\n      78.438100\n    \n    \n      2\n      3\n      298.635417\n      103.261806\n      330.516667\n      429.979861\n      95.910417\n    \n    \n      3\n      4\n      323.209173\n      113.222222\n      314.129526\n      439.990972\n      84.125505\n    \n    \n      4\n      5\n      296.861806\n      105.461806\n      324.660876\n      427.359722\n      88.701153\n    \n    \n      5\n      6\n      292.118915\n      104.219444\n      330.458333\n      428.665278\n      89.692526\n    \n    \n      6\n      7\n      339.848611\n      119.959722\n      303.437413\n      439.002778\n      84.323524\n    \n    \n      7\n      8\n      332.009028\n      116.752778\n      313.126653\n      438.550000\n      89.832903\n    \n    \n      8\n      9\n      290.577083\n      104.436806\n      342.506267\n      428.110417\n      100.536129\n    \n    \n      9\n      10\n      310.887500\n      108.638889\n      331.667130\n      434.941667\n      98.974074\n    \n    \n      10\n      11\n      312.226389\n      108.406250\n      350.486787\n      458.562500\n      95.744426\n    \n    \n      11\n      12\n      313.099306\n      108.276389\n      375.387500\n      483.829167\n      96.381250\n    \n    \n      12\n      13\n      292.540972\n      97.745833\n      389.507307\n      485.947222\n      98.355224\n    \n    \n      13\n      14\n      210.243056\n      76.329167\n      390.913829\n      470.870139\n      53.957579\n    \n    \n      14\n      15\n      294.886806\n      91.408333\n      399.457639\n      500.201389\n      102.734722\n    \n    \n      15\n      16\n      322.011111\n      114.262500\n      400.745833\n      510.212500\n      98.281944\n    \n    \n      16\n      17\n      306.800000\n      106.773611\n      390.968033\n      492.745833\n      98.248589\n    \n    \n      17\n      18\n      298.656250\n      104.536111\n      364.097222\n      459.456944\n      98.760417\n    \n    \n      18\n      19\n      314.968750\n      110.327083\n      365.431250\n      460.609028\n      109.463889\n    \n    \n      19\n      20\n      329.323611\n      113.339583\n      357.791522\n      473.039583\n      100.735966\n    \n    \n      20\n      21\n      338.721334\n      117.433333\n      340.713189\n      470.612500\n      91.388690\n    \n    \n      21\n      22\n      338.259722\n      117.554861\n      325.689368\n      441.588194\n      104.806034\n    \n    \n      22\n      23\n      354.881944\n      122.917361\n      306.553857\n      438.565972\n      99.952468\n    \n    \n      23\n      24\n      344.563194\n      119.732639\n      319.499653\n      452.019444\n      92.310764\n    \n    \n      24\n      25\n      261.228472\n      87.575000\n      344.902643\n      441.439583\n      77.116531\n    \n    \n      25\n      26\n      345.552778\n      118.828472\n      337.203614\n      459.212500\n      104.715419\n    \n    \n      26\n      27\n      356.714583\n      123.323611\n      309.846421\n      434.491667\n      108.745727\n    \n    \n      27\n      28\n      358.297636\n      125.206944\n      303.482615\n      421.080556\n      115.492750\n    \n    \n      28\n      29\n      352.906944\n      122.894444\n      322.271399\n      448.573611\n      103.710288\n    \n    \n      29\n      30\n      357.626129\n      123.736806\n      331.607516\n      462.778472\n      102.718367\n    \n    \n      30\n      31\n      323.794302\n      107.959722\n      356.192629\n      466.917361\n      105.109847\n    \n  \n\n\n\n\n\n\nCombining DataFrames\nThere are several ways to combine data from multiple Series or DataFrames into a single object in pandas. These functions include pd.append(), pd.join(), and pd.merge(). We will focus on the general pd.concat() function, which is the most versatile way to concatenate pandas objects. To learn more about these other functions, refer to the pandas documentation or see  Chapter 3 of the  Python Data Science Handbook.\nLet‚Äôs start by considering the simplest case of two DataFrames with identical columns:\ndf1 = pd.DataFrame([['Los Angeles', 34.0522, -118.2437],\n                    ['Bamako', 12.6392, 8.0029],\n                    ['Johannesburg', -26.2041, 28.0473],\n                    ['Cairo', 30.0444, 31.2357]],\n                  columns=['CITY', 'LAT', 'LONG'])\n\ndf2 = pd.DataFrame([['Cape Town', -33.9249, 18.4241],\n                    ['Kyoto', 35.0116, 135.7681],\n                    ['London', 51.5074, -0.1278],\n                    ['Cochabamba', -17.4140, -66.1653]],\n                  columns=['CITY', 'LAT', 'LONG'])\nUsing pd.concat([df1,df2]), we can combine the two DataFrames into one. Notice that we must pass the DataFrames as a list, because pd.concat() requires an iterable object as its input.\n# Concatenate df1 and df2\ncity_coords = pd.concat([df1,df2])\n\ncity_coords\n\n\n\n\n\n           CITY      LAT      LONG\n0   Los Angeles  34.0522 -118.2437\n1        Bamako  12.6392    8.0029\n2  Johannesburg -26.2041   28.0473\n3         Cairo  30.0444   31.2357\n0     Cape Town -33.9249   18.4241\n1         Kyoto  35.0116  135.7681\n2        London  51.5074   -0.1278\n3    Cochabamba -17.4140  -66.1653\n\n\n\n\nBy default, pandas concatenates along the row axis, appending the values in df2 to df1 as new rows. However, notice that the original index values have been retained. Since these index labels do not contain useful information, it would be best to reset the index before proceeding. This can be done in one of two ways. First, we could have passed ignore_index=True to the pd.concat() function, telling pandas to ignore the index labels. Since we have already created a new variable, however, let‚Äôs use a more general method: df.reset_index().\n# Reset index in-place and delete old index\ncity_coords.reset_index(inplace=True, drop=True)\n\ncity_coords\n\n\n\n\n\n           CITY      LAT      LONG\n0   Los Angeles  34.0522 -118.2437\n1        Bamako  12.6392    8.0029\n2  Johannesburg -26.2041   28.0473\n3         Cairo  30.0444   31.2357\n4     Cape Town -33.9249   18.4241\n5         Kyoto  35.0116  135.7681\n6        London  51.5074   -0.1278\n7    Cochabamba -17.4140  -66.1653\n\n\n\n\nBy passing the optional inplace and drop parameters, we ensured that pandas would reset the index in-place (the default is to return a new DataFrame) and drop the old index (the default behaviour is to add the former index as a column).\nNow let‚Äôs consider the case of concatenating two DataFrames whose columns do not match. In this case, pandas will keep source rows and columns separate in the concatenated DataFrame, filling empty cells with NaN values:\ndf3 = pd.DataFrame([['USA', 87],['Mali', 350],['South Africa', 1753],['Egypt', 23],\n                    ['South Africa', 25],['Japan', 47],['UK', 11],['Bolivia', 2558]],\n                  columns=['COUNTRY', 'ELEV'])\n\n# Concatenate cities1 and df3\npd.concat([city_coords,df3])\n\n\n\n\n\n           CITY      LAT      LONG       COUNTRY    ELEV\n0   Los Angeles  34.0522 -118.2437           NaN     NaN\n1        Bamako  12.6392    8.0029           NaN     NaN\n2  Johannesburg -26.2041   28.0473           NaN     NaN\n3         Cairo  30.0444   31.2357           NaN     NaN\n4     Cape Town -33.9249   18.4241           NaN     NaN\n5         Kyoto  35.0116  135.7681           NaN     NaN\n6        London  51.5074   -0.1278           NaN     NaN\n7    Cochabamba -17.4140  -66.1653           NaN     NaN\n0           NaN      NaN       NaN           USA    87.0\n1           NaN      NaN       NaN          Mali   350.0\n2           NaN      NaN       NaN  South Africa  1753.0\n3           NaN      NaN       NaN         Egypt    23.0\n4           NaN      NaN       NaN  South Africa    25.0\n5           NaN      NaN       NaN         Japan    47.0\n6           NaN      NaN       NaN            UK    11.0\n7           NaN      NaN       NaN       Bolivia  2558.0\n\n\n\n\nInstead, we must pass axis=1 to the function to specify that we want to add the data in df3 as columns to the new DataFrame:\n# Concatenate along column axis\ncities = pd.concat([city_coords,df3], axis=1)\n\ncities\n\n\n\n\n\n           CITY      LAT      LONG       COUNTRY  ELEV\n0   Los Angeles  34.0522 -118.2437           USA    87\n1        Bamako  12.6392    8.0029          Mali   350\n2  Johannesburg -26.2041   28.0473  South Africa  1753\n3         Cairo  30.0444   31.2357         Egypt    23\n4     Cape Town -33.9249   18.4241  South Africa    25\n5         Kyoto  35.0116  135.7681         Japan    47\n6        London  51.5074   -0.1278            UK    11\n7    Cochabamba -17.4140  -66.1653       Bolivia  2558\n\n\n\n\n\nüìö  <b> Practice 6. </b> \n<ol class=\"alpha\">\n    <li> Concatenate <code>df1</code> and <code>df2</code> into a new DataFrame with all 9 rivers.</li>\n    <li> Create a new DataFrame <code>rivers</code> with the discharge, mouth, source, and continent information and add this to your DataFrame from (a) to produce a DataFrame with all of the data in the table below.</li>\n\n\n\n\n\nRiver\n\n\nLength (\\text{km})\n\n\nDrainage area (\\text{km}^2)\n\n\nDischarge (\\text{m}^2/\\text{s})\n\n\nMouth\n\n\nSource\n\n\nContinent\n\n\n\n\nAmazon\n\n\n6400\n\n\n7,050,000\n\n\n209,000\n\n\nAtlantic Ocean\n\n\nRio Mantaro\n\n\nSouth America\n\n\n\n\nCongo\n\n\n4371\n\n\n4,014,500\n\n\n41,200\n\n\nAtlantic Ocean\n\n\nLualaba River\n\n\nAfrica\n\n\n\n\nYangtze\n\n\n6418\n\n\n1,808,500\n\n\n30,166\n\n\nEast China Sea\n\n\nJianggendiru Glacier\n\n\nAsia\n\n\n\n\nMississippi\n\n\n3730\n\n\n3,202,230\n\n\n16,792\n\n\nGulf of Mexico\n\n\nLake Itasca\n\n\nNorth America\n\n\n\n\nZambezi\n\n\n2574\n\n\n1,331,000\n\n\n3,400\n\n\nIndian Ocean\n\n\nMiombo Woodlands\n\n\nAfrica\n\n\n\n\nMekong\n\n\n4023\n\n\n811,000\n\n\n16,000\n\n\nSouth China Sea\n\n\nLasagongma Spring\n\n\nAsia\n\n\n\n\nMurray\n\n\n2508\n\n\n1,0614,69\n\n\n767\n\n\nSouthern Ocean\n\n\nAustralian Alps\n\n\nOceania\n\n\n\n\nRh√¥ne\n\n\n813\n\n\n98,000\n\n\n1,710\n\n\nMediterranean Sea\n\n\nRh√¥ne Glacier\n\n\nEurope\n\n\n\n\nCubango\n\n\n1056\n\n\n530,000\n\n\n475\n\n\nOkavango Delta\n\n\nBi√© Plateau\n\n\nAfrica\n\n\n\n\n\n\n\nCode\n# 6a. Concatenate df1 and df2\nrivs = pd.concat([df1,df2],ignore_index=True)\n\n# 6b. Concatenate rivs and df3\n# Add new data to DataFrame\ndf3 = pd.DataFrame([[209000, 'Atlantic Ocean', 'Rio Mantaro', 'South America'], \n                    [41200, 'Atlantic Ocean', 'Lualaba River', 'Africa'],\n                    [30166, 'East China Sea', 'Jianggendiru Glacier', 'Asia'],\n                    [16792, 'Gulf of Mexico', 'Lake Itasca', 'North America'],\n                    [3400, 'Indian Ocean', 'Miombo Woodlands', 'Africa'],\n                    [16000, 'South China Sea', 'Lasagongma Spring', 'Asia'],\n                    [767, 'Southern Ocean', 'Australian Alps', 'Oceania'],\n                    [1710, 'Mediterranean Sea', 'Rhone Glacier', 'Europe'],\n                    [475, 'Okavango Delta', 'Bie Plateau', 'Africa']],\n                  columns=['DISCHARGE_m3s', 'MOUTH', 'SOURCE', 'CONTINENT'] )\n# Concatenate rivs + df3\nrivers = pd.concat([rivs,df3], axis=1)\nrivers\n\n\n\n\n\n\n  \n    \n      \n      RIVER\n      LENGTH_km\n      DRAINAGE_AREA_km2\n      DISCHARGE_m3s\n      MOUTH\n      SOURCE\n      CONTINENT\n    \n  \n  \n    \n      0\n      Amazon\n      6400\n      7050000\n      209000\n      Atlantic Ocean\n      Rio Mantaro\n      South America\n    \n    \n      1\n      Congo\n      4371\n      4014500\n      41200\n      Atlantic Ocean\n      Lualaba River\n      Africa\n    \n    \n      2\n      Yangtze\n      6418\n      1808500\n      30166\n      East China Sea\n      Jianggendiru Glacier\n      Asia\n    \n    \n      3\n      Mississippi\n      3730\n      3202230\n      16792\n      Gulf of Mexico\n      Lake Itasca\n      North America\n    \n    \n      4\n      Zambezi\n      2574\n      1331000\n      3400\n      Indian Ocean\n      Miombo Woodlands\n      Africa\n    \n    \n      5\n      Mekong\n      4023\n      811000\n      16000\n      South China Sea\n      Lasagongma Spring\n      Asia\n    \n    \n      6\n      Murray\n      2508\n      1061469\n      767\n      Southern Ocean\n      Australian Alps\n      Oceania\n    \n    \n      7\n      Rhone\n      813\n      98000\n      1710\n      Mediterranean Sea\n      Rhone Glacier\n      Europe\n    \n    \n      8\n      Cubango\n      1056\n      530000\n      475\n      Okavango Delta\n      Bie Plateau\n      Africa\n    \n  \n\n\n\n\n\n\n\nData export\n\n\nWhile you will most likely use pandas DataFrames to manipulate data, perform statistical analyses, and visualize results within Python, you may encounter scenarios where it is useful to ‚Äúsave‚Äù a DataFrame with which you‚Äôve been working. Exporting data from pandas is analogous to importing it.\nLet‚Äôs take the example of the cities DataFrame we created in the last example. Now that we‚Äôve compiled GPS coordinates of various cities, let‚Äôs say we wanted to load these data into a GIS software application. We could export this DataFrame using df.to_csv() specifying the file name with the full file path as follows:\ncities.to_csv('./exports/cities.csv')\n\nüìö  <b> Practice 7. </b> \nUsing the example above, export your <code>rivers</code> DataFrame to a CSV file in the <code>exports</code> folder. Make sure you have copied this folder over from your local copy of <code>envdatasci</code> to the <code>exercises</code> folder of your private repository first!\n\n\n\nCode\n# 7. Export rivers\nrivers.to_csv('./answerkeys/exports/rivers.csv')\n\n\n\n\n\n\nCode\n# IGNORE THIS CELL\nfrom IPython.core.display import HTML\ndef css_styling():\n    styles = open(\"./styles/exercises.css\", \"r\").read()\n    return HTML(styles)\ncss_styling()"
  },
  {
    "objectID": "answerkeys/Exercise1-5_Key.html#functions",
    "href": "answerkeys/Exercise1-5_Key.html#functions",
    "title": "",
    "section": "Functions",
    "text": "Functions\nA function is simply a set of instructions that you wish to use repeatedly on varying data. Sometimes a function is used to group a complex set of instructions that allows you to compartmentalize your code in ways that improve its readability. There are three types of functions in Python: builtin functions, user-defined functions, and anonymous functions. We have already seen many builtin functions, and you will meet many more in the coming weeks. This exercise focuses on user-defined and anonymous functions, both of which are important for advanced data analysis.\n\nUser-defined Functions (UDFs)\nA UDF is created using some very specific syntax. First, a function is delcared using the def keyword. The name of the function - and any arguments it takes - follows the def keyword, followed by a :. The combination of def and : is a similar construction to other control statements in Python that you‚Äôve already seen, such as for + :, and if + :. The code block below is the simplest possible function.\ndef my_function():\n    pass\nThe pass keyword means ‚Äúdo nothing‚Äù. Therefore, we have defined a function that: (1) does not take any arguments; (2) does nothing, and then (3) returns nothing.\n\nüêç <b>Note.</b> Technically, a function that lacks a <code>return</code> statement will still return a value. But the value it returns is <a href=\"https://docs.python.org/3/c-api/none.html\"><code>None</code></a>, which is python-ese for nothing. Just like the concept of <a href=https://www.amazon.com/Zero-Biography-Dangerous-Charles-Seife/dp/0140296476>`0`</a>, the concept of <code>None</code> will turn out to be quite useful!\n\nThe next function below still does not take any arguments and it still doesn‚Äôt do anything. It does, however, include a return statement. As the note above indicates, the return statement isn‚Äôt necessary in Python functions; they will just automatically return None if you don‚Äôt specify otherwise. However, using the return statement is required if you ever want to work with any output from your functions.\ndef my_function():\n    return True\nNext, we can take a look at an example of a function that takes an argument (a) and returns a value (also a)‚Ä¶ but it still doesn‚Äôt actually do anything!\ndef my_function(a):\n    return a\nHopefully your functions will be more useful than the ones above that do nothing. However, we‚Äôve introduced these three ‚Äúdo-nothing functions‚Äù in order to highlight three important aspects of all functions. The ability to (1) pass an argument into a function, (2) transform data within - or based on - the value of a function argument, and (3) return some new data or result based on those manipulations. These three factors combine to make functions extremely useful. Finally the code below provides an example of a function that has all three components and does something that should be quite familiar to you at this point.\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\n# Define a simple function\ndef convert_F_to_C(temp_F):\n    temp_C = (temp_F-32)*5./9.\n    return temp_C\n\n\nThe function above takes a Temperature in Fahrenheit and converts it to Celsius. It then returns this new value.\n\n‚úèÔ∏è <b> Try it. </b> \nCall the <code>convert_F_to_C()</code> function with the value 98.6 (¬∞F). It should return 37.0.\n\n\n\nCode\n# Convert 98.6¬∞F to ¬∞C\nconvert_F_to_C(98.6)\n\n\n37.0\n\n\n\n\nFunction Arguments & Parameters\nWhen we define a function, we specify the parameters the function requires. The definition of convert_F_to_C contains a single parameter, temp_F. When we call a function, we supply arguments to the function which are then mapped to the function parameters. Providing the argument 98.6 to the function maps this number to the temp_F parameter. So wherever temp_F appears in the function, 98.6 is used instead. What happens if we call a function without supplying arguments for the parameters?\n\nconvert_F_to_C() # Uh-oh... we didn't provide an argument for the temp_F parameter.\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n<ipython-input-3-60e83d2545ed> in <module>\n----> 1 convert_F_to_C()\n\nTypeError: convert_F_to_C() missing 1 required positional argument: 'temp_F'\nIn the error above, we see that not providing a required argument raises a TypeError, and provides some additional detail regarding what went wrong. In this case, we are told that we are mssing one required positional argument, which needs to be assigned to the temp_F parameter.\n\nSpecifying default parameters\nWhen defining a function, it is possible to set a default value for any parameter. This is done by assigning the parameter the default value right inside the parameter list:\ndef convert_F_to_C(temp_F=0):\n    temp_C = (temp_F-32)*5./9.\n    return temp_C\n\nüêç <b>Note.</b> Functions are no different than variables (or any other object in Python). Therefore, any function you create in a notebook can be re-defined by simply editing the function and re-running the cell! \n\n\n‚úèÔ∏è <b> Try it. </b> \nRe-define the <code>convert_F_to_C()</code> function so that the default value of <code>temp_F</code> is 0. Test what happens if you call this re-defined function without an argument. \n\n\n\nCode\n# Redefine convert_F_to_C() with default temp_F=0\ndef convert_F_to_C(temp_F=0):\n    temp_C = (temp_F-32)*5./9.\n    return temp_C\n\n# Call function\nconvert_F_to_C()\n\n\n-17.77777777777778\n\n\n\n\nRequired arguments\nArguments that are included in the parameter list and do not have default values are called required arguments. In the convert_temp_to_C function below, both temp and unit are required parameters.\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\ndef convert_temp_to_C(temp, unit):\n    \"\"\" Converts a temperature to Celsius\n    \n    Parameters\n    ----------\n        temp : float\n            Temperature value to convert\n        unit : str\n            temp units ('K' or 'F')\n       \n    Returns\n    -------\n        temp_C : float\n            The value of temp converted to Celsius\n    \"\"\"\n    if unit == 'K':\n        temp_C = temp - 273.15\n    elif unit == 'F':\n        temp_C = (temp-32)*5./9.\n    return temp_C\n\n\nYou can also see that we have added some comments to the function right below the definition. These commments are known as Docstrings, and they are critical to allow users to understand what your program is doing. The use of \"\"\" to begin and end the docstrings signifies we are writing a multi-line comment (as opposed to # which specifys a single line comment in Python). The first line of a function‚Äôs docstrings should always be a short description of what the function does. The rest of the docstrings should specify the required arguments that the function needs and what values it returns, if any.\n\nüêç <b>The ABC of Python:</b> Always. Be. Commenting.\n\n\nüêç <b>Note.</b> You can see the function definition and <b>docstrings</b> for any function (if they exist) by using the builtin <code>help()</code> function.\n\n\n‚úèÔ∏è <b> Try it. </b> \nUse the <code>help()</code> function to see the function definition and docstrings for the <code>convert_temp_to_C</code> function.\n\n\n\nCode\nhelp(convert_temp_to_C)\n\n\nHelp on function convert_temp_to_C in module __main__:\n\nconvert_temp_to_C(temp, unit)\n    Converts a temperature to Celsius\n    \n    Parameters\n    ----------\n        temp : float\n            Temperature value to convert\n        unit : str\n            temp units ('K' or 'F')\n       \n    Returns\n    -------\n        temp_C : float\n            The value of temp converted to Celsius\n\n\n\n\nüìö  <b> Practice 1. </b> \nCreate a new function, <code>convert_temp_to_K</code> that converts a temperature to Kelvin from either Fahrenheit or Celsius, depending on user-supplied arguments. \n\n\n\nCode\n# Define a new function\ndef convert_temp_to_K(temp, unit):\n    \"\"\" Converts a temperature to Celsius\n    \n    Parameters\n    ----------\n        temp : float\n            Temperature value to convert\n        unit : str\n            temp units ('C' or 'F')\n       \n    Returns\n    -------\n        temp_K : float\n            The value of temp converted to Celsius\n    \"\"\"\n    if unit == 'C':\n        temp_K = temp + 273.15\n    elif unit == 'F':\n        temp_K = ((temp-32)*5./9.) + 273.15\n    return temp_K\n\n\n\n\nKeyword arguments\nIn both convert_temp_to_C and convert_temp_to_K, the order of parameters is very important. If we tried calling the convert_temp_to_C function like this: convert_temp_to_C('F', 212.0) we would get an error! The reason we get an error is because the function definition assumes that the first argument should be mapped to the first parameter temp and the second argument should be mapped to the second parameter unit. That‚Äôs why the TypeError refered to temp_Fas a required positional argument in the section above. This assumption that arguments be mapped to parameters in a specific order can make working with complicated functions that have many parameters almost impossible. For this reason, Python provides the ability to pass keyword arguments to functions.\nRather than making assumptions about how arguments map to parameters based on their order, keyword arguments specify exactly how arguments are mapped to parameters within a function. This is done by assigning an argument to a specific parameter within the function call.\nFor example, instead of writing convert_temp_to_C('F', 212.0), we can instead call the same function using convert_temp_to_C(unit='F', temp=212.0).\n\nüêç <b>Note.</b> Python doesn't require you to change anything about a function's definition to take advantage of keyword arguments. For this reason, it's good practice to use keyword arguments whenever possible.\n\n\n‚úèÔ∏è <b> Try it. </b> \nCall the <code>convert_temp_to_K</code> function that you created using keyword arguments.\n\n\n\nCode\nconvert_temp_to_K(unit='F',temp=98.6)\n\n\n310.15\n\n\nAn important consideration when using keyword arguments is that they must all follow any positional arguments that are passed to a function. In other words, if you are calling a function with a mix of positional arguments and keyword arguments, the positional arguments need to all be listed first. So, using our simple temperature conversion function as an example, convert_temp_to_C(212.0, unit='F') is valid, but convert_temp_to_C(temp=212.0, 'F') is not.\n\n\nAnonymous functions\nSometimes we may just want to create a very simple function without having to go through all the trouble of using def to define the function, writing docstrings and adding a return statement. For these ‚Äúone-liners‚Äù Python has the concept of anonymous functions. Instead of using def, these functions are declared using lambda notation, so they are often refered to as lambda functions. Because they are meant to be simple, a lambda function declaration is always contained in a single line:\nQ = lambda T: 5.67e-8 * T**4\nThe function above calculates the Energy Flux, Q [W/m^2], for a blackbody object at a specified temperature, T [Kelvin], assuming an emissivity of 1:\nQ = 5.67x10^{-8} \\times T^4\nWe can use this lambda function just like any other function:\nQ(50+273.15)\n>>> 618.3006455416394\n\nüìö  <b> Practice 2. </b> \nCreate a <code>lambda</code> function in the cell below that converts a Celsius temperature to Kelvin.</div>\n\n\n\nCode\n# Create function to convert C to K\ntemp_K = lambda temp_C: temp_C + 273.15\n# Test function\ntemp_K(40)\n\n\n313.15\n\n\n\n\n\nDocumenting Functions\nAs we saw above, the use of docstrings can greatly improve your ability to understand what a program requires in terms of arguments and what the function returns. There is no standard for docstrings, but there are some best practices. A good docstring should contain:\n\nA brief description of what the function does.\nA more detailed explanation of how the functions works, if necessary.\nInformation on any arguments - both required and optional - that may be passed into the function.\nInformation on any parameter default values.\nInformation on any exceptions that the function raises.\nAny information about side effects the function may cause, or restrictions on when the function can be used.\n\nThe last couple of items on the list above aren‚Äôt very common, but the first four are essential components of all function docstrings. While it is fine to develop your own docstring style, here‚Äôs another example of what a docstring should look like:\ndef Q(T, epsilon=1, unit='C'):\n    \"\"\" Calculates energy emitted by an object with temperature T\n\n    Uses the Stefan-Bolzmann Law to calculate total radiative \n    emmittance in W/m^2 based on temperature and emissivity:\n    \n    Q = epsilon * sigma * T**4\n    \n    where sigma is the Stefan-Boltzmann constant (5.67e-8 W/m^2/K^4),\n    epsilon is the emissitivity (0-1), and T is temperature in Kelvin.\n\n    Parameters\n    ----------\n        T: float\n            Temperature of object\n        epsilon: float, optional\n            emissivity of object [0-1] (default is 1)\n        unit: str, optional\n            units of T, either 'F', 'C', or 'K' (default is 'C')\n    \n    Returns\n    -------\n        Q: float\n            Energy emitted by object [W/m^2]\n    \"\"\"\n\n    # Set Stefan-Boltzmann constant:\n    SIGMA = 5.67e-8 # W/m2/K^4                    \n                \n    # If T is in Fahrenheit, convert to C:\n    if unit == 'F':\n        T = (T - 32) * (5./9.)\n        unit = 'C' # Re-assign unit to C\n        \n    # If T is in Celsius, convert to Kelvin\n    if unit == 'C':\n        T = T + 273.15\n    \n    # Calculate Q and return the value\n    Q = epsilon * SIGMA * T**4\n    return Q\n\nüìö  <b> Practice 3. </b> \nWrite a complete set of docstrings for your function a <code>convert_temp_to_K</code>. Check to make sure they work using the <code>help()</code> function.</div>\n\n\n\nCode\n# Define function with docstrings\ndef convert_temp_to_K(temp, unit):\n    \"\"\" Converts a temperature to Celsius\n    \n    Parameters\n    ----------\n        temp : float\n            Temperature value to convert\n        unit : str\n            temp units ('C' or 'F')\n       \n    Returns\n    -------\n        temp_K : float\n            The value of temp converted to Celsius\n    \"\"\"\n    # If unit is in Celsius, conveert to K\n    if unit == 'C':\n        temp_K = temp + 273.15\n    # If unit is in Fahrenheit, convert to K\n    elif unit == 'F':\n        temp_K = ((temp-32)*5./9.) + 273.15\n    # Return temp in Kelvin\n    return temp_K\n\n# Check out docstring\nhelp(convert_temp_to_K)\n\n\nHelp on function convert_temp_to_K in module __main__:\n\nconvert_temp_to_K(temp, unit)\n    Converts a temperature to Celsius\n    \n    Parameters\n    ----------\n        temp : float\n            Temperature value to convert\n        unit : str\n            temp units ('C' or 'F')\n       \n    Returns\n    -------\n        temp_K : float\n            The value of temp converted to Celsius"
  },
  {
    "objectID": "answerkeys/Exercise1-5_Key.html#classes",
    "href": "answerkeys/Exercise1-5_Key.html#classes",
    "title": "",
    "section": "Classes",
    "text": "Classes\nClasses are Python objects that contain both attributes (i.e.¬†data) and methods (i.e.¬†functions). Classes are the essence of any object-oriented programming (OOP) language. A Class is created using the class keyword:\n\nclass Temperature:\n    value = 74.0\n    unit = 'F'\n    \nThe above code defines a new class called Temperature. It then assigns two attributes to the class, value and unit. This simple class has no methods. We will get to those next!\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\nclass Temperature:\n    value = 74.0\n    unit = 'F'\n\n\n\nCreating an Instance of a Class\nWe create an instance of the class by calling it (like we call a function) and assigning the output of the call to a new variable:\nmy_temp = Temperature()\n\n\nAccessing Class Data\nClass objects are mutable, so it‚Äôs possible to change the data in a class. We can access ‚Äì and alter ‚Äì the attributes of a class using . notation:\nprint(my_temp.value) # Use . notation to access attributes of a class.\n>>> 74.0\n\nmy_temp.value = 83.2  # Assign a new value to this instance of Temperature.\nprint(my_temp.value)  # Check to see if the value has been changed...\n>>> 83.2\n\nüìö  <b> Practice 4. </b> \nCreate an instance of the <code>Temperature</code> class and print out the string: <code>\"The temperature is 74 ¬∞F\"</code>.\n\n\n\nCode\n# Create instance of Temperature\nmy_temp = Temperature()\n\n# Print temperature as formatted print statement.\nprint('The temperature is %d ¬∞%s.' % (int(my_temp.value),my_temp.unit))\n\n\nThe temperature is 74 ¬∞F.\n\n\n\n\nClass Initialization\nIn the example above, we saw how to create an instance of a Temperature. But you probably noticed that every instance of our class will have the same temperature and unit: 74.0 degress F. While it‚Äôs possible to change these values later (in python parlance, we‚Äôd say ‚Äúafter the object is instanced‚Äù), it‚Äôd be better if we could initialize our class instances with the values we want. To do this, we will create our first class method, the __init__ method.\n\n\n__init__() method\nThe __init__() method is a special function that we create for classes that tells python how to create a new instance of the class. This function is included as part of a class‚Äôs definition, and usually should be the very first method that appears in the class.\n\nüêç <b>Note.</b> Python uses the \"double underscore + name + double underscore\" syntax (<code>__</code> + <code>init</code> + <code>__</code>) to define a suite of \"magic\" functions. The exact way to pronounce these strange functions isn't settled, but most people use \"dunder\" to refer to the double underscore, so <code>__init__()</code> is referred to as the \"dunder init dunder\" function, or \"dunder init\" for short.\n\nThe __init__() function is the initializer method for a Class. It gets passed whatever arguments are provided when a class is created. For example, if we called T = Temperature(10, 'F'), the __init__() method would automatically be passed these two arguments.\nWe define the __init__ method just like any other function, with one difference: It always includes self as its first argument:\n\nclass Temperature:\n    \n    def __init__(self, value=74.0, unit='F'):\n        self.value = value\n        self.unit = unit\n\n\nWhy self?\nIt‚Äôs not at all obvious why we need to add an extra parameter (which, by convention is always called self ) to the initializer method. Even weirder is the fact that we need to add this extra parameter, self to every class method! To beginning Pythonistas, the concept of self is deeply strange. However, there is a fairly straight-foward reason for its existence.\nPython functions ‚Äì like functions in most programming languages ‚Äì can only manipulate data that exist within the function itself. Speaking generally, Python functions aren‚Äôt supposed to manipulate data that they haven‚Äôt been passed via argument. The consequences of this ‚Äúseparation of namespaces‚Äù is that ‚Äì paradoxically ‚Äì a class method can‚Äôt operate on class data unless the class data itself is passed into the method!\nBy convention, we use the self parameter to allow us to work with the properties of a class within our class methods. If we didn‚Äôt include this extra parameter, the functions that we write inside of a class wouldn‚Äôt even be able to access the attributes of the class that they were inside of!\nEssentially, you can think of self as a placeholder for a class instance. In fact, Python automatically passes a class instance into any class function whenever that class function is called. The class instance argument is inserted by Python before any other arguments. Therefore, we include the self parameter at the beginning of every class method (remember methods and functions are the same thing), knowing that Python will pass a class instance into our function first, and all of the attributes of that instance will get assigned to the self parameter.\nThere are many, many other explanations out there about the need for the self parameter in class methods. Because the use of self in Python is such a confusing concept, there have also been formal proposals to get rid of self and warnings about its misuse in popular culture. There is even a blog post about the necessity self from the creator of self‚Ä¶ himself.\n\nüêç <b>Bottom Line.</b> Whenever you write a class function, you will need to include <code>self</code> as the first positional parameter in the function definition. In addition, whenever you want to access class attributes within a class method, you will need to use <code>self</code> as the object that contains the data.\n\n\nUsing the __init__() function\nWe almost never call the __init__() function directly. Instead, the Class constructor function calls it for us. We already saw that a class instance is created using the constructor function like my_temp = Temperature(). With our new __init__() function defined for the Temperature class, we can now create Temperature instances with any data we want:\nT = Temperature(83.2, 'F')\nprint(T.value)\n>>> 83.2\n\n‚úèÔ∏è <b> Try it. </b>  \nCopy the example code above to create an new <code>Temperature</code> class that contains an <code>__init__</code> method that sets the value and units. Create a few new <code>Temperature</code> instances with different values and units.\n\n\n\nCode\n# Create Temperature class with __init__ method\nclass Temperature:\n\n    def __init__(self, value=74.0, unit='F'):\n        self.value = value\n        self.unit = unit\n\n# Temperature instances\ntemp1 = Temperature(40.3, 'C')\ntemp2 = Temperature(-14.8, 'F')\n\n\n\n\n\nUser Defined Class Methods\nWe often want to create our own methods that allow us to manipulate and work with class data. For example, now that we have a Temperature class, we might want to create a method that allows us to get the value of temperature in any unit. We can add this functionality by defining a class method. The class method is just the same as every other Python function, except, like __init__(), it has self as its first argument:\n\nclass Temperature:\n    \n    def __init__(self, value=74.0, unit='F'):\n        self.value = value\n        self.unit = unit\n        self.temp_K = self.get_K()\n\n    def get_K(self):\n        \n        unit = self.unit\n        T = self.value\n\n        # If T is in Fahrenheit, convert to C:\n        if unit == 'F':\n            T = (T - 32) * (5./9.)\n            unit = 'C' # Re-assign unit to C\n        \n        # If T is in Celsius, convert to Kelvin\n        if unit == 'C':\n            T = T + 273.15\n\n        return T\n    \nIn this example, we‚Äôve added a class function called get_K that always returns the Temperature object‚Äôs value in degrees Kelvin. You will notice that we can even use this function inside the __init__() function. This means that after creating an instance of an object, we will end up with the temp_K property of the object set for us automatically.\nWe can also run any class methods by calling it directly. Just as we used . notation to access class data, we use . notation to access class methods:\n\nmy_temp = Temperature(50,'C')\nmy_temp.get_K()\n>>> 323.15\n\n‚úèÔ∏è <b> Try it. </b>  \nCopy the example code above to create an new <code>Temperature</code> class that contains the <code>get_K</code> method, which is used to set the value of <code>temp_K</code> during intialization. Create a few new <code>Temperature</code> instances with different values and units and test to make sure <code>temp_K</code> is being set correctly. \n\n\n\nCode\n# Create Temperature class with get_K method\nclass Temperature:\n\n    def __init__(self, value=74.0, unit='F'):\n        self.value = value\n        self.unit = unit\n        self.temp_K = self.get_K()\n\n    def get_K(self):\n\n        unit = self.unit\n        T = self.value\n\n        # If T is in Fahrenheit, convert to C:\n        if unit == 'F':\n            T = (T - 32) * (5./9.)\n            unit = 'C' # Re-assign unit to C\n\n        # If T is in Celsius, convert to Kelvin\n        if unit == 'C':\n            T = T + 273.15\n\n        return T\n    \n    \n# A few instances\ntemp1 = Temperature(40.3, 'C')\ntemp2 = Temperature(-14.8, 'F')\n\nprint('The temperature is %.1f¬∞%s or %.2f K.' % (temp1.value,temp1.unit,temp1.get_K()))\nprint('The temperature is %.1f¬∞%s or %.2f K.' % (temp2.value,temp2.unit,temp2.get_K()))\n\n\nThe temperature is 40.3¬∞C or 313.45 K.\nThe temperature is -14.8¬∞F or 247.15 K.\n\n\n\nüìö  <b> Practice 4. </b> \nUse the cell below to create a new <code>Temperature</code> class that contains a user-defined class function of your own design. This function can do anything you want. It doesn't need to be fancy or even useful, just make sure you test your function by creating an instance of <code>Temperature</code> class and running the function.\n\n\n\nCode\n# Create Temperature class with get_K method\nclass Temperature:\n\n    def __init__(self, value=74.0, unit='F'):\n        self.value = value\n        self.unit = unit\n        self.temp_K = self.get_K()\n\n    def get_K(self):\n\n        unit = self.unit\n        T = self.value\n\n        # If T is in Fahrenheit, convert to C:\n        if unit == 'F':\n            T = (T - 32) * (5./9.)\n            unit = 'C' # Re-assign unit to C\n\n        # If T is in Celsius, convert to Kelvin\n        if unit == 'C':\n            T = T + 273.15\n\n        return T\n\n    def get_C(self):\n\n        unit = self.unit\n        T = self.value\n\n        # If T is in Fahrenheit, convert to C:\n        if unit == 'F':\n            T = (T - 32) * (5./9.)\n        # If T is in Celsius, do nothing\n        if unit == 'C':\n            T = T\n\n        return T\n\n    def get_F(self):\n\n        unit = self.unit\n        T = self.value\n\n        # If T is in Celsius, convert to F:\n        if unit == 'C':\n            T = (T * (9./5.)) + 32\n\n        # If T is in Fahrenheit, do nothing\n        if unit == 'F':\n            T = T\n\n        return T\n    \n    \n    \n# A few instances\ntemp1 = Temperature(40.3, 'C')\ntemp2 = Temperature(-14.8, 'F')\n\n# Print temperature in all units\nprint('The temperature is %.2f¬∞%s (%.2f¬∞F or %.2f K).' % (temp1.value,temp1.unit,temp1.get_F(),temp1.get_K()))\nprint('The temperature is %.2f¬∞%s (%.2f¬∞C or %.2f K).' % (temp2.value,temp2.unit,temp2.get_C(),temp2.get_K()))\n\n\nThe temperature is 40.30¬∞C (104.54¬∞F or 313.45 K).\nThe temperature is -14.80¬∞F (-26.00¬∞C or 247.15 K).\n\n\n\n\nTwo additional - and very useful - Class ‚ÄúMagic‚Äù Methods\nIn addition to the __init__() function, there are some other useful ‚Äúmagic‚Äù class methods. The first, __repr__ is a function that allows you to define how a Class object represents itself. For example, check out this example for a string (str) variable:\n\nSIGMA = 5.67e-8 # Create a variable that contains the Stefan-Boltzmann constant\nSIGMA               # What happens if you just execute a line that contains the variable? \n>>> 5.67e-08\nYou see that when the variable SIGMA is invoked, the Python interpreter returns 5.67e-08, which is not exactly what you wrote when you assigned SIGMA. That‚Äôs because what is happening ‚Äúbehind the scenes‚Äù is that Python is calling the __repr__() function for the object SIGMA:\nSIGMA.__repr__()\n>>> 5.67e-08\nThere is a similar magic function, __str__() that is called whenever print() is invoked on an object:\nprint(SIGMA)\n>>> 5.67e-08\n\nSIGMA.__str__()\n>>> 5.67e-08\nIn the case of float variables (type(SIGMA) is float), __repr__() and __str__() return the same thing. But they don‚Äôt have to. Look at this example, using a datetime object, which is part of the standard Python library and the primary object for dealing with time/date information in Python:\nfrom datetime import datetime\n\ncurrent_time = datetime.now()\n\ncurrent_time\n>>> datetime.datetime(2020, 4, 17, 12, 50, 52, 778357) # Your time will be different!\n\nprint(current_time)\n>>> 2020-04-17 12:51:38.750213\nWe see that the representation of a datetime object (created by the class‚Äôs __repr__() function) is different than the class‚Äôs __str__() function.\nYou can create these functions inside a class in the same way you created the __init__() function:\nclass Temperature:\n    \n    def __init__(self, value=74.0, unit='F'):\n        self.value = value\n        self.unit = unit\n\n    def __repr__(self):\n        return \"Temperature({value},¬∞{unit})\".format(value=self.value,unit=self.unit)\n\n    def __str__(self):\n        return \"The temperature is {value} ¬∞{unit}\".format(value=self.value, unit=self.unit)\n\n‚úèÔ∏è <b> Try it. </b>  \nUse the example above to define a new <code>Temperature</code> class that adds <code>__repr__</code> and <code>__str__</code> methods. Test out the <code>__str__()</code> method by creating an instance and using the <code>print()</code> command. \n\n\n\nCode\n# Define new Temperature class with __repr__ and __str__ methods\nclass Temperature:\n\n    def __init__(self, value=74.0, unit='F'):\n        self.value = value\n        self.unit = unit\n\n    def __repr__(self):\n        return \"Temperature({value},¬∞{unit})\".format(value=self.value,unit=self.unit)\n\n    def __str__(self):\n        return \"The temperature is {value} ¬∞{unit}\".format(value=self.value, unit=self.unit)\n\n# Create an instance\ntemp1 = Temperature(40.3, 'C')\n    \n# Test __sstr__() method\nprint(temp1)\n\n\nThe temperature is 40.3 ¬∞C\n\n\n\n\nDocumenting Classes\nJust like functions, classes should contain docstrings. The format and content of docstrings is similar to a function, but there is a need for even more description. This is because the docstrings should include information about all of the attributes of the class as well as any class methods that are defined. So for a simple Weather class we might have something like this:\nclass Weather:\n    \"\"\"\n    A class used to represent the weather\n\n    Attributes\n    ----------\n    \n    temperature : float\n        air temperature, in deg-C\n        \n    relative_humidity : float\n        relative humidity, in %\n    \n    pressure : float\n        air pressure, in kPa\n    \n    Methods\n    -------\n    \n    sat_vap_pressure()\n        returns the saturation vapor pressure for the current weather condition\n        \n    \"\"\"\n    \n    def __init__(self, temp, RH, P):\n        \"\"\" \n        Parameters\n        ----------\n        temp : float\n            air temperature, in ¬∞C\n        \n        RH : float\n            relative humidity, in %\n        \n        P : float\n            pressure, in kPa\n        \"\"\"\n        \n        self.temperature = temp\n        self.relative_humidity = RH\n        self.pressure = P \n        \n    def sat_vap_pressure(self):\n        \"\"\" Determines Saturation Vapor Pressure\n        \n        Uses the Tetens equation to estimate saturation vapor pressure (svp) given air Temp.\n        \n        P = 0.61078 * exp((17.27 * T)/(T + 237.3))\n        \n        where P is svp in kPa and T is air temperature in ¬∞C.\n        \n        \n        Returns:\n        --------\n        \n        P, saturation vapor pressure, in kPa\n        \n        \"\"\"\n        from math import exp\n        \n        P = 0.61078 * exp(17.27*self.C)/(self.T + 237.3)\n        \n        return P\n\nüêç <b>ABC!</b> Notice how there are more docstrings in this definition than there is code! This is because the concept of abstraction ‚Äì creating classes and functions that represent general concepts and methods ‚Äì requires a high degree of documentation in order for the abstractions to be used correctly. The same code written in a notebook cell (without abstraction) would be easier to read and require much less documentation.\n\n\nüìö  <b> Practice 5. </b> \nUse the cell below to create a final version of your <code>Temperature</code> class that includes docstrings. Check to see if your docstrings are working using the <code>help()</code> function.\n\n\n\nCode\n# Create Temperature class with get_K method\nclass Temperature:\n    \"\"\"\n    A class used to represent the temperature\n\n    Attributes\n    ----------\n\n    temperature : float\n        temperature, in ¬∞F or ¬∞C\n\n    unit : str\n        units of temperature\n\n    Methods\n    -------\n\n    get_K()\n        returns temperature in K\n        \n    get_C()\n        returns temperature in ¬∞C\n    \n    get_F()\n        returns temperature in ¬∞F\n\n    \"\"\"\n    def __init__(self, value=74.0, unit='F'):\n        '''\n        PARAMETERS:\n        ----------\n        value : int or float\n            temperature (default is 74.0)\n        \n        unit : str\n            units of temperature (default is F)\n        '''\n        self.value = value\n        self.unit = unit\n        self.temp_K = self.get_K()\n\n    def get_K(self):\n        \"\"\" Converts temperature to K\n\n        Converts temperature to K using the equation\n        \n            T_K = T_C + 273.15\n        \n        where T_K is the temperature in K and T_C is the temperature in ¬∞C. If necessary, the temperature is\n        first converted from ¬∞F to ¬∞C according to the equation\n        \n            T_C = (T_F - 32) * (5./9.)\n\n        where T_F is the temperature in ¬∞F.\n\n        Returns:\n        --------\n\n        T : temperature in K\n\n        \"\"\"\n        unit = self.unit\n        T = self.value\n\n        # If T is in Fahrenheit, convert to C:\n        if unit == 'F':\n            T = (T - 32) * (5./9.)\n            unit = 'C' # Re-assign unit to C\n\n        # If T is in Celsius, convert to Kelvin\n        if unit == 'C':\n            T = T + 273.15\n\n        return T\n\n    def get_C(self):\n        \"\"\" Converts temperature to C\n\n        Converts temperature to C using the equation\n        \n            T_C = (T_F - 32) * (5./9.)\n        \n        where T_F is the temperature in Fahrenheit and T_C is the temperature in ¬∞C. \n\n        Returns:\n        --------\n\n        T : temperature in C\n\n        \"\"\"\n        unit = self.unit\n        T = self.value\n\n        # If T is in Fahrenheit, convert to C:\n        if unit == 'F':\n            T = (T - 32) * (5./9.)\n        # If T is in Celsius, do nothing\n        if unit == 'C':\n            T = T\n\n        return T\n\n    def get_F(self):\n        \"\"\" Converts temperature to F\n\n        Converts temperature to F using the equation\n        \n            T_F = (T_C * (9./5.)) + 32\n        \n        where T_F is the temperature in Fahrenheit and T_C is the temperature in ¬∞C. \n\n        Returns:\n        --------\n\n        T : temperature in F\n\n        \"\"\"\n        unit = self.unit\n        T = self.value\n\n        # If T is in Celsius, convert to F:\n        if unit == 'C':\n            T = (T * (9./5.)) + 32\n\n        # If T is in Fahrenheit, do nothing\n        if unit == 'F':\n            T = T\n\n        return T\n    \n    \n    \n# A few instances\ntemp1 = Temperature(40.3, 'C')\ntemp2 = Temperature(-14.8, 'F')\n\n\nhelp(temp1)\n\n\nHelp on Temperature in module __main__ object:\n\nclass Temperature(builtins.object)\n |  Temperature(value=74.0, unit='F')\n |  \n |  A class used to represent the temperature\n |  \n |  Attributes\n |  ----------\n |  \n |  temperature : float\n |      temperature, in ¬∞F or ¬∞C\n |  \n |  unit : str\n |      units of temperature\n |  \n |  Methods\n |  -------\n |  \n |  get_K()\n |      returns temperature in K\n |      \n |  get_C()\n |      returns temperature in ¬∞C\n |  \n |  get_F()\n |      returns temperature in ¬∞F\n |  \n |  Methods defined here:\n |  \n |  __init__(self, value=74.0, unit='F')\n |      PARAMETERS:\n |      ----------\n |      value : int or float\n |          temperature (default is 74.0)\n |      \n |      unit : str\n |          units of temperature (default is F)\n |  \n |  get_C(self)\n |      Converts temperature to C\n |      \n |      Converts temperature to C using the equation\n |      \n |          T_C = (T_F - 32) * (5./9.)\n |      \n |      where T_F is the temperature in Fahrenheit and T_C is the temperature in ¬∞C. \n |      \n |      Returns:\n |      --------\n |      \n |      T : temperature in C\n |  \n |  get_F(self)\n |      Converts temperature to F\n |      \n |      Converts temperature to F using the equation\n |      \n |          T_F = (T_C * (9./5.)) + 32\n |      \n |      where T_F is the temperature in Fahrenheit and T_C is the temperature in ¬∞C. \n |      \n |      Returns:\n |      --------\n |      \n |      T : temperature in F\n |  \n |  get_K(self)\n |      Converts temperature to K\n |      \n |      Converts temperature to K using the equation\n |      \n |          T_K = T_C + 273.15\n |      \n |      where T_K is the temperature in K and T_C is the temperature in ¬∞C. If necessary, the temperature is\n |      first converted from ¬∞F to ¬∞C according to the equation\n |      \n |          T_C = (T_F - 32) * (5./9.)\n |      \n |      where T_F is the temperature in ¬∞F.\n |      \n |      Returns:\n |      --------\n |      \n |      T : temperature in K\n |  \n |  ----------------------------------------------------------------------\n |  Data descriptors defined here:\n |  \n |  __dict__\n |      dictionary for instance variables (if defined)\n |  \n |  __weakref__\n |      list of weak references to the object (if defined)"
  },
  {
    "objectID": "answerkeys/Exercise1-5_Key.html#loading-functions-and-classes",
    "href": "answerkeys/Exercise1-5_Key.html#loading-functions-and-classes",
    "title": "",
    "section": "Loading functions and classes",
    "text": "Loading functions and classes\nIn the last practice cell, you probably noticed that your class definition is getting pretty large. While it‚Äôs nice to be able to edit this code easily in your notebook, once you have settled on a function or class definition, it is often helpful to move the definitions out of your notebook and just load them when you need them. Python uses the import function to load objects from external libraries and files.\n\nMoving your class definition to a new file\n\nüìö  <b> Practice 6. </b> \nFollow the directions below to save your final <code>Temperature</code> class definition into a new file called <code>temperature.py</code>\n\n\nGo to the JupyterLab File menu and click New -> Text File\n\n\n\nCopy the entire Temperature class definition you created during Practice 5 and paste it into the text file.\nRename the text file temperature.py. You can do this easily by right-clicking on the filename in the file‚Äôs tab (see the image below)\n\n\n\nüêç <b>Note:</b>Make sure you save your file with the <code>.py</code> extension and not <code>.txt</code>. You will know if you saved it correctly if the file appears with python code formating as in the image below:\n\n\n\nSave the new file. This will create a file called temperature.py in your current directory.\n\n\n\nImporting your class from the temperature.py file.\nAssuming you were able to save your file correctly, and that your Temperature class definition doesn‚Äôt have any errors in it, you can import the Temperature class into your notebook like this:\n\nfrom temperature import Temperature\n\nT = Temperature(98.6, unit='F')\n\n‚úèÔ∏è <b> Try it. </b>  \nLoad your <code>Temperature</code> class from the <code>temperature.py</code> file using the <code>import</code> command. Make some new Temperature instances to ensure that your class loaded correctly and works okay.\n\n\n\nCode\n# Import Temperature class\nfrom temperature import Temperature\n\n# A few instances\ntemp1 = Temperature(32.3, 'C')\ntemp2 = Temperature(104.8, 'F')\n\n# Print temperature in all units\nprint('The temperature is %.2f¬∞%s (%.2f¬∞F or %.2f K).' % (temp1.value,temp1.unit,temp1.get_F(),temp1.get_K()))\nprint('The temperature is %.2f¬∞%s (%.2f¬∞C or %.2f K).' % (temp2.value,temp2.unit,temp2.get_C(),temp2.get_K()))\n\n\nThe temperature is 32.30¬∞C (90.14¬∞F or 305.45 K).\nThe temperature is 104.80¬∞F (40.44¬∞C or 313.59 K)."
  },
  {
    "objectID": "answerkeys/Exercise1-3_Key.html#loops",
    "href": "answerkeys/Exercise1-3_Key.html#loops",
    "title": "",
    "section": "Loops",
    "text": "Loops\n\n\n\nfor loops\nfor loops are the most commonly used type of loop and are extremely useful. for loops are used to iterate or loop through any object capable of returning its members one at time, i.e.¬†an iterable object.\n\nüêç <b>Note.</b>  The <b>iterator</b> in a <code>for</code> loop is a temporary variable used to store each value in the iterable object. The iterator is defined in the <code>for</code> loop syntax as follows:\nfor <ITERATOR> in <ITERABLE>:\n    do something to iterator\nThe name of the iterator should reflect the nature of the list. i is commonly used as an enumerator or counter variable and should be avoided for other uses.\n\nA generic counter for loop can be generated using the range() function.\nfor i in range(4):\n    print(i + 1)\n    \n>>> 1\n    2\n    3\n    4\nfor loops are commonly used to iterate through lists. As with the generic range() for loop, the iterator is assigned the next value from the list at the end of the indented code block.\nfor aa in aminoacids:\n    print(aa)\n    \n>>> histidine\n    isoleucine\n    leucine\n    lysine\n    methionine\n    phenylalanine\n    threonine\n    tryptophan\n    valine\n    alanine\n    arginine\n    asparagine\n    aspartate\n    cysteine\n    glutamate\n    glutamine\n    glycine\n    proline\n    serine\n    tyrosine\n\nüìö  <b> Practice 3. </b> \nGenerate a list called <code>org_elements</code> containing the names of the six most abundant elements comprising organic molecules. Sort the list in alphabetical order (in place) and write a <code>for</code> loop that prints each element in <code>org_elements</code>.\n\n\n\nCode\n# Define org_elements\norg_elements = ['carbon', 'oxygen', 'hydrogen','phosphorous', 'sulfur','nitrogen']\n\norg_elements.sort()\n\n# Print each element in org_elements\nfor element in org_elements:\n    print(element)\n\n\ncarbon\nhydrogen\nnitrogen\noxygen\nphosphorous\nsulfur\n\n\n\n Built-in functions \n\nThe enumerate() function can be used in a for loop to keep track of the index of the iterator. This can be useful for keeping track of the number of iterations completed, accessing other elements in the same list based on their relative index (e.g.¬†the value immediately following the current iterator value), or accessing elements in another list based on the iterator‚Äôs index.\ngases = ['N2', 'O2', 'Ar', 'H2O', 'CO2']\n\nfor i,gas in enumerate(gases):\n    rank = i + 1\n    print('The #%d most abundant gas in the atmosphere is %s.' %(rank,gas))\n\n >>>  The #1 most abundant gas in the atmosphere is N2.\n\n\nThe #2 most abundant gas in the atmosphere is O2.\n\n\nThe #3 most abundant gas in the atmosphere is Ar.\n\n\nThe #4 most abundant gas in the atmosphere is H2O.\n\n\nThe #5 most abundant gas in the atmosphere is CO2.\n\n\n‚úèÔ∏è Try it. Given your sorted org_elements list and the corresponding list of atomic masses given in the cell below, use enumerate() in a for loop to print a formatted statement that expresses the atomic mass of of each element. Your formatted print statement should include the name of the element, the atomic mass rounded to 2 decimal places, and units.\n\n\n\nCode\n# Define list of atomic masses of 6 most abundant elements\natomic_mass = [12.011, 1.00784, 14.0067, 15.999, 30.97376, 32.065]  # g/mol\n\n# Iterate through org_elements + print the atomic mass of each element\nfor i,element in enumerate(org_elements):\n    mass = atomic_mass[i]\n    print('The atomic mass of %s is %.2f g/mol.' % (element,mass))\n\n\nThe atomic mass of carbon is 12.01 g/mol.\nThe atomic mass of hydrogen is 1.01 g/mol.\nThe atomic mass of nitrogen is 14.01 g/mol.\nThe atomic mass of oxygen is 16.00 g/mol.\nThe atomic mass of phosphorous is 30.97 g/mol.\nThe atomic mass of sulfur is 32.06 g/mol.\n\n\nTo iterate through multiple lists at the same time without indexing, use the zip() function.\ngas_frac = [0.78084, 0.209476, 0.00934, 0.0025, 0.000314]\ngas_molar_mass = [14.0067, 15.999, 39.948, 18.01528, 44.01]\n\nmass_atmosphere = 5.148e21   # grams\nn_a = 6.022e23    # Avogadro's number\n\nfor frac,mol_mass in zip(gas_frac,gas_molar_mass):\n    mass = frac * mass_atmosphere\n    molecules = (mass / mol_mass ) * n_a\n    print(molecules)\n\n>>> 1.7282458205744395e+44\n    4.0590156271366957e+43\n    7.248215956743767e+41\n    4.302078013774973e+41\n    2.211859664621677e+40\nThe zip() function is nearly always used when each element of one list corresponds to an element in the same index position in another list. Therefore, it should mostly be used with two or more lists of the same length. If the lists do not have the same length, however, the number of iterations of the for loop will match the length of the shortest list.\n\n‚úèÔ∏è Try it. As in the previous example, print the atomic masses of each of the six most abundant elements in formatted print statements, this time using zip() to iterate through both org_elements and atomic_mass at the same time\n\n\n\nCode\nfor element,mass in zip(org_elements,atomic_mass):\n    print('The atomic mass of %s is %.2f g/mol.' % (element,mass))\n\n\nThe atomic mass of carbon is 12.01 g/mol.\nThe atomic mass of hydrogen is 1.01 g/mol.\nThe atomic mass of nitrogen is 14.01 g/mol.\nThe atomic mass of oxygen is 16.00 g/mol.\nThe atomic mass of phosphorous is 30.97 g/mol.\nThe atomic mass of sulfur is 32.06 g/mol.\n\n\nThe enumerate() and zip() functions can also be used together, if necessary, to keep track of the index position of iterators.\nfor i,(frac,mol_mass) in enumerate(zip(gas_frac,gas_molar_mass)):\n    gas = gases[i]\n    mass = frac * mass_atmosphere\n    molecules = (mass / mol_mass ) * n_a\n    print('There are ' + '{:.2e}'.format(molecules) + ' molecules of %s in the atmosphere.' % (gas))\n\n >>>  There are 1.73e+44 molecules of N2 in the atmosphere.\n\n\nThere are 4.06e+43 molecules of O2 in the atmosphere.\n\n\nThere are 7.25e+41 molecules of Ar in the atmosphere.\n\n\nThere are 4.30e+41 molecules of H2O in the atmosphere.\n\n\nThere are 2.21e+40 molecules of CO2 in the atmosphere.\n\n\n Nested for loops \n\nLike if statements, for loops can be nested to perform an operation multiple times for each iterator in the overall loop.\nfor aa in aminoacids:\n    vowels = 0\n    for letter in aa:\n        if letter in ['a', 'e', 'i', 'o', 'u']:\n            vowels = vowels + 1\n    print(aa.capitalize() + ' has ' + str(vowels) + ' vowels.')\n    \n>>> Histidine has 4 vowels.\n    Isoleucine has 6 vowels.\n    Leucine has 4 vowels.\n    Lysine has 2 vowels.\n    Methionine has 5 vowels.\n    Phenylalanine has 5 vowels.\n    Threonine has 4 vowels.\n    Tryptophan has 2 vowels.\n    Valine has 3 vowels.\n    Alanine has 4 vowels.\n    Arginine has 4 vowels.\n    Asparagine has 5 vowels.\n    Aspartate has 4 vowels.\n    Cysteine has 3 vowels.\n    Glutamate has 4 vowels.\n    Glutamine has 4 vowels.\n    Glycine has 2 vowels.\n    Proline has 3 vowels.\n    Serine has 3 vowels.\n    Tyrosine has 3 vowels.\n\nüìö  <b> Practice 4. </b> \nThe cell below contains four lists containing monthly global land-ocean surface temperature in ¬∞F for 2015, 2016, 2017, and 2018. Using  <code>enumerate()</code>, <code>zip()</code>, a nested <code>for</code> loop, or some combination of the three:\n\n\nCalculate the monthly global land-ocean surface temperature anomalies (deviation from the mean) in ¬∞C for 2015-2018. The mean global land-ocean surface temperature calculated over the 20th century was 15.6¬∞C.\n\n\nCreate a new list with the mean monthly global surface temperature anomalies in ¬∞C for 2015-2018 (i.e.¬†calculate the mean temperature anomaly for each month and put these values in a list). Use the command np.mean() to calculate mean values.\n\n\nPrint each monthly mean value with the name of the month and units.\n\n\n\n\n\nCode\n# Import numpy for mean calculations\nimport numpy as np\n\n# Lists of monthly global surface temperature in ¬∞F\ntempF_2015 = [61.538, 61.646, 61.7, 61.43, 61.43, 61.502, 61.358, 61.502, 61.556, 62.006, 61.934, 62.06]\ntempF_2016 = [62.15, 62.51, 62.438, 62.006, 61.718, 61.466, 61.556, 61.88, 61.664, 61.7, 61.718, 61.574]\ntempF_2017 = [61.844, 62.114, 62.114, 61.736, 61.682, 61.34, 61.556, 61.646, 61.448, 61.664, 61.628, 61.682]\ntempF_2018 = [61.466, 61.61, 61.718, 61.646, 61.538, 61.412, 61.484, 61.394, 61.448, 61.862, 61.484, 61.682]\n\n# List of yearly lists (may or may not be useful)\ntempF_list = [tempF_2015, tempF_2016, tempF_2017, tempF_2018]\n# List of years\nyears = [2015, 2016, 2017, 2018]\n\n# 4a. Monthly temperature anomalies\nprint('Practice 4a')\n# Empty list of lists\ntempC_list = []\nanomC_list = []\n# Iterate through yearly lists\nfor tempsF,year in zip(tempF_list,years):\n    # Empty list for a single year\n    tempsC = []\n    anomsC = []\n    # Iterate through a single year\n    for tempF in tempsF:\n        # Convert temp from F to C\n        tempC = (tempF - 32.0) * (5/9)\n        # Append to tempsC\n        tempsC.append(round(tempC,2))\n        # Calculate temp anomaly in ¬∞C\n        anomC = tempC - 15.6\n        # Append to anomsC\n        anomsC.append(round(anomC,2))\n    # Print list of temps and anomalies in ¬∞C to check\n    print('Monthly temperatures in ¬∞C, %d:' % (year))\n    print(tempsC)\n    print('Monthly temperature anomalies in ¬∞C, %d:' % (year))\n    print(anomsC)\n    # Add list of ¬∞C temps to tempC_list (list of lists)\n    tempC_list.append(tempsC)\n    # Add list of anomalies in ¬∞C to anomC_list (list of lists)\n    anomC_list.append(anomsC)\n    \ntempC_list[:][0]\n\n# 4b. Mean monthly temperature anomaly, 2015-2018\nprint('Practice 4b')\n# Empty list for monthly mean temperature anomalies\nmonthly_means = []\n# Set up generic counter loop with 12 iterations\nfor i in range(12):\n    # Generate list of temperature anomalies for each month by extracting the ith value from each sublist.\n    # This creates a list of 4 values: \n    #       [T_anom for month i of 2015, T_anom for month i of 2016, \n    #        T_anom for month i of 2017, T_anom for month i of 2018]\n    monthly = [anom[i] for anom in anomC_list]\n    # Calculate mean for month i\n    monthly_mean = np.mean(monthly)\n    # Add mean for month i to list of means\n    monthly_means.append(round(monthly_mean,4))\n# Print list of mean monthly temperature anomalies, 2015-2018.\nprint(monthly_means)\n\n# Alternative:\nmonthly_means = []\nfor anomC_15,anomC_16,anomC_17,anomC_18 in zip(*anomC_list):\n# Note: * is an \"unpacking\" operator that extracts each sublist of anomC_list making them iterables.\n# for i,(anomC_15,anomC_16,anomC_17,anomC_18) in enumerate(zip(anomC_list[0],\n#                                                              anomC_list[1],\n#                                                              anomC_list[2],\n#                                                              anomC_list[3])):\n    # Put month i values in a list\n    monthly = [anomC_15, anomC_16, anomC_17, anomC_18]\n    # Calculate mean for month i\n    monthly_mean = np.mean(monthly)\n    # Add mean for month i to list of means\n    monthly_means.append(round(monthly_mean,4))\n# Print list of mean monthly temperature anomalies, 2015-2018.\nprint(monthly_means)\n\n\n# 4c. Print mean temperature anomalies by month\nprint('Practice 4c')\n\nmonths = ['January', 'February', 'March', 'April', 'May', 'June', \n          'July', 'August', 'September', 'October', 'November', 'December']\n\nfor month,mean in zip(months,monthly_means):\n    print('Mean %s temperature anomaly, 2015-2018: %.4f¬∞C' % (month,mean))\n\n\nPractice 4a\nMonthly temperatures in ¬∞C, 2015:\n[16.41, 16.47, 16.5, 16.35, 16.35, 16.39, 16.31, 16.39, 16.42, 16.67, 16.63, 16.7]\nMonthly temperature anomalies in ¬∞C, 2015:\n[0.81, 0.87, 0.9, 0.75, 0.75, 0.79, 0.71, 0.79, 0.82, 1.07, 1.03, 1.1]\nMonthly temperatures in ¬∞C, 2016:\n[16.75, 16.95, 16.91, 16.67, 16.51, 16.37, 16.42, 16.6, 16.48, 16.5, 16.51, 16.43]\nMonthly temperature anomalies in ¬∞C, 2016:\n[1.15, 1.35, 1.31, 1.07, 0.91, 0.77, 0.82, 1.0, 0.88, 0.9, 0.91, 0.83]\nMonthly temperatures in ¬∞C, 2017:\n[16.58, 16.73, 16.73, 16.52, 16.49, 16.3, 16.42, 16.47, 16.36, 16.48, 16.46, 16.49]\nMonthly temperature anomalies in ¬∞C, 2017:\n[0.98, 1.13, 1.13, 0.92, 0.89, 0.7, 0.82, 0.87, 0.76, 0.88, 0.86, 0.89]\nMonthly temperatures in ¬∞C, 2018:\n[16.37, 16.45, 16.51, 16.47, 16.41, 16.34, 16.38, 16.33, 16.36, 16.59, 16.38, 16.49]\nMonthly temperature anomalies in ¬∞C, 2018:\n[0.77, 0.85, 0.91, 0.87, 0.81, 0.74, 0.78, 0.73, 0.76, 0.99, 0.78, 0.89]\nPractice 4b\n[0.9275, 1.05, 1.0625, 0.9025, 0.84, 0.75, 0.7825, 0.8475, 0.805, 0.96, 0.895, 0.9275]\n[0.9275, 1.05, 1.0625, 0.9025, 0.84, 0.75, 0.7825, 0.8475, 0.805, 0.96, 0.895, 0.9275]\nPractice 4c\nMean January temperature anomaly, 2015-2018: 0.9275¬∞C\nMean February temperature anomaly, 2015-2018: 1.0500¬∞C\nMean March temperature anomaly, 2015-2018: 1.0625¬∞C\nMean April temperature anomaly, 2015-2018: 0.9025¬∞C\nMean May temperature anomaly, 2015-2018: 0.8400¬∞C\nMean June temperature anomaly, 2015-2018: 0.7500¬∞C\nMean July temperature anomaly, 2015-2018: 0.7825¬∞C\nMean August temperature anomaly, 2015-2018: 0.8475¬∞C\nMean September temperature anomaly, 2015-2018: 0.8050¬∞C\nMean October temperature anomaly, 2015-2018: 0.9600¬∞C\nMean November temperature anomaly, 2015-2018: 0.8950¬∞C\nMean December temperature anomaly, 2015-2018: 0.9275¬∞C\n\n\n\n\n\n\nwhile loops\nwhile loops are used to repeatedly execute a block of code while a given condition is satisfied. The indented code block will be contiuously executed until the condition becomes False.\nx = 0\nwhile x < 4:\n    x = x + 1\n    print(x)\n>>> 1\n    2\n    3\n    4\nwhile loops are often used for user input, which allows the program to ‚Äústall,‚Äù repeatedly prompting the user until an acceptable answer is input.\n\n‚úèÔ∏è Try it. Run the following cell to see how a while loop works, inputing various answers that do not satisfy the condition before inputing the value that will end the loop.\n\n\n\nCode\n# Define a blank string variable\nuser_txt = \"\"\n# Wait for a specific answer, repeatedly asking for input until the condition is satisfied.\nwhile user_txt != \"42\":\n    user_txt = input(\"What is the answer to life, the universe, and everything? \")\n\n\nWhat is the answer to life, the universe, and everything? water\nWhat is the answer to life, the universe, and everything? 0\nWhat is the answer to life, the universe, and everything? 42\n\n\n\nüêç <b>Note.</b> <code>while</code> loops can be infinite, so they should be used very judiciously. For example, imagine if instead of <code>x = x + 1</code> in the previous example, the code block executed in the <code>while</code> loop were <code>x = x - 1</code>:\nx = 0\nwhile x < 4:\n    x = x - 1\n    print(x)\n>>> -1\n    -2\n    -3\n    -4\n    -5\n    -6\n    ... # and so on\nThis loop would never stop executing because the condition can never be met.\n\n\n\n\n\nEscaping loops\nSometimes it is necessary to terminate a loop iteration or the loop itself. The break and continue statements are used to escape loops.\nbreak statements in Python are used to escape an entire loop based on a condition. In nested loops, a break will only exit out of one level.\n\n\n\nbreak_chart\n\n\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\nwhile True:\n    print(\"What is the answer to life, the universe, and everything? \")\n    option = input(\"   Your answer: \")\n    if option.isdigit():\n        if int(option) == 42:\n            print('You have solved the ultimate question.')\n            break\n        else:\n            print(\"Nope. Try again...\\n\")\n    else:\n        print(\"Nope. Try again...\\n\")\n\n\nWhat is the answer to life, the universe, and everything? \n   Your answer: 77\nNope. Try again...\n\nWhat is the answer to life, the universe, and everything? \n   Your answer: Happiness\nNope. Try again...\n\nWhat is the answer to life, the universe, and everything? \n   Your answer: 42\nYou have solved the ultimate question.\n\n\ncontinue statements are used to skip the remainder of the loop for a given iteration.\n\n\n\ncontinue_chart\n\n\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\nfor x in [47, 22.5342, 'four hundred eighty-two', 0, 72104, -932.14, 6, -23, 'eleven']:\n    # Check to see if value is a string\n    if type(x) == str:\n        # If so, skip to next iteration\n        continue\n    # Otherwise, divide by 2 and print\n    print(x/2)\n\n\n23.5\n11.2671\n0.0\n36052.0\n-466.07\n3.0\n-11.5\n\n\n\n\n\n\nList comprehensions\nA list comprehension is a quick, concise way to generate a list. They are generally used to condense the generation of a list from a simple expression into one line of code.\nFor example, say you wanted a list of all the squares from 0 and 100. As we learned in Exercise 1.2, this could be accomplished as follows:\nsquares = []\n\nfor x in range(11):\n    squares.append(x**2)\n\nprint(squares)\n>>> squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\nUsing a list comprehension, the same list could be generated in a single line of code as follows:\nsquares = [x**2 for x in range(11)]\n\nprint(squares)\n>>> squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\nList comprehensions are often combined with if statements. For example, the following line of code creates a list of all even numbers from 0 to 100.\nevens = [x for x in range(101) if x%2 == 0]\n\nprint(evens)\n>>> evens = [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, \n             22, 24, 26, 28, 30, 32, 34, 36, 38, 40,\n             42, 44, 46, 48, 50, 52, 54, 56, 58, 60, \n             62, 64, 66, 68, 70, 72, 74, 76, 78, 80, \n             82, 84, 86, 88, 90, 92, 94, 96, 98]\n\nüìö  <b> Practice 5. </b> \nUse a list comprehension to generate a list of all even squares from 0 to 1000.\n\n\n\nCode\nevensquares = [x**2 for x in range(101) if (x**2)%2 == 0]\nprint(evensquares)\n\n\n[0, 4, 16, 36, 64, 100, 144, 196, 256, 324, 400, 484, 576, 676, 784, 900, 1024, 1156, 1296, 1444, 1600, 1764, 1936, 2116, 2304, 2500, 2704, 2916, 3136, 3364, 3600, 3844, 4096, 4356, 4624, 4900, 5184, 5476, 5776, 6084, 6400, 6724, 7056, 7396, 7744, 8100, 8464, 8836, 9216, 9604, 10000]\n\n\n\n\n\n\nCode\nfrom IPython.core.display import HTML\ndef css_styling():\n    styles = open(\"../styles/exercises.css\", \"r\").read()\n    return HTML(styles)\ncss_styling()"
  },
  {
    "objectID": "answerkeys/Exercise2-1_Key.html#introduction-to-numpy",
    "href": "answerkeys/Exercise2-1_Key.html#introduction-to-numpy",
    "title": "",
    "section": "Introduction to NumPy",
    "text": "Introduction to NumPy\n\nNumPy, an abbreviation for Numerical Python, is the core library for scientific computing in Python. In addition to manipulation of array-based data, NumPy provides an efficient way to store and operate on very large datasets. In fact, nearly all Python packages for data storage and computation are built on NumPy arrays.\nThis exercise will provide an overview of NumPy, including how arrays are created, NumPy functions to operate on arrays, and array math. While most of the basics of the NumPy package will be covered here, there are many, many more operations, functions, and modules. As always, you should consult the NumPy Docs to explore its additional functionality.\nBefore jumping into NumPy, we should take a brief detour through importing libraries in Python. While most packages we will use ‚Äì including NumPy ‚Äì¬†are developed by third-parties, there are a number of ‚Äústandard‚Äù packages that are built into the Python API. The following table contains a description of a few of the most useful modules worth making note of.\n\n\n\n\n\n\n\n\nModule\nDescription\nSyntax\n\n\n\n\n os \nProvides access to operating system functionality\n import os \n\n\n math \nProvides access to basic mathematical functions\n import math \n\n\n random \nImplements pseudo-random number generators for various distributions\n import random \n\n\n datetime \nSupplies classes for generating and manipulating dates and times\n import datetime as dt \n\n\n\n\nüêç <b>Import syntax.</b> \nAs we saw in Exercise 1.5, modules and packages can be loaded into a script using an <code>import</code> statement: <code>import [module]</code> for the entire module, or <code>from [module] import [identifier]</code> to import a certain class of the module. All modules and packages used in a program should be imported at the beginning of the program.\nMany packages are imported with standard abbreviations (such as dt for the datetime module) using the following syntax:\n\nimport [module] as [name]\n\nThe standard syntax for importing NumPy is:\n\nimport numpy as np\n\n\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\n# Imports\nimport numpy as np\n\n\n\nNumPy Arrays\n\n\nThe n-dimensional array object in NumPy is referred to as an ndarray, a multidimensional container of homogeneous items ‚Äì¬†i.e.¬†all values in the array are the same type and size. These arrays can be one-dimensional (one row or column vector), two-dimensional (m rows x n columns), or three-dimensional (arrays within arrays).\n\n Constructing arrays from lists \n\nThere are two main ways to construct NumPy arrays. The first involves using the np.array() function to generate an array from one or more lists:\nnp.array([8,0,9,1,4])\n>>> array([8, 0, 9, 1, 4])\nRecall that unlike lists, all elements within an array must be of the same type. If the types do not match, NumPy will ‚Äúupcast‚Äù if possible (e.g.¬†convert integers to floats):\nnp.array([8.14,0.12,9,1.77,4])\n>>> array([8.14, 0.12, 9.  , 1.77, 4.  ])\nIn these examples, we have created one-dimensional arrays. By default, elements in a one-dimensional array are cast as rows in a column (i.e.¬†a column vector). If, however, we wanted a row vector instead, we could use double brackets [[]] to create an array with one row and multiple columns:\nnp.array([[8,0,9,1,4]]) # row vector with 5 columns\n>>> array([[8, 0, 9, 1, 4]])\nThis is because NumPy treats the inner element(s) or list(s) as rows. This is easier to see with a multidimensional array:\nnp.array([[3,2,0,1],[9,1,8,7],[4,0,1,6]]) # array with 3 rows x 4 columns\n\n>>> array([[3, 2, 0, 1],\n           [9, 1, 8, 7],\n           [4, 0, 1, 6]])\n\nüìö  <b> Practice 1. </b> \nCreate the following arrays and assign the corresponding variable names:\n\n\na\n\n$ \\begin{matrix}\n        4 &   5 &   0 & 12 & -1 \\\\\n        8 & -21 &  -4 &  6 &  3 \\\\\n       17 &   1 & -13 &  7 &  0\n      \\end{matrix}$\n<li> <code>b</code> </li> \n    $ \\begin{matrix}\n        1.0 & 2.7 & 0 & 0.188 & 4.07 & 0.24\n      \\end{matrix}$\n<li> <code>c</code> </li> \n    $ \\begin{matrix}\n        0.4 \\\\\n        0.8 \\\\\n        1.2 \\\\\n        1.6 \\\\\n        2.0 \\\\\n        2.4\n      \\end{matrix}$\n\n\n\n\nCode\n# Create 3x5 array of integers\na = np.array([[4, 5, 0, 12, -1], [8, -21, -4, 6, 3], [17, 1, -13, 7, 0]])\n\n# Create a 1x6 array of floats\nb = np.array([[1.0, 2.7, 0, 0.188, 4.07, 0.24]])\n\n# Create a one-d array with 6 elements\nc = np.array([0.4, 0.8, 1.2, 1.6, 2.0, 2.4])\n\n\n\n Constructing arrays using functions \n\nOftentimes, it will be more efficient to construct arrays from scratch using NumPy functions. The np.arange() function is used to generate an array with evenly spaced values within a given interval. np.arange() can be used with one, two, or three parameters to specify the start, stop, and step values. If only one value is passed to the function, it will be interpreted as the stop value:\n# Create an array of the first seven integers \nnp.arange(7)\n>>> array([0, 1, 2, 3, 4, 5, 6])\n\n# Create an array of floats from 1 to 12\nnp.arange(1.,13.)\n>>> array([ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10., 11., 12.])\n\n# Create an array of values between 0 and 20, stepping by 2\nnp.arange(0,20,2)\n>>> array([ 0,  2,  4,  6,  8, 10, 12, 14, 16, 18])\nSimilarly, the np.linspace() function is used to construct an array with evenly spaced numbers over a given interval. However, instead of the step parameter, np.linspace() takes a num parameter to specify the number of samples within the given interval:\n# Create an array of 5 evenly spaced values between 0 and 1\nnp.linspace(0,1,5)\n>>> array([0.  , 0.25, 0.5 , 0.75, 1.  ])\nNote that unlike np.arange(), np.linspace() includes the stop value by default (this can be changed by passing endpoint=True). Finally, it should be noted that while we could have used np.arange() to generate the same array in the above example, it is recommended to use np.linspace() when a non-integer step (e.g.¬†0.25) is desired.\n\nüìö  <b> Practice 2. </b> \n\n\nCreate a new array d of integers the multiples of 3 between 0 and 100.\n\n\nCreate an array f 10 evenly spaced elements between 0 and 2.\n\n\nRe-create array c from Practice 1c using a function. Assign this to variable name g.\n\n\n\n\n\nCode\n# a.\nd = np.arange(1,100,3)\n# b. \nf = np.linspace(0,2,10)\n# c.\ng = np.linspace(0.4,2.4,6)\n\n\nThere are several functions that take a shape argument to generate single-value arrays with specified dimensions passed as a tuple (rows,columns):\n# Create a 1D array of zeros of length 4\nnp.zeros(4)\n>>> array([0., 0., 0., 0.]\n\n# Create a 4 x 3 array filled with zeros\nnp.zeros((4,3))\n>>> array([[0., 0., 0.],\n           [0., 0., 0.],\n           [0., 0., 0.],\n           [0., 0., 0.]])\n\n# Create a 4 x 3 array filled with ones\nnp.ones((4,3))\n>>> array([[1., 1., 1.],\n           [1., 1., 1.],\n           [1., 1., 1.],\n           [1., 1., 1.]])\n\n\n# Create a 4 x 3 array filled with 3.14\nnp.full((4,3),9.87)\n>>> array([[9.87, 9.87, 9.87],\n           [9.87, 9.87, 9.87],\n           [9.87, 9.87, 9.87],\n           [9.87, 9.87, 9.87]])\nThe np.random.rand() function is used to generate n-dimensional arrays filled with random numbers between 0 and 1:\n# Create a 4 x 3 array of uniformly distributed random values\nnp.random.rand(4,3)\n>>> array([[0.17461878, 0.74586348, 0.9770975 ],\n           [0.77861373, 0.28807114, 0.10639001],\n           [0.09845499, 0.36038089, 0.58533369],\n           [0.30983962, 0.74786381, 0.27765305]])\nAs we will see, the np.random.rand() function is very useful for sampling and modeling.\nThe last array-construction function we will consider (but by no means the last in the NumPy API!) is the np.eye() function, which is used to generate the two-dimensional identity matrix:\n# Create a 4 x 4 identity matrix\nnp.eye(4)\n>>> array([[1., 0., 0., 0.],\n           [0., 1., 0., 0.],\n           [0., 0., 1., 0.],\n           [0., 0., 0., 1.]])\nLastly, it‚Äôs worth noting that nearly all of these functions contain an optional dtype parameter, which can be used to specify the data-type of the resulting array (e.g.¬†np.ones((4,3),dtype=int) would return a 4 x 3 array of ones as integers, rather than the default floats).\n\nüìö  <b> Practice 3. </b> Assign the following to variables:\n<ol class=\"alpha\">\n    <li> A 5x3 array of ones. </li>\n    <li> A one-dimensional array of 6 zeros. </li> \n    <li> A 7x7 identity array. </li>\n    <li> A random 10x10 array. </li>\n\n\n\n\nCode\n# a. \nones = np.ones((5,3))\n# b.\nzeros6 = np.zeros(6)\n# c.\neye = np.eye(7)\n# d.\nrand100 = np.random.rand(10,10)\n\n\n\n\nArray Manipulation\n\n\nHaving established how to construct arrays in NumPy, let‚Äôs explore some of the attributes of the ndarray, including how to manipulate arrays. Nearly all data manipulation in Python involves NumPy array manipulation; many other Python data tools like Pandas (Exercise 2.2) are built on the NumPy array. Thus, while many of the examples below may seem trivial, understanding these operations will be critical to understanding more complex operations and Python data manipulation more broadly.\n\n Array attributes \n\nArray attributes are properties that are intrinsic to the array itself. While there are quite a few attributes of NumPy arrays, the ones we will use most often provide information about the size, shape, and type of the arrays:\n\n\n\n\n\n\n\nMethod\nDescription\n\n\n\n\n ndarray.ndim \nNumber of array dimensions\n\n\n ndarray.shape \nTuple of array dimensions (rows, columns)\n\n\n ndarray.size \nTotal number of elements in the array\n\n\n ndarray.dtype \nData-type of array elements\n\n\n\nFor example, let‚Äôs create a random two-dimensional array and explore its attributes using the above methods.\n# Initialize array\na = np.random.rand(4,7)\n\n# Determine array dimensions\na.ndim\n>>> 2\n\n# Determine array shame\na.shape\n>>> (4, 7)\n\n# Determine array size\na.size\n>>> 28\n\n# Determine data-type\na.dtype\n>>> dtype('float64')\n\n‚úèÔ∏è <b> Try it. </b> \nConstruct two array vectors, a column vector and a row vector, from the list <code>[8,0,9,1,4]</code>, as in the first example. Using the <code>ndarray.ndim</code> and <code>ndarray.shape</code> methods, show the difference between constructing an array with single vs. double brackets.\n\n\n\nCode\n# Initialize row and column vector arrays\na_column = np.array([8,0,9,1,4])\na_row = np.array([[8,0,9,1,4]])\n\n# Print dimension\nprint(a_column.ndim)\nprint(a_row.ndim)\n\n# Print shape\nprint(a_column.shape)\nprint(a_row.shape)\n\n\n\nüìö  <b> Practice 4. </b> Use array methods and the array you created in Practice 2a (<code>d</code>) to count the number of multiples of 3 between 0 and 100.\n\n\n\nCode\n# Print size of d\nd.size\n\n\n\n Indexing + slicing \n\nIndexing arrays is analogous to indexing lists:\n# Initialize a one-dimensional array\nx1 = np.array([8,0,9,1,4])\n\n# Return the value in position 1\nx1[1]\n>>> 0\nWith multidimensional arrays, a tuple of indices can be passed to access the rows and columns of an array: ndarray[row,column]. If a single index is passed, the corresponding row element will be returned:\n# Initialize a two-dimensional array\nx2 = np.array([[3,2,0,1],\n               [9,1,8,7],\n               [4,0,1,6]])\n\n# Return the value of the element in the 2nd row, 3rd column\nx2[1,2]\n>>> 8 \n\n# Return the entire second row\nx2[1]\n>>> array([9, 1, 8, 7])\nSlicing of arrays allows you to access parts of arrays or subarrays. Just like with lists, slicing follows the syntax ndarray[start:stop:step].\n# Return the elements in positions 1-4\nx1[1:]\n>>> array([0, 9, 1, 4])\nFor multidimensional arrays, a tuple of slices is used: ndarray[row_start:row_end:row_step, col_start:col_end:col_step].\n# Return the entire third column\nx2[:,2]\n>>> array([0, 8, 1])\n\n# Return the first two rows and two columns\nx2[:2,:2]\n>>> array([[3, 2],\n           [9, 1]])\n\n# Return all rows and every other column\nx2[:,::2]\n>>> array([[3, 0],\n           [9, 8],\n           [4, 1]])\n\nüìö  <b> Practice 5. </b> Using the array you created in Practice 3d,\n<ol class=\"alpha\">\n    <li> Print all the elements in column 4. </li>\n    <li> Print all the elements in row 7. </li>\n    <li> Extract the 4x4 subarray at the center of the array and assign it as a new variable. </li>\n    <li> Print the last two values in column 10. </li>\n\n\n\n\nCode\n# a. Print all the elements in column 4\nprint(rand100[:,3])\n\n# b. Print all the elements in row 7\nprint(rand100[6])\n\n# c. Extract the 4x4 subarray at the center of the array and assign it as a new variable.\nprint(rand100[3:7,3:7])\n\n# d. Print the last two values in column 10.\nprint(rand100[-2:,9])\n\n\n\nüìö  <b> Practice 6. </b> Create a blank 8x8 matrix and fill it with a checkerboard pattern of 0s and 1s using indexing.\n\n\n\nCode\n# Blank 8x8 array\nq = np.zeros((8,8))\n\n# Fill with checkerboard pattern\nq[::2,1::2] = 1\nq[1::2,::2] = 1\nq\n\n\n\n Array reduction \n\nArray reduction refers to the computation of summary statistics on an array ‚Äì i.e.¬†reducing an array to a single aggregate value, such as the mean, minimum, maximum, etc. These array reduction methods are similar to those used for lists:\nx2 = np.array([[3,2,0,1],\n               [9,1,8,7],\n               [4,0,1,6]])\n\n# Sum of all values in array\nx2.sum()\n>>> 42\n\n# Maximum value of the array\nx2.max()\n>>> 9\n\n# Minimum value of the array\nx2.min()\n>>> 0\n\n# Mean value of the array\nx2.mean()\n>>> 3.5\n\n# Standard deviation of the array\nx2.std()\n>>> 3.095695936834452\nAll of these methods can be passed with an axis argument, which allows for aggregation across the rows or columns of the array. In NumPy ‚Äì as well as the many libraries built on NumPy, axis 0 always refers to the rows of an array, while axis 1 refers to the columns:\n# Mean of each row (calculated across columns)\nx2.mean(axis=1)\n>>> array([1.5 , 6.25, 2.75])\n\n# Maximum value of each column (calculated across rows)\nx2.max(axis=0)\n>>> array([9, 2, 8, 7])\n\nüêç <b>Functions vs. Methods.</b> \nRecall from Exercise 1.5 that <i>functions</i> and <i>methods</i> in Python are essentially the same thing. The key difference, however, is that functions can be called generically, while methods are always attached to and called on objects. It is also worth noting that while a method may alter the object itself, a function <i>usually</i> simply operates on an object without changing it, and then prints something or returns a value.\nFor each of the array reduction methods demonstrated above, there is a corresponding function. For example, the mean of an array can be calculated using the method ndarray.mean() or the function np.mean(ndarray).\nThese ‚Äì¬†and the many additional ‚Äì aggregation functions in NumPy can be used, not only on arrays, but on any numerical object.\n\n\n Reshaping, resizing, + rearranging arrays \n\nOther useful array operations include reshaping, resizing, and rearranging arrays. The ndarray.reshape() method is used to change the shape of an array:\n# Initialize a one-dimensional array with 16 elements\na = np.arange(1.0,17.0)\n\na\n>>> array([ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10., 11., 12., 13.,\n       14., 15., 16.])\n\n# Reshape array a into a 4x4 array\nb = a.reshape(4,4)\n\nb\n>>> [[ 1.  2.  3.  4.]\n     [ 5.  6.  7.  8.]\n     [ 9. 10. 11. 12.]\n     [13. 14. 15. 16.]]\n\nThere are a few important things to note about the ndarray.reshape() method. First and unsurprisingly, the size of array must be preserved (i.e.¬†the size of the reshaped array must match that of the original array). Secondly, and perhaps more importantly, the ndarray.reshape() method creates a view of the original array a, rather than a copy, which would allow the two variables to exist independently. Because b is a view of a, any changes made to b will also be applied to a:\n# Reset the value in the third row, third column (11.0)\nb[2,2] = 0.0\n\nb\n>>> array([[ 1.,  2.,  3.,  4.],\n           [ 5.,  6.,  7.,  8.],\n           [ 9., 10.,  0., 12.],\n           [13., 14., 15., 16.]])\n\na\n>>> array([ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10.,  0., 12., 13., \n           14., 15., 16.])\nUnlike ndarray.reshape(), the ndarray.resize() method operates in-place on the original array. The ndarray.resize() method is used to add or delete rows and/or columns:\n# Initialize a 2 x 3 array\na = np.array([[1,2,3],[4,5,6]])\n\n# Copy the original array\nsmaller = a.copy()\n# Use ndarray.resize() to reshape to a 2x2 array and delete the last two elements\nsmaller.resize(2,2)\n\nsmaller\n>>> array([[1, 2],\n           [3, 4]])\n\n# Copy the original array\nbigger = a.copy()\n# Use ndarray.resize() to reshape to a 6x6 array by adding zeros\nbigger.resize(6,6)\n\nbigger\n>>> array([[1, 2, 3, 4, 5, 6],\n           [0, 0, 0, 0, 0, 0],\n           [0, 0, 0, 0, 0, 0],\n           [0, 0, 0, 0, 0, 0],\n           [0, 0, 0, 0, 0, 0],\n           [0, 0, 0, 0, 0, 0]])\n\nüêç <b>Copies vs. Views</b> \nThis is just one example of many occasions when it is advisable to create a <b>copy</b> of the original object before manipulating it. Had we not copied <code>a</code> before resizing it to a 2x2 array, the last two elements would have been permanently deleted, as <code>a</code> itself would have been resized. A good rule of thumb is to <b>always create a copy</b> before changing or deleting any data.\n\nOften it is useful to rearrange the elements in an array. The ndarray.transpose() method ‚Äì¬†or simply ndarray.T, transposes the array, switching the rows and columns, while the np.flip(), np.flipud(), and np.fliplr() functions reverse the order of elements in the array along a given axis:\n# Initialize a new 4x5 array\nx = np.array([[4, 2, 0, 1, 5],\n              [9, 4, 1, 3, 0],\n              [6, 0, 8, 5, 9],\n              [7, 3, 2, 7, 4]])\n\n# Transpose rows + columns\nx.T\n>>> array([[4, 9, 6, 7],\n           [2, 4, 0, 3],\n           [0, 1, 8, 2],\n           [1, 3, 5, 7],\n           [5, 0, 9, 4]])\n\n# Flip the array (reverse the order of all elements)\nnp.flip(x)\n>>> array([[4, 7, 2, 3, 7],\n           [9, 5, 8, 0, 6],\n           [0, 3, 1, 4, 9],\n           [5, 1, 0, 2, 4]])\n\n# Flip the array up/down (reverse the order of the rows)\nnp.flipud(x)\n>>> array([[7, 3, 2, 7, 4],\n           [6, 0, 8, 5, 9],\n           [9, 4, 1, 3, 0],\n           [4, 2, 0, 1, 5]])\n\n# Flip the array left/right (reverse the order of the columns)\nnp.fliplr(x)\n>>> array([[5, 1, 0, 2, 4],\n           [0, 3, 1, 4, 9],\n           [9, 5, 8, 0, 6],\n           [4, 7, 2, 3, 7]])\nWhen passed with the axis argument, np.flip() mimics the np.flipud() and np.fliplr() functions:\n# Flip the array over the row axis (same as np.flipud(x))\nnp.flip(x, axis=0)\n>>> array([[7, 3, 2, 7, 4],\n           [6, 0, 8, 5, 9],\n           [9, 4, 1, 3, 0],\n           [4, 2, 0, 1, 5]])\n\n# Flip the array over the column axis (same as np.fliplr(x))\nnp.flip(x, axis=1)\n>>> array([[5, 1, 0, 2, 4],\n           [0, 3, 1, 4, 9],\n           [9, 5, 8, 0, 6],\n           [4, 7, 2, 3, 7]])\n\nüìö  <b> Practice 7. </b>\n<ol class=\"alpha\">\n    <li> Create a 3x3 matrix with values ranging from 0 to 8. </li>\n    <li> Reverse the order of elements in your random 10x10 array from 3d. </li>\n\n\n\n\nCode\n# a. Create a 3x3 matrix with values ranging from 0 to 8\nw = np.arange(0,9)\nv = w.reshape(3,3)\n\n# b. Reverse the order of elements in your random 10x10 array from 3d.\nrand100_rev = np.flip(rand100)\n\n\n\n Joining + splitting arrays \n\nSo far, we have considered array manipulation routines that operatee on a single array. We will encounter many scenarios in which it is necessary to combine multiple arrays into one or, conversely, to split a single array into two or more separate objects.\nConcatenation in computer programming refers to the process of joining multiple objects end-to-end. The most common way of concatenating arrays in NumPy is with the np.concatenate() function, which takes a tuple of arrays:\n# Initialize a 3x3 array\nx = np.array([[4,2,0],\n              [9,4,1],\n              [6,0,8]])\n# Initialize a 1x3 array\ny = np.array([[2,8,6]])\n\n# Concatenate x and y\nnp.concatenate((x,y))\n>>> array([[4, 2, 0],\n           [9, 4, 1],\n           [6, 0, 8],\n           [2, 8, 6]])\nNote that, by default, np.concatenate() operates along the row axis (0). To concatenate along the column axis, we must specify axis=1 as an argument:\n# Concatenate x and y along the column axis\nnp.concatenate((x,y), axis=1)\n>>> ---------------------------------------------------------------------------\n    ValueError                                Traceback (most recent call last)\n    <ipython-input-65-6c2205ef28d2> in <module>\n          5 y = np.array([[2,8,6,0]])\n          6 \n    ----> 7 np.concatenate((x,y),axis=1)\n\n    <__array_function__ internals> in concatenate(*args, **kwargs)\n\n    ValueError: all the input array dimensions for the concatenation axis must match exactly, but along \n    dimension 0, the array at index 0 has size 3 and the array at index 1 has size 1\nUh-oh! Unsurprisingly, when we tried to concatenate an array with 1 row to an array with 3 rows, we got a ValueError. For np.concatenate() to work, the dimensions must match. Thus, we must first transpose y before adding it to x as a column:\n# Transpose y and concatenate x and y along the column axis\nnp.concatenate((x,y.T),axis=1)\n>>> array([[4, 2, 0, 2],\n           [9, 4, 1, 8],\n           [6, 0, 8, 6]])\nEquivalently, we could use the np.vstack() or np.hstack() function to concatenate directly along the row or column axis, respectively:\n# Stack rows of x and y (same as np.concatenate((x,y), axis=0)\nnp.vstack((x,y))\n>>> array([[4, 2, 0],\n           [9, 4, 1],\n           [6, 0, 8],\n           [2, 8, 6]])\n\n# Stack columns of x and y (same as np.concatenate((x,y), axis=1)\nnp.hstack((x,y.T))\n>>> array([[4, 2, 0, 2],\n           [9, 4, 1, 8],\n           [6, 0, 8, 6]])\n\nüìö  <b> Practice 8. </b> Create two random 1-D arrays of length 10. Merge them into a 2x10 array and then a 10x2 array.\n\n\n\nCode\n# 2 random 1-D arrays\nj = np.random.rand(10)\nk = np.random.rand(10)\n\n# Concat as 2x10 array\nvert = np.vstack((j,k))\n# Concat as 10x2 array\nhoriz = vert.T # or np.column_stack((j,k)).shape\n\n\nConversely, splitting allows you to breakdown a single array into multiple arrays. Splitting is implemented with the np.split(), np.vsplit(), and np.hsplit() functions.\n# Initialize a 4x3 array\nz = np.array([[4, 2, 0],\n              [9, 4, 1],\n              [6, 0, 8],\n              [2, 8, 6]])\n\n# Split z into two arrays at row 1\nnp.split(z,[1])\n>>> [array([[4, 2, 0]]), array([[9, 4, 1],\n                                [6, 0, 8],\n                                [2, 8, 6]])]\n\n# OR\nnp.vsplit(z,[1])\n>>> [array([[4, 2, 0]]), array([[9, 4, 1],\n                                [6, 0, 8],\n                                [2, 8, 6]])]\n\n# Split z into two arrays at column 1\nnp.hsplit(z,[1])\n>>> [array([[4],\n            [9],\n            [6],\n            [2]]), \n     array([[2, 0],\n            [4, 1],\n            [0, 8],\n            [8, 6]])]\nMultiple indices can be passed to the np.split() and related functions, with n indices (split points) resulting in n + 1 subarrays.\n\nüìö  <b> Practice 9. </b>\n<ol class=\"alpha\">\n    <li> Split your random 10x10 array from 3d into two 10x5 arrays. </li>\n    <li> Combine the first 10x5 array from (a), the 10x2 array from 8b, and the other 10x5 array from (a). In other words, recombine the 10x10 array from 3d with two new columns in index positions 5 and 6. Your final array should have 10 rows and 12 columns. Verify this by printing the shape of the resulting array. </li>\n\n\n\n\nCode\n# Split into equal 10x5 arrays.\nx,y = np.hsplit(rand100,[5])\n\n# Concatenate x, y, and horiz\nrand120 = np.concatenate((x,y,horiz), axis=1)\n\n# Print dimensions\nprint(rand120.shape)\n\n\n\n\nArray Math\n\n\nOne of the key advantages of NumPy is its ability to perform vectorized operations using universal functions (ufuncs), which perform element-wise operations on arrays very quickly. For example, say we had a very large list of data, and we wanted to perform some mathematical operation on all of the data elements. We could store this data as a list or an ndarray:\n# Create a list of the first 10,000 integers\na = list(range(10000))\n\n# Create a one-dimensional array of the first 10,000 integers\nb = np.arange(10000)\nNow, let‚Äôs multiply each element in our dataset by 2. We can accomplish this by using a for loop for the list a and a ufunc for array b. (The %timeit module is a built-in Python function used to calculate the time it takes to execute short code snippets.)\n# Use a for loop to multiply every element in a by 2\n%timeit [i*2 for i in a]\n# Use a ufunc to multiply every element in b by 2\n%timeit b * 2\n\n>>> 388 ¬µs ¬± 30.6 ¬µs per loop (mean ¬± std. dev. of 7 runs, 1000 loops each)\n    3.58 ¬µs ¬± 41.1 ns per loop (mean ¬± std. dev. of 7 runs, 100000 loops each)\nThe %timeit module is a built-in Python function used to calculate the time it takes to execute short code snippets.\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\n# Create a list of the first 10,000 integers\nlist10 = list(range(10000))\n# Use a for loop to multiply every element in a by 2\n%timeit [i*2 for i in a]\n\n# Create a one-dimensional array of the first 10,000 integers\narray10 = np.arange(10000)\n# Use a ufunc to multiply every element in b by 2\n%timeit b * 2\n\n\nAs you can see, the for loop took about 100 times longer than the exact same element-wise array operation!\n\n Computation on single arrays using ufuncs \n\nUfuncs are fairly straightforward to use, as they rely on Python‚Äôs native operators (e.g.¬†+, -, *, /):\n# Create a 2x4 array of floats\nx  = np.array([[1.,2.,3.,4.],\n               [5.,6.,7.,8.]])\n\n# Do some math\n# Addition\nx + 12\n>>> array([[13., 14., 15., 16.],\n           [17., 18., 19., 20.]])\n\n# Subtraction\nx - 400\n>>> array([[-399., -398., -397., -396.],\n           [-395., -394., -393., -392.]])\n\n# Exponentiation\nx ** 2\n>>> array([[ 1.,  4.,  9., 16.],\n           [25., 36., 49., 64.]])\n\n# Combine operations\n10 ** (x/2)\n>>> array([[3.16227766e+00, 1.00000000e+01, 3.16227766e+01, 1.00000000e+02],\n           [3.16227766e+02, 1.00000000e+03, 3.16227766e+03, 1.00000000e+04]])\nThese arithmetic operators act as wrappers (effectively shortcuts) around specific built-in NumPy functions; for example, the + operator is a convenient shortcut for the np.add() function:\nx + 2\n>>> array([[ 3.,  4.,  5.,  6.],\n           [ 7.,  8.,  9., 10.]])\n\nnp.add(x,2)\n>>> array([[ 3.,  4.,  5.,  6.],\n           [ 7.,  8.,  9., 10.]])\nThe following table contains a list of arithmetic operators implemented by NumPy. Note that these functions work on all numerical objects, not just arrays.\n\n\n\nArithmetic functions in NumPy \n\n\n\n\n\n\n\n\n\nOperator\nufunc\nDescription\n\n\n\n\n +\n np.add() \nAddition\n\n\n -\n np.subtract() \nSubtraction\n\n\n * \n np.multiply() \nMultiplication\n\n\n / \n np.divide() \nDivision\n\n\n // \n np.floor_divide() \nFloor division (returns largest integer)\n\n\n ** \n np.power() \nExponentiation\n\n\n % \n np.mod() \nModulus/remainder\n\n\n **(1/2) \n np.sqrt() \nSquare root-alize\n\n\n\nFurthermore, as a numerical package, NumPy implements many additional mathematical operations for use in Python ‚Äì¬†on arrays or otherwise. The following tables show some of the more commonly used mathematical functions in NumPy. The x is used to denote a numerical object ‚Äì this could be an int, float, list, ndarray, etc.\n\n\n\nLogarithmic functions \n\n\n\n\n\n\n\n\nufunc\nOperation\n\n\n\n\n np.exp(x) \ne^x\n\n\n np.log(x) \n\\ln x\n\n\n np.log10(x) \n\\log x\n\n\n\n\n\n\n Trigonometric functions \n\n\n\n\n\n\n\n\nufunc\nDescription\n\n\n\n\n np.sin(x) \n\\sin{x}\n\n\n np.cos(x) \n\\cos{x}\n\n\n np.tan(x) \n\\tan{x}\n\n\n np.arcsin(x) \n\\sin^{-1}{x}\n\n\n np.arccos(x) \n\\cos^{-1}{x}\n\n\n np.arctan(x) \n\\tan^{-1}{x}\n\n\n\n\n\nNote: NumPy assumes all inputs to trigonometic functions are in units of radians. The np.radians() function can be used to convert from degrees to radians, while the np.degrees() function does the opposite.\n\n\n\n Useful mathematical constants \n\n\n\n\n\n\n\n\nConstants\nDescription\n\n\n\n\n np.e \ne\n\n\n np.pi \n\\pi\n\n\n\n\n Array-to-array math \n\nSo far, we have only considered operations between a single array and an integer, but often it is necessary to perform mathematical operations on multiple arrays. Much like NumPy handles single array operations, array-to-array math in NumPy uses ufuncs to perform element-wise calculations. For arrays of the same dimensions, this is straight forward:\nx  = np.array([[1.,2.,3.,4.],\n               [5.,6.,7.,8.]])\n\ny = np.array([[9.,87.,3.,5.6],\n              [-1.,4.,7.1,8.]])\n\n# Addition\nx + y\n>>> array([[10. , 89. ,  6. ,  9.6],\n           [ 4. , 10. , 14.1, 16. ]])\n\n# Division\nx / y\n>>> array([[ 0.11111111,  0.02298851,  1.        ,  0.71428571],\n           [-5.        ,  1.5       ,  0.98591549,  1.        ]])\nFor arrays whose dimensions do not match, NumPy does something called broadcasting. So long as one dimension of each array matches and one array has a dimension of 1 in one direction, the smaller array is ‚Äúbroadcast‚Äù to the dimensions of the larger array. In this process, the row or column is replicated to match the dimensions of the larger array. This is best illustrated in the following diagram:\n\na = np.array([[1.,2.,3.,4.],\n             [5.,6.,7.,8.]])\n\nb = np.array([10,11,12,13])\n\nc = np.array([[1.],\n             [20.]])\n\n# Row-wise\na + b\n>>> array([[11., 13., 15., 17.],\n           [15., 17., 19., 21.]])\n\n# Column-wise\na + c\n>>> array([[ 2.,  3.,  4.,  5.],\n           [25., 26., 27., 28.]])\n\n# Multiple operations\na + c**2\n>>> array([[  2.,   3.,   4.,   5.],\n           [405., 406., 407., 408.]])\n\nüìö  <b> Practice 10. </b>\n<ol class=\"alpha\">\n    <li> Raise array <code>b</code> to the power of array <code>c</code>. </li>\n    <li> Create a new 5x10 array of random values. Subtract the mean of each row from every value. </li>\n\n\n\n\nCode\n# a. \nb ** c\n\n# b. \n# Random 5x10 array\nrand50 = np.random.rand(5, 10)\n\n# Calculate mean of each row\nm = np.array([rand50.mean(axis=1)])\n# Subtract mean from each element\nl = rand50 - m.T\nprint(l)\n\n\n\n\nMissing Data\n\n\nMost real-world datasets ‚Äì¬†environmental or otherwise ‚Äì¬†have data gaps. Data can be missing for any number of reasons, including observations not being recorded or data corruption. While a cell corresponding to a data gap may just be left blank in a spreadsheet, when imported into Python, there must be some way to handle ‚Äúblank‚Äù or missing values.\nMissing data should not be replaced with zeros, as 0 can be a valid value for many datasets, (e.g.¬†temperature, precipitation, etc.). Instead, the convention is to fill all missing data with the constant NaN. NaN stands for ‚ÄúNot a Number‚Äù and is implemented in NumPy as np.nan.\nNaNs are handled differently by different packages. In NumPy, all computations involving NaN values will return nan:\ndata = np.array([[2.,2.7.,1.89.],\n                 [1.1, 0.0, np.nan],\n                 [3.2, 0.74, 2.1]])\n\ndata.mean()\n>>> nan\nIn this case, we‚Äôd want to use the alternative np.nanmean() function, which ignores NaNs:\ndata.nanmean()\n>>> 1.71625\nNumPy has several other functions ‚Äì including np.nanmin(), np.nanmax(), np.nansum() ‚Äì that are analogous to the regular ufuncs covered above, but allow for computation of arrays containing NaN values.\n\n\n\n\nWrapping up\nThe topics covered in this exercise are but a small window into the wide world of NumPy, but by now you should be familiar with the basic objects and operations in the NumPy library, which are the building blocks of data science in Python. As always ‚Äì especially now that we‚Äôve begun exploring third-party packages ‚Äì refer to the NumPy docs for comprehensive information on all functions, methods, routines, etc. and to check out more of NumPy‚Äôs capabilities.\nNext, we‚Äôll explore one of data scientists‚Äô favorite libraries: üêº.\n\n\n\n\nCode\n# IGNORE THIS CELL\nfrom IPython.core.display import HTML\ndef css_styling():\n    styles = open(\"../styles/exercises.css\", \"r\").read()\n    return HTML(styles)\ncss_styling()"
  },
  {
    "objectID": "answerkeys/Exercise1-0_Key.html#introduction-to-python",
    "href": "answerkeys/Exercise1-0_Key.html#introduction-to-python",
    "title": "",
    "section": "Introduction to Python",
    "text": "Introduction to Python\n\n\n\nPrint statements\nThe most basic function in Python is the print() function, which simply prints out a line.\nprint( 'This is a print statement.' )\n\n >>>  This is a print statement.\n\n\n‚ñ∂Ô∏è Run the cell below.\n\n\n\nCode\nprint( 'This is a print statement.' )\n\n\nThis is a print statement.\n\n\n\nüìö Practice 1. In the following cell, use the print() command to print the line ‚ÄúHello, World!‚Äù)\n\n\n\nCode\nprint('Hello, World!')\n\n\nHello, World!\n\n\n\n\n\n\nUser input\nThe input() command is an important Python function that can be used in a program to prompt for user input.\n\n‚úèÔ∏è Try it. Run the following cell to see how the input() function works, inputing your first name when prompted.\n\n\n\nCode\nname = input( 'What is your first name? ' )\nprint( 'My name is ' + name + '.' )\n\n\nWhat is your first name? Bryn\nMy name is Bryn.\n\n\n\n\n\n\nComments\nIn programming, a comment is a piece of text that the computer ignores when running the program. Comments are usually used at the top of a program to provide a description of the program, name and information of the author, dependencies, etc., as well as throughout the script to explain lines of code. Commenting is a critical element of proper coding etiquette.\nThere are two types of comments: in-line comments and block comments. In-line comments are used to provide context at the end of a line of code, while block comments come before a ‚Äúblock‚Äù or chunk of code.\n\nüêç <b>Note.</b>\nIn Python, there are two ways of writing comments. For in-line comments and most short comments, the <span style=\"font-weight:bold\"> # </span> character is used. For large block comments, such as those at the beginning of a file or function, three quotations <span style=\"font-weight:bold\">  '''  </span> are used to enclose comments. Both single and double quotations are interpreted the same, as long as they are not used together.\n\nThe following example is a function (a type of Python object we will cover later on) that uses both methods of commenting. As you can see, without the comments, it would be difficult to understand what the function does, what parameters it takes, and what the intermediate steps are to reach the end.\ndef homo_affine_matrix(p, p_prime):\n    '''\n    Finds the unique homogeneous affine transformation that transforms a set of 3 points \n    from one coordinate system to that of a second set of points in 3-D space\n    \n    Parameters\n    ----------\n    p : array\n        original set of points as a row vector: ((p1, p2, p3))\n    p_prime : array\n        Transformed points as a row vector: ((p1_prime, p2_prime, p3_prime))\n    \n    Returns\n    -------\n    array\n        4 x 3 affine transformation matrix.\n        \n    Source: Adapted by B. Morgan from https://math.stackexchange.com/a/222170 (robjohn)\n    '''\n    # Construct intermediate matrix\n    Q       = p[1:]       - p[0]\n    Q_prime = p_prime[1:] - p_prime[0]\n\n    # Calculate rotation matrix\n    R = np.dot(np.linalg.inv(np.row_stack((Q, np.cross(*Q)))),\n               np.row_stack((Q_prime, np.cross(*Q_prime))))\n\n    # Calculate translation vector\n    t = p_prime[0] - np.dot(p[0], R)\n\n    # Calculate affine transformation matrix\n    return np.column_stack((np.row_stack((R, t)),\n                            (0, 0, 0, 1)))\n \n\n‚ñ∂Ô∏è Run the cell below.\n\n\n\nCode\n# This comment will not be read by the computer.\n2 + 2  # Neither will this.\n\n\n4\n\n\n\n\n\n\nCode\n# IGNORE THIS CELL\nfrom IPython.core.display import HTML\ndef css_styling():\n    styles = open(\"./styles/exercises.css\", \"r\").read()\n    return HTML(styles)\ncss_styling()"
  },
  {
    "objectID": "answerkeys/Exercise1-1_Key.html#variables-operators",
    "href": "answerkeys/Exercise1-1_Key.html#variables-operators",
    "title": "",
    "section": "Variables + Operators",
    "text": "Variables + Operators\nVariables are used in Python to create references to an object (e.g.¬†string, float, DataFrame, etc.). Variables are assigned in Python using =.\n\nüêç <b>Note.</b>\nVariable names should be chosen carefully and should indicate what the variable is used for. Python etiquette generally dictates using lowercase variable names. Underscores are common. Variable names cannot start with a number. Also, there are several names that cannot be used as variables, as they are reserved for built-in Python commands, functions, etc. We will see examples of these throughout this exercise.\n\n\n\n\nNumbers\nNumbers in Python can be either integers (whole numbers) or floats (floating point decimal numbers).\nThe following syntax is used to define an integer:\nx = 1\ny = 42\n\n‚ñ∂Ô∏è Run the cell below.\n\n\n\nCode\n# Define variables x and y as integers.\nx = 1\ny = 42\n\n\nThe following syntax is used to define a float:\na = 1.0\nb = 42.0\nc = 23.782043\n\n‚úèÔ∏è Try it.\nDefine variables a, b, and c according to the values above.\n\n\n\nCode\n# Define variables a, b, and c as floats.\na = 1.0\nb = 42.0\nc = 23.782043\n\n\n\n Arithmetic Operators \n\nJust like a calculator, basic arithmetic can be done on number variables. Python uses the following symbols\n\n\n\nSymbol\nTask\n\n\n\n\n+\nAddition\n\n\n-\nSubtraction\n\n\n*\nMultiplication\n\n\n/\nDivision\n\n\n%\nModular\n\n\n//\nFloor division\n\n\n**\nPower\n\n\n\n\n‚úèÔ∏è Try it. Practice these arithmetic operations by running the code in the cell below. Feel free to add more to test the operators. Use the print() command to output your answers.\n\n\n\nCode\n# Do some math.\nt = x + y\nu = c / 7.1\nv = a - u * (c + u)\nw = c % 2\n\n# Print your answers.\nprint(t)\nprint(u)\nprint(v)\nprint(w)\n\n\n43\n3.349583521126761\n-89.87964909653199\n1.7820430000000016\n\n\nNotice that the order of operations applies.\n\n Boolean Operators \n\nBoolean operators evaluate a condition between two operands, returning True if the condition is met and False otherwise. True and False are called booleans.\n\n\n\nSymbol\nTask\n\n\n\n\n==\nEquals\n\n\n!=\nDoes not equal\n\n\n<\nLess than\n\n\n>\nGreater than\n\n\n<=\nLess than or equal to\n\n\n>=\nGreater than or equal to\n\n\n\n\n‚ñ∂Ô∏è Run the cell below.\n\n\n\nCode\nprint( b >= w )\nprint( 87 < -2 )\nprint( c != 0 )\nprint( y == x)\n\n\nTrue\nFalse\nTrue\nFalse\n\n\n\n Built-in functions \n\nPython has a number of built-in functions. Here we will introduce a few of the useful built-in functions for numerical variables.\nThe type() function is used to check the data type of a variable. For numerical arguments, either float or int is returned.\n\n‚ñ∂Ô∏è Run the cell below.\n\n\n\nCode\ntype(v)\n\n\nfloat\n\n\nThe isinstance() function is used to determine whether an argument is in a certain class. It returns a boolean value. Multiple classes can be checked at once.\nisinstance(12, int)\n>>> True\n\nisinstance(12.0,int)\n>>> False\n\nisinstance(12.0,(int,float))\n>>> True\nThe commands int() and float() are used to convert between data types.\n\n‚ñ∂Ô∏è Run the cell below.\n\n\n\nCode\nprint( float(y) )\nprint( int(c) )\n\n\n42.0\n23\n\n\nNotice that when converting a float value to an integer, the int() command always rounds down to the nearest whole number.\nTo round a float to the nearest whole number, use the function round(). You can specify the number of decimal places by adding an integer as an argument to the round() function .\n\n‚ñ∂Ô∏è Run the cell below.\n\n\n\nCode\nprint( round(c) )\nprint( round(c,3) )\n\n\n24\n23.782\n\n\nThe complex() function is used to define a complex number.\n\n‚ñ∂Ô∏è Run the cell below.\n\n\n\nCode\nd = complex('5+2j')\n\n\nTo return the absolute value of a number, use the abs() function.\n\n‚ñ∂Ô∏è Run the cell below.\n\n\n\nCode\nprint( abs(d) )\nprint( abs(-12) )\n\n\n5.385164807134504\n12\n\n\nThe divmod() function returns the quotient and remainder of two input operands in a tuple. (Tuples are another data type that we will cover later.)\ndivmod(64, 4.2)\n>>> (15.0, 0.9999999999999973)\n\n\nThe pow() function is an alternative to the ** operator for raising a number to an exponent, i.e.¬†x^y. An optional third argument is used to return the modulus (%) of the power of a number, i.e.¬†x^y % z.\npow(8,2)\n>>> 64\n\npow(8,2,3)\n>>> 1\n\n\n\nüìö Practice 1. The laws of conservation state that in a closed system, mass, energy, and momentum can be neither created nor destroyed. Thus, the energy coming into the Earth‚Äôs surface (via solar radiation) must be equal to the energy going out from the Earth‚Äôs surface. The energy coming in via solar radiation can be written: R_{\\text{in}} = G_s \\pi {r_{e}}^2 (1 - \\alpha) where r_e is the radius of the Earth; \\alpha is the Earth‚Äôs albedo, a fraction correponding to the amount of incident radiation that is reflected; and G_s is the Solar Constant, or the flux density of the solar radiation at the Earth‚Äôs surface. The Solar Constant can be calculated according to the equation G_s = \\sigma {T_{sun}}^4 \\left( \\frac{4 \\pi {r_{sun}}^2}{4 \\pi d^2} \\right) where \\sigma is the Stefan-Boltzmann constant, T_{sun} is the temperature of the sun, r_{sun} is the radius of the sun, and d is the average distance between the sun and the Earth. The outgoing radiation from the Earth is given by the Stefan-Boltzmann law: R_{\\text{out}} = \\varepsilon \\sigma A_{e} {T_e}^4 where \\varepsilon is the emissivity of the Earth, A_e is the surface area of the Earth approximated as a sphere, and T_e is the temperature of the Earth‚Äôs surface.\n\nGiven \\sigma = 5.67 \\times 10-8 W m-2 K-4, the radius of the sun is 6.957 \\times 105 km, the temperature of the sun is 5778 K, the average distance between the sun and the Earth is 1.5 \\times 108 km, and the emissivity of the Earth is 1.0,\n\n\n\nCalculate the Solar Constant in W m-2. Print your answer rounded to 3 decimal places.\n\n\nCalculate the temperature of the Earth‚Äôs surface in ¬∞C. Print your answer as both a float and an integer.\n\n\nThe actual global surface temperature of the Earth is about 14.6¬∞C. What accounts for the difference between the answer you calculated above in the actual surface temperature?\n\n\n\nShow your work by including comments in your code and assigning variables.\n\n\n\n\nCode\n# Constants\nsigma = 5.67e-8  # W m-2 K-4\nr_sun = 6.957e8  # m\nT_sun = 5778     # K\nd = 1.5e11       # m\nalpha = 0.3      # unitless\n\n# 1a. Solar constant\nprint('Practice 1a')\ng_s = sigma * (T_sun **4) * ((r_sun**2) / (d**2))\nprint('Solar constant = ' + str(round(g_s,3)) + ' W m-2')\n\n# 1b. Temperature of the Earth\nprint('Practice 1b')\nT_e = (((g_s*(1-alpha)) / (4*1.0*sigma))**(1/4)) - 273.15\nprint(\"Temperature of the Earth's surface = \" + str(int(T_e)) + '¬∞C')\nprint(\"Temperature of the Earth's surface = \" + str(T_e) + '¬∞C')\n\n\nPractice 1a\nSolar constant = 1359.423 W m-2\nPractice 1b\nTemperature of the Earth's surface = -18¬∞C\nTemperature of the Earth's surface = -18.6414235372213¬∞C\n\n\n1c. Greenhouse gases; i.e.¬†the emissivity of the Earth‚Äôs atmosphere is not 1.0.\n\n\n\n\nStrings\nPieces of text in Python are referred to as strings. Strings are defined with either single or double quotes. The only difference between the two is that it is easier to use an apostrophe with double quotes.\nmytext = 'This is a string.'\nmytext2 = \"This is also a string.\"\nTo use an apostrope or single quotes inside a string defined by single quotes (or to use double quotes), use a single backslash ( \\ ) referred to as an ‚Äúescape‚Äù character.\nq1a = \"What is Newton's 1st law?\"\nq1b = 'What is Newton\\'s 1st law?'\n\nüìö Practice 2. In the cell below, answer the question by defining a new string variable. Use the print() command to output your answer.\n\n\n\nCode\n# Question\nq1 = 'What is Newton\\'s 1st law?'\n\n# Answer the question by defining a new string variable.\na1 = 'An object in motion will stay in motion until it is acted upon by an external force.'\n# Print your answer.\nprint(q1)\nprint(a1)\n\n\nWhat is Newton's 1st law?\nAn object in motion will stay in motion until it is acted upon by an external force.\n\n\n\n Built-in functions \n\nJust like the int() and float commands, the str() command converts a number to a string.\n\n‚ñ∂Ô∏è Run the cell below.\n\n\n\nCode\nystr = str(y)\n\n\nThe + operator can be used to combine two or more strings.\n\n‚ñ∂Ô∏è Run the cell below.\n\n\n\nCode\ns = 'isaac' + ' ' + 'newton'\n\n\nThe commands string.upper() and string.capitalize() can be used to convert all letters in the string to uppercase and capitalize the first letter in the string, respectively.\n\n‚ñ∂Ô∏è Run the cell below.\n\n\n\nCode\nprint( s.upper() )\nprint( s.capitalize() )\n\n\nISAAC NEWTON\nIsaac newton\nisaac newton\n\n\n\nüìö Practice 3. Assign your first and last names to variables and use the + operator to combine them into a single variable. Practice capitalizing the first letter and then the entire string. Print your answers.\n\n\n\nCode\n# Define variables\nfirst = 'Bryn'\nlast = 'Morgan'\n# Combine in a single string.\nfull_name = first + ' ' + last\n# Capitalize the first letter\ncap_name = full_name.capitalize()\n# Capitalize the entire string.\nupper_name = full_name.upper()\n# Print outputs.\nprint(full_name)\nprint(cap_name)\nprint(upper_name)\n\n\nBryn Morgan\nBryn morgan\nBRYN MORGAN\n\n\n\n Formatted print statements \n\nPython uses C-style formatting to create new, formatted strings with the % operator. This is useful for printing variables in functions and when asking for user input, both of which we will discuss later. Formatted print statements contain a string argument with one of the following specifiers:\n\n\n\nSymbol\nTask\n\n\n\n\n%s\nStrings\n\n\n%d\nIntegers\n\n\n%f\nFloating point numbers\n\n\n\nThe second argument can contain a variable name or a tuple, which is a list of a fixed size. The arguments are separated by the % operator.\n\n‚ñ∂Ô∏è Run the cell below.\n\n\n\nCode\ncity = 'Santa Barbara'\nyrs = 3\nprint( 'I live in %s.' % city )\nprint( 'I have lived in %s for %d years.' % (city,yrs))\n\n\nI live in Santa Barbara.\nI have lived in Santa Barbara for 3 years.\n\n\n\n‚úèÔ∏è Try it. Use the code below to write a formatted string that prints the sentence My name is [YOUR FIRST NAME]. I am [YOUR AGE] years old., inputing your name and age. Replace first with the name of the variable you assigned to your first name in the previous question. Replace age with your age as an integer.\n\n\n\nCode\n# Define the variable info.\ninfo = (first, 25)\n# Complete the sentence to be printed\nsentence = \"My name is %s. I am %d years old.\"\n# Print\nprint( sentence % info)\n\n\nMy name is Bryn. I am 25 years old.\n\n\nWhen printing floats, the %f argument specifier can be accompanied by a number of decimal places to print only a certain number of digits.\n\n‚ñ∂Ô∏è Run the cell below.\n\n\n\nCode\nimport math\npi_sqrt = math.sqrt(math.pi)\nprint(\"The square root of pi is %f.\" % pi_sqrt)\nprint(\"The square root of pi is %.2f.\" % pi_sqrt)\n\n\nThe square root of pi is 1.772454.\nThe square root of pi is 1.77.\n\n\n\nüìö Practice 4. Rewrite your answers to practice questions 1a and 1b using formatted print statements. Each answer should include: 1. What you are solving for; 2. Your solution as an integer, float, and a float rounded to 3 decimal places; and 3. Units. For example:\n\nThe radius of the earth is 6,378 km.\n\nYou should have a total of 6 print statements.\n\n\n\nCode\n# Formatted print statement for 1a.\nprint('Solar constant = %d W m-2' % (int(g_s)))\nprint('Solar constant = %f W m-2' % (g_s))\nprint('Solar constant = %.3f W m-2' % (g_s))\n\n# Formatted print statement for 1b.\nprint(\"Temperature of the Earth's surface =  %d¬∞C\" % (int(T_e)))\nprint(\"Temperature of the Earth's surface =  %f¬∞C\" % (T_e))\nprint(\"Temperature of the Earth's surface =  %.3f¬∞C\" % (T_e))\n\n\nSolar constant = 1359 W m-2\nSolar constant = 1359.423263 W m-2\nSolar constant = 1359.423 W m-2\nTemperature of the Earth's surface =  -18¬∞C\nTemperature of the Earth's surface =  -18.641424¬∞C\nTemperature of the Earth's surface =  -18.641¬∞C\n\n\n\n\nRecall from Exercise 1.0 that the input() function allows for user input within a script or program. Importantly, when Python prompts the user for input, the input is stored as a string, regardless of what it is. Thus, if you write a function (a type of object we will explore in a future exercise) prompting the user for a number, you must be sure to convert the variable storing the input to an integer or float.\nTo demonstrate this, run the following cell, entering the month in which you were born in numerical format (e.g.¬†if you were born in April, your input would be 4) when prompted.\n\n‚ñ∂Ô∏è Run the cell below.\n\n\n\nCode\nmonth_in = input('Month of birth (1-12): ')\ntype(month_in)\n\n\nMonth of birth (1-12): 10\n\n\nstr\n\n\n\nüìö Practice 5. Following the example above, create a variable corresponding to the day on which you were born based on user input. Convert both variables to floats and assign the float versions to new variables. Lastly, use one of the boolean operators to evaluate which variable is greater ‚Äì the day or the month ‚Äì and print the result.\n\n\n\nCode\n# User input variable for day of birth\nday_in = input('Day of birth (1-31): ')\n# Convert birth day and month to floats.\nmonth = float(month_in)\nday = float(day_in)\n# Evaluate boolean operation + print result.\nprint(month > day)\n\n\nDay of birth (1-31): 11\nFalse\n\n\n\n\n\n\nCode\n# IGNORE THIS CELL\nfrom IPython.core.display import HTML\ndef css_styling():\n    styles = open(\"./styles/exercises.css\", \"r\").read()\n    return HTML(styles)\ncss_styling()"
  },
  {
    "objectID": "enumerate_and_zip.html#first-lets-make-three-short-lists-to-use-in-our-example",
    "href": "enumerate_and_zip.html#first-lets-make-three-short-lists-to-use-in-our-example",
    "title": "Enumerate and Zip",
    "section": "1. First, let‚Äôs make three short lists to use in our example:",
    "text": "1. First, let‚Äôs make three short lists to use in our example:\n\n\nCode\nlist_1 = ['a', 'b', 'c', 'd']\nlist_2 = [1, 2, 3, 4]\nlist_3 = ['i', 'j', 'k', 'l']"
  },
  {
    "objectID": "enumerate_and_zip.html#now-lets-see-what-happens-when-we-put-the-first-list-into-a-for-loop-using-enumerate",
    "href": "enumerate_and_zip.html#now-lets-see-what-happens-when-we-put-the-first-list-into-a-for-loop-using-enumerate",
    "title": "Enumerate and Zip",
    "section": "2. Now, let‚Äôs see what happens when we put the first list into a for loop using enumerate",
    "text": "2. Now, let‚Äôs see what happens when we put the first list into a for loop using enumerate\n\n\nCode\nfor stuff in enumerate(list_1):\n    print(stuff)\n\n\n\nü§î stuff contained two items each time the loop ran. The first item is the index into list_1 (the current position of the loop in the list) and the second item is the value of list_1 at that position."
  },
  {
    "objectID": "enumerate_and_zip.html#lets-alter-our-code-to-assign-each-of-these-items-separately-in-the-for-loop",
    "href": "enumerate_and_zip.html#lets-alter-our-code-to-assign-each-of-these-items-separately-in-the-for-loop",
    "title": "Enumerate and Zip",
    "section": "3. Let‚Äôs alter our code to assign each of these items separately in the for loop:",
    "text": "3. Let‚Äôs alter our code to assign each of these items separately in the for loop:\n\n\nCode\nfor i,value in enumerate(list_1):\n    print(i,value)\n\n\n\nüß† : Now that we have an ‚Äúindex‚Äù variable (i), we could grab the value of any item in any other list at the same position!"
  },
  {
    "objectID": "enumerate_and_zip.html#lets-grab-the-values-of-list_1-and-list_2-as-well.",
    "href": "enumerate_and_zip.html#lets-grab-the-values-of-list_1-and-list_2-as-well.",
    "title": "Enumerate and Zip",
    "section": "4. Let‚Äôs grab the values of list_1 and list_2 as well.",
    "text": "4. Let‚Äôs grab the values of list_1 and list_2 as well.\n\n\nCode\nfor i,value in enumerate(list_1):\n    print(i,value,list_2[i],list_3[i])"
  },
  {
    "objectID": "enumerate_and_zip.html#finally-instead-of-using-the-index-to-grab-items-outside-the-loop-we-can-use-zip-to-loop-through-all-of-these-lists-at-the-same-time",
    "href": "enumerate_and_zip.html#finally-instead-of-using-the-index-to-grab-items-outside-the-loop-we-can-use-zip-to-loop-through-all-of-these-lists-at-the-same-time",
    "title": "Enumerate and Zip",
    "section": "üß† üß† Finally, instead of using the index to ‚Äúgrab‚Äù items outside the loop, we can use zip to loop through all of these lists at the same time!",
    "text": "üß† üß† Finally, instead of using the index to ‚Äúgrab‚Äù items outside the loop, we can use zip to loop through all of these lists at the same time!\n\n\nCode\nfor stuff in zip(list_1, list_2, list_3):\n    print(stuff)\n\n\n\n\nCode\ndef f(x):\n    return x + 'stuff'\n\n# new_list = []\n# for value in list_1:\n#     new_list.append(f(value))\n    \n\nnew_list = [f(value) for value in list_1]\nprint(new_list)\n\n\n\n\nCode\nfor v in zip(list_1): #, list_2, list_3):\n    print(v)\n\n\n\n\n\nth-4165028533.jpeg"
  },
  {
    "objectID": "Exercise1-3_ControlFlowStatements.html",
    "href": "Exercise1-3_ControlFlowStatements.html",
    "title": "",
    "section": "",
    "text": "‚¨ÖÔ∏è Previous Exercise | üè† Index | ‚û°Ô∏è Next Exercise |"
  },
  {
    "objectID": "Exercise1-3_ControlFlowStatements.html#loops",
    "href": "Exercise1-3_ControlFlowStatements.html#loops",
    "title": "",
    "section": "Loops",
    "text": "Loops\n\n\n\nfor loops\nfor loops are the most commonly used type of loop and are extremely useful. for loops are used to iterate or loop through any object capable of returning its members one at time, i.e.¬†an iterable object.\n\nüêç <b>Note.</b>  The <b>iterator</b> in a <code>for</code> loop is a temporary variable used to store each value in the iterable object. The iterator is defined in the <code>for</code> loop syntax as follows:\nfor <ITERATOR> in <ITERABLE>:\n    do something to iterator\nThe name of the iterator should reflect the nature of the list. i is commonly used as an enumerator or counter variable and should be avoided for other uses.\n\nA generic counter for loop can be generated using the range() function.\nfor i in range(4):\n    print(i + 1)\n    \n>>> 1\n    2\n    3\n    4\nfor loops are commonly used to iterate through lists. As with the generic range() for loop, the iterator is assigned the next value from the list at the end of the indented code block.\nfor aa in aminoacids:\n    print(aa)\n    \n>>> histidine\n    isoleucine\n    leucine\n    lysine\n    methionine\n    phenylalanine\n    threonine\n    tryptophan\n    valine\n    alanine\n    arginine\n    asparagine\n    aspartate\n    cysteine\n    glutamate\n    glutamine\n    glycine\n    proline\n    serine\n    tyrosine\n\nüìö  <b> Practice 3. </b> \nGenerate a list called <code>org_elements</code> containing the names of the six most abundant elements comprising organic molecules. Sort the list in alphabetical order (in place) and write a <code>for</code> loop that prints each element in <code>org_elements</code>.\n\n\n\nCode\n# Define org_elements\n\n# Print each element in org_elements\n\n\n\n Built-in functions \n\nThe enumerate() function can be used in a for loop to keep track of the index of the iterator. This can be useful for keeping track of the number of iterations completed, accessing other elements in the same list based on their relative index (e.g.¬†the value immediately following the current iterator value), or accessing elements in another list based on the iterator‚Äôs index.\ngases = ['N2', 'O2', 'Ar', 'H2O', 'CO2']\n\nfor i,gas in enumerate(gases):\n    rank = i + 1\n    print('The #%d most abundant gas in the atmosphere is %s.' %(rank,gas))\n\n >>>  The #1 most abundant gas in the atmosphere is N2.\n\n\nThe #2 most abundant gas in the atmosphere is O2.\n\n\nThe #3 most abundant gas in the atmosphere is Ar.\n\n\nThe #4 most abundant gas in the atmosphere is H2O.\n\n\nThe #5 most abundant gas in the atmosphere is CO2.\n\n\n‚úèÔ∏è Try it. Given your sorted org_elements list and the corresponding list of atomic masses given in the cell below, use enumerate() in a for loop to print a formatted statement that expresses the atomic mass of of each element. Your formatted print statement should include the name of the element, the atomic mass rounded to 2 decimal places, and units.\n\n\n\nCode\n# Define list of atomic masses of 6 most abundant elements\natomic_mass = [12.011, 1.00784, 14.0067, 15.999, 30.97376, 32.065]  # g/mol\n\n# Iterate through org_elements + print the atomic mass of each element\n\n\nTo iterate through multiple lists at the same time without indexing, use the zip() function.\ngas_frac = [0.78084, 0.209476, 0.00934, 0.0025, 0.000314]\ngas_molar_mass = [14.0067, 15.999, 39.948, 18.01528, 44.01]\n\nmass_atmosphere = 5.148e21   # grams\nn_a = 6.022e23    # Avogadro's number\n\nfor frac,mol_mass in zip(gas_frac,gas_molar_mass):\n    mass = frac * mass_atmosphere\n    molecules = (mass / mol_mass ) * n_a\n    print(molecules)\n\n>>> 1.7282458205744395e+44\n    4.0590156271366957e+43\n    7.248215956743767e+41\n    4.302078013774973e+41\n    2.211859664621677e+40\nThe zip() function is nearly always used when each element of one list corresponds to an element in the same index position in another list. Therefore, it should mostly be used with two or more lists of the same length. If the lists do not have the same length, however, the number of iterations of the for loop will match the length of the shortest list.\n\n‚úèÔ∏è Try it. As in the previous example, print the atomic masses of each of the six most abundant elements in formatted print statements, this time using zip() to iterate through both org_elements and atomic_mass at the same time\n\nThe enumerate() and zip() functions can also be used together, if necessary, to keep track of the index position of iterators.\nfor i,(frac,mol_mass) in enumerate(zip(gas_frac,gas_molar_mass)):\n    gas = gases[i]\n    mass = frac * mass_atmosphere\n    molecules = (mass / mol_mass ) * n_a\n    print('There are ' + '{:.2e}'.format(molecules) + ' molecules of %s in the atmosphere.' % (gas))\n\n >>>  There are 1.73e+44 molecules of N2 in the atmosphere.\n\n\nThere are 4.06e+43 molecules of O2 in the atmosphere.\n\n\nThere are 7.25e+41 molecules of Ar in the atmosphere.\n\n\nThere are 4.30e+41 molecules of H2O in the atmosphere.\n\n\nThere are 2.21e+40 molecules of CO2 in the atmosphere.\n\n\n Nested for loops \n\nLike if statements, for loops can be nested to perform an operation multiple times for each iterator in the overall loop.\nfor aa in aminoacids:\n    vowels = 0\n    for letter in aa:\n        if letter in ['a', 'e', 'i', 'o', 'u']:\n            vowels = vowels + 1\n    print(aa.capitalize() + ' has ' + str(vowels) + ' vowels.')\n    \n>>> Histidine has 4 vowels.\n    Isoleucine has 6 vowels.\n    Leucine has 4 vowels.\n    Lysine has 2 vowels.\n    Methionine has 5 vowels.\n    Phenylalanine has 5 vowels.\n    Threonine has 4 vowels.\n    Tryptophan has 2 vowels.\n    Valine has 3 vowels.\n    Alanine has 4 vowels.\n    Arginine has 4 vowels.\n    Asparagine has 5 vowels.\n    Aspartate has 4 vowels.\n    Cysteine has 3 vowels.\n    Glutamate has 4 vowels.\n    Glutamine has 4 vowels.\n    Glycine has 2 vowels.\n    Proline has 3 vowels.\n    Serine has 3 vowels.\n    Tyrosine has 3 vowels.\n\nüìö  <b> Practice 4. </b> \nThe cell below contains four lists containing monthly global land-ocean surface temperature in ¬∞F for 2015, 2016, 2017, and 2018. Using  <code>enumerate()</code>, <code>zip()</code>, a nested <code>for</code> loop, or some combination of the three:\n\n\nCalculate the monthly global land-ocean surface temperature anomalies (deviation from the mean) in ¬∞C for 2015-2018. The mean global land-ocean surface temperature calculated over the 20th century was 15.6¬∞C.\n\n\nCreate a new list with the mean monthly global surface temperature anomalies in ¬∞C for 2015-2018 (i.e.¬†calculate the mean temperature anomaly for each month and put these values in a list). Use the command np.mean() to calculate mean values.\n\n\nPrint each monthly mean value with the name of the month and units.\n\n\n\n\n\nCode\n# Import numpy for mean calculations\nimport numpy as np\n\n# Lists of monthly global surface temperature in ¬∞F\ntempF_2015 = [61.538, 61.646, 61.7, 61.43, 61.43, 61.502, 61.358, 61.502, 61.556, 62.006, 61.934, 62.06]\ntempF_2016 = [62.15, 62.51, 62.438, 62.006, 61.718, 61.466, 61.556, 61.88, 61.664, 61.7, 61.718, 61.574]\ntempF_2017 = [61.844, 62.114, 62.114, 61.736, 61.682, 61.34, 61.556, 61.646, 61.448, 61.664, 61.628, 61.682]\ntempF_2018 = [61.466, 61.61, 61.718, 61.646, 61.538, 61.412, 61.484, 61.394, 61.448, 61.862, 61.484, 61.682]\n\n# List of yearly lists (may or may not be useful)\ntempC_list = [tempC_2015, tempC_2016, tempC_2017, tempC_2018]\n\n\n\n\n\n\n\nwhile loops\nwhile loops are used to repeatedly execute a block of code while a given condition is satisfied. The indented code block will be contiuously executed until the condition becomes False.\nx = 0\nwhile x < 4:\n    x = x + 1\n    print(x)\n>>> 1\n    2\n    3\n    4\nwhile loops are often used for user input, which allows the program to ‚Äústall,‚Äù repeatedly prompting the user until an acceptable answer is input.\n\n‚úèÔ∏è Try it. Run the following cell to see how a while loop works, inputing various answers that do not satisfy the condition before inputing the value that will end the loop.\n\n\n\nCode\n# Define a blank string variable\nuser_txt = \"\"\n# Wait for a specific answer, repeatedly asking for input until the condition is satisfied.\nwhile user_txt != \"42\":\n    user_txt = input(\"What is the answer to life, the universe, and everything? \")\n\n\n\nüêç <b>Note.</b> <code>while</code> loops can be infinite, so they should be used very judiciously. For example, imagine if instead of <code>x = x + 1</code> in the previous example, the code block executed in the <code>while</code> loop were <code>x = x - 1</code>:\nx = 0\nwhile x < 4:\n    x = x - 1\n    print(x)\n>>> -1\n    -2\n    -3\n    -4\n    -5\n    -6\n    ... # and so on\nThis loop would never stop executing because the condition can never be met.\n\n\n\n\n\nEscaping loops\nSometimes it is necessary to terminate a loop iteration or the loop itself. The break and continue statements are used to escape loops.\nbreak statements in Python are used to escape an entire loop based on a condition. In nested loops, a break will only exit out of one level.\n\n\n\nbreak_chart\n\n\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\nwhile True:\n    print(\"What is the answer to life, the universe, and everything? \")\n    option = input(\"   Your answer: \")\n    if option.isdigit():\n        if int(option) == 42:\n            print('You have solved the ultimate question.')\n            break\n        else:\n            print(\"Nope. Try again...\\n\")\n    else:\n        print(\"Nope. Try again...\\n\")\n\n\ncontinue statements are used to skip the remainder of the loop for a given iteration.\n\n\n\ncontinue_chart\n\n\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\nfor x in [47, 22.5342, 'four hundred eighty-two', 0, 72104, -932.14, 6, -23, 'eleven']:\n    # Check to see if value is a string\n    if type(x) == str:\n        # If so, skip to next iteration\n        continue\n    # Otherwise, divide by 2 and print\n    print(x/2)\n\n\n\n\n\n\nList comprehensions\nA list comprehension is a quick, concise way to generate a list. They are generally used to condense the generation of a list from a simple expression into one line of code.\nFor example, say you wanted a list of all the squares from 0 and 100. As we learned in Exercise 1.2, this could be accomplished as follows:\nsquares = []\n\nfor x in range(11):\n    squares.append(x**2)\n\nprint(squares)\n>>> squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\nUsing a list comprehension, the same list could be generated in a single line of code as follows:\nsquares = [x**2 for x in range(11)]\n\nprint(squares)\n>>> squares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\nList comprehensions are often combined with if statements. For example, the following line of code creates a list of all even numbers from 0 to 100.\nevens = [x for x in range(101) if x%2 == 0]\n\nprint(evens)\n>>> evens = [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, \n               22, 24, 26, 28, 30, 32, 34, 36, 38, 40,\n               42, 44, 46, 48, 50, 52, 54, 56, 58, 60, \n               62, 64, 66, 68, 70, 72, 74, 76, 78, 80, \n               82, 84, 86, 88, 90, 92, 94, 96, 98]\n\nüìö  <b> Practice 5. </b> \nUse a list comprehension to generate a list of all even squares from 0 to 1000.\n\n\n\n\n\nCode\nfrom IPython.core.display import HTML\ndef css_styling():\n    styles = open(\"./styles/exercises.css\", \"r\").read()\n    return HTML(styles)\ncss_styling()"
  },
  {
    "objectID": "Exercise1-4_Structured-Data.html",
    "href": "Exercise1-4_Structured-Data.html",
    "title": "",
    "section": "",
    "text": "‚¨ÖÔ∏è Previous Exercise | üè† Index | ‚û°Ô∏è Next Exercise |"
  },
  {
    "objectID": "Exercise1-4_Structured-Data.html#dictionaries",
    "href": "Exercise1-4_Structured-Data.html#dictionaries",
    "title": "",
    "section": "1. Dictionaries ",
    "text": "1. Dictionaries \n\nTLDR: Dictionaries are a very common collection type that allows data to be organized using a key:value framework. Because of the similarity between key:value pairs and many data structures (e.g.¬†‚Äúlookup tables‚Äù), you will see Dictionaries quite a bit when working in python\n\nThe first collection we will look at today is the dictionary, or dict. This is one of the most powerful data structures in python. It is a mutable, unordered collection, which means that it can be altered, but elements within the structure cannot be referenced by their position and they cannot be sorted. Instead, the dictionary stores elements using keys, which are labels associated with each value in the dictionary. Using the analogy of an actual dictionary, the words of a dictionary would form the keys, while the definitions would be the values. Similarly, using the same analogy, we need to always remember that in Python, dictionaries can‚Äôt be sorted!\nYou can create a dictionary using the {}, providing both a key and a value, which are separated by a :.\nenvironmental_disciplines = {\n    'ecology':'The relationships between organisms and their environments.',\n    'hydrology':'The properties, distribution & effects of water on the surface, subsurface, & atmosphere.',\n    'geology':'The origin, history, and structure of the earth.',\n    'meteorology':'The phenomena of the atmosphere, especially weather and weather conditions.'\n    }\n\nüêç <b>Note.</b> The use of whitespace and indentation is important in python. In the example above, the dictionary entries are indented relative to the brackets <code>{</code> and <code>}</code>. In addition, there is no space between the <code>'key'</code>, the <code>:</code>, and the <code>'value'</code> for each entry. Finally, notice that there is a <code>,</code> following each dictionary entry. This pattern is the same as all of the other <i>collection</i> data types we've seen so far, including <b>list</b>, <b>set</b>, and <b>tuple</b>.\n\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\nenvironmental_disciplines = {\n    'ecology':'The relationships between organisms and their environments.',\n    'hydrology':'The properties, distribution & effects of water on the surface, subsurface, & atmosphere.',\n    'geology':'The origin, history, and structure of the earth.',\n    'meteorology':'The phenomena of the atmosphere, especially weather and weather conditions.'\n}\n\n\n\nAccessing elements in Dictionaries\nAccess an element in a dictionary is easy if you know what you are looking for. For example, if I want to know the definition of ecology, I can simply retireve the value of this defition using the key as my index into the dictionary:\nenvironmental_disciplines['ecology']\n>>> 'The relationships between organisms and their environments.'\n\n‚úèÔ∏è <b> Try it. </b> \nTry accessing the some of the definitions in the <code>environmental_disciplines</code> dictionary.\n\n\n\nCode\nenvironmental_disciplines['ecology']\n\n\n'The relationships between organisms and their environments.'\n\n\nBecause dictionaries are mutable, it is easy to add additional entries. This is done using the following notation:\n    environmental_discplines['geomorphology'] =  'The evolution and configuration of landforms.'\n\n‚úèÔ∏è <b> Try it. </b> \n<b>Biogeochemistry</b> is defined as <b>\"the chemical, physical, geological, and biological processes and reactions that govern the composition of the natural environment.\"</b> Add this discpline to the dictionary <code>environmental_disciplines</code>.\n\n\n\nCode\nenvironmental_disciplines['biogeochemistry'] = 'the chemical, physical, geological, and biological processes and reactions that govern the composition of the natural environment.'\nprint(environmental_disciplines['biogeochemistry'])\n\n\nthe chemical, physical, geological, and biological processes and reactions that govern the composition of the natural environment.\n\n\n\n\nAccessing dictionary keys and values\nEvery dictionary has builtin methods to retrieve its keys and values. These functions are called, appropriately, keys() and values()\n\ndisciplines = environmental_disciplines.keys()\nprint(disciplines)\n>>> dict_keys(['ecology', 'hydrology', 'geology', 'meteorology', 'biogeochemistry'])\n\ndefinitions = environmental_disciplines.values()\nprint(definitions)\n>>> dict_values(\n    ['The relationships between organisms and their environments.', \n     'The properties, distribution & effects of water on the surface, subsurface, & atmosphere.', \n     'The origin, history, and structure of the earth.', \n     'The phenomena of the atmosphere, especially weather and weather conditions.', \n     'The chemical, physical, geological, and biological processes and reactions that govern the composition of the natural environment.'])\n\nüêç <b>Note.</b> The <code>keys()</code> and <code>values()</code> functions return a <code>dict_key</code> object and <code>dict_values</code> object, respectively. Each of these objects contains a <b>list</b> of either the keys or values. You can force the result of the <code>keys()</code> or <code>values()</code> function into a <b>list</b> by wrapping either one in a <code>list()</code> command. For example: <code>key_list = list(environmental_disciplines.keys())</code> will return a <b>list</b> of the keys in <code>environmental_disciplines</code>\n\n\n\nCode\nfor key, value in environmental_disciplines.items():\n    print(key, value)\n    environmental_disciplines[key] = value.capitalize()\n\n\necology The relationships between organisms and their environments.\nhydrology The properties, distribution & effects of water on the surface, subsurface, & atmosphere.\ngeology The origin, history, and structure of the earth.\nmeteorology The phenomena of the atmosphere, especially weather and weather conditions.\n\n\n\n\nLooping through Dictionaries\nPython has an efficient way to loop through all the keys and values of a dictionary at the same time. The items() method returns a tuple containing a (key, value) for each element in a dictionary. In practice this means that we can loop through a dictionary in the following way:\nmy_dict = {'name': 'Homer Simpson',\n           'occupation': 'Nuclear Engineer',\n           'address': '742 Evergreen Terrace',\n           'city': 'Springfield',\n           'state': ' ? '\n          }\n\nfor key, value in my_dict.items():\n    print(f\"{key.capitalize()}: {value}.\")\n\n\n>>> Name: Homer Simpson.\n    Occupation: Nuclear Engineer.\n    Address: 742 Evergreen Terrace.\n    City: Springfield.\n    State:  ? .\n\n‚úèÔ∏è <b> Try it. </b> \nLoop through the <code>environmental_disciplines</code> dictionary and print out a sentence providing the definition of each subject (e.g. \"Ecology is the study of....\").\n\n\n\nCode\na = {\n    'one': 1,\n    'one': 2,\n    'one': 3\n}\n\n\n{'one': 3}\n\n\n\n\nCode\na = {\n    'Santa Barbara' : {\n        'Temp': 3,\n        'b_key_2': 'b_value_2'\n    },\n    'a_key_2' : {\n        'c_key_1': 'c_value_1',\n        'c_key_2': 'c_value_2'\n    }\n}\n\na['Santa Barbara']['Temp']\n\n# for key, value in a.items():\n#     for key_2, value_2 in value.items():\n#         print(key_2, value_2)\n\n\n3"
  },
  {
    "objectID": "Exercise1-4_Structured-Data.html#sets",
    "href": "Exercise1-4_Structured-Data.html#sets",
    "title": "",
    "section": "2. Sets",
    "text": "2. Sets\n\nTLDR: Sets are useful for comparing groups of items to determine their overlap or their differences. Sometimes used in data science, but rarely when working with large datasets.\n\nSets are another collection data type. As opposed to a list or tuple, a set is not a sequence. Although a set is iterable (like the sequences you‚Äôve already met), a set is an unordered collection data type, which means it is not a sequence. However, a set is mutable, which means - like a list - it can be modified after being created. Finally - and most uniquely - a set has no duplicate elements. In this sense, a set in python is very much like a mathematical set.\nWe‚Äôve seen that a list is implemented using [], while a tuple is implemented using (). A set is implemented using {}:\nnum_set = {1, 3, 6, 10, 15, 21, 28}\nstr_set = {'hydrology', 'ecology', 'geology', 'climatology'}\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\n# Define set variables\nnum_set = {1, 3, 6, 10, 15, 21, 28}\nstr_set = {'hydrology', 'ecology', 'geology', 'climatology'}\n\n\nAs with all other collections, you can also create a set using the set() function:\nnum_set = set([1, 3, 6, 10, 15, 21, 28, 45, 45, 45, 45, 45])\n\n‚úèÔ∏è <b> Try it. </b> \nUse the <code>set()</code> function to create a set containing the first four prime numbers.\n\n\n\nCode\nnum_set = set([1, 3, 6, 10, 15, 3, 10, 21, 28])\nprint(num_set)\n\n\n{1, 3, 6, 10, 15, 21, 28}\n\n\n\nMutability\nSets are mutable.\nTo remove an element from a set, use the discard() method:\n\nstr_set.discard('ecology')\n    \nTo add an element from to set, use the add() method:\n\nstr_set.add('oceanography')\n    \nTo add multiple elements to a set at the same time, use the update() method. The items to add should be contained in a list.\n\nstr_set.update(['oceanography', 'microbiology'])\n    \n\nüìö  <b> Practice 2. </b> \nAdd <code>'biogeochemistry'</code> and <code>'meteorology'</code> to <code>str_set</code> and then remove <code>'ecology'</code>.\n\nMany of the same functions that worked on list and tuple also work for a set.\nlen(str_set)\n>>> 4\nThe min() and max() commands can also be used to find the minimum and maximum values in a tuple. For a tuple of strings, this corresponds to the alphabetically first and last elements.\nmin(str_set)\n>>> 'climatology'\n\nmax(str_tuple)\n>>> 'oceanography'\n\n‚úèÔ∏è <b> Try it. </b> \nUse the <code>len()</code>, <code>min()</code>, and <code>max()</code> commands to find the length, minimum, and maximum of <code>num_set</code>.\n\n\n\nMixed Data Types in Collections and Sequences\nAs a reminder, it‚Äôs usually a good idea to make sure your sets are all of the same basic data type. The reason is because Python doesn‚Äôt know how to compare the magnitude of different data types.\nWhich is larger: ecology, or the number 3? Python doesn‚Äôt know the answer, and neither do I. If you try to use functions like max or min on a mixed data type set you will get a TypeError exception.\n\nmixed_set = {3, 4, 'ecology', 'biology'}\nmax(mixed_set)\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n<ipython-input-49-a4da84ba3cd4> in <module>\n      1 mixed_set = {3, 4, 'ecology', 'biology'}\n----> 2 max(mixed_set)\n\nTypeError: '>' not supported between instances of 'int' and 'str'\n\n\nSet Methods\nGiven their similarity to mathematical sets, there are some specific functions that allow us to compare and combine the contents of different sets.\n\nUnion\nA union of sets contains all the items that are in any of the sets.\nThe union of sets A and B is defined as $ A B $.\n\n\n\nimage\n\n\nodds = {1, 3, 5, 7, 9, 11, 13, 15}\nevens = {2, 4, 6, 8, 10, 12, 14, 16}\n\nintegers = odds.union(evens)\nprint(integers)\n\n>>> {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16}\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\nknows_python = {'Bart', 'Maggie', 'Homer', 'Lisa', 'Professor Frink', 'Nelson'}\nknows_R = {'Homer', 'Nelson', 'Lisa', 'Marge', 'Ralph', 'Milhouse', 'Ms. Krabappel'}\n\n\n\n\nIntersection\nAn intersection of sets contains all the items that are found in all of the sets.\nThe intersection of sets A and B is defined as $ A B $.\n\n\n\nimage\n\n\n\nsquares = {4, 9, 16, 25, 36, 49}\nmultiples_of_nine = {9, 18, 27, 36, 45}\n\nsquares_divisible_by_nine = squares.intersection(multiples_of_nine)\nprint(squares_divisible_by_nine)\n\n>>> {9, 36}\n\n‚úèÔ∏è <b> Try it. </b> \nUse the <code>intersection()</code> method to determine who knows both `python` and `R`.\n\n\n\nCode\n# knows_both = \n\n\n\n\nDifference\nAn difference of two sets contains all the items that are in A but not in B.\nThe difference (or relative complement) of set A and B is defined as $ A B $.\n\n\n\nimage\n\n\n\nsquares = {4, 9, 16, 25, 36, 49}\nmultiples_of_nine = {9, 18, 27, 36, 45}\n\nsquares_not_divisible_by_nine = squares.difference(multiples_of_nine)\nprint(squares_not_divisible_by_nine)\n\n>>> {16, 49, 4, 25}\n\nüêç <b>Note.</b> Because a <b>set</b> is an <i>unordered</i> collection, the result of a set function will return elements in an unpredictable order. In the example above, the intersection returned `{16, 49, 4, 25}` rather than `{4, 16, 25, 49}`, which you may have expected.\n\n\n‚úèÔ∏è <b> Try it. </b> \nUse the <code>difference()</code> method to determine who knows <b>R</b>, but does not know <b>Python</b>.\n\n\n\nSymmetric Difference\nThis method returns all the items that are unique to each set.\nThe symmetric difference (or disjunctive union) of sets A and B is A \\triangle B (also sometimes written as A \\oplus B)\n\n\n\nimage\n\n\n\nsquares = {4, 9, 16, 25, 36, 49}\nmultiples_of_nine = {9, 18, 27, 36, 45}\n\nsquares_not_divisible_by_nine = squares.symmetric_difference(multiples_of_nine)\nprint(squares_not_divisible_by_nine)\n\n>>> {16, 49, 18, 4, 25, 27, 45}\n\n‚úèÔ∏è <b> Try it. </b> \nUse the <code>symmetric_difference()</code> method to determine who only knows <i>either</i> R or Python.\n\n\n\n\nAdditional Set Methods: isdisjoint(), issubset(), issuperset()\nThere are three additional set functions that allow you to determine the relationships between two sets. Each of these functions returns either True or False, which means they are Boolean operators.\nisdisjoint() determines if two sets are disjoint. It returns True if the contents of two sets are completely distinct, and False if they have any overlap\nodds.isdisjoint(evens)\n>>> True\n\nüêç <b>Note.</b> Set <i>A</i> is <b>disjoint</b> from set <i>B</i> if, and only if, the <b>intersection</b> of <i>A</i> and <i>B</i> is <code>None</code>.\n\nissubset() returns True if the content of set A is a subset of set B, and False if it is not a subset.\n\nprimes = {1, 3, 5, 7, 11}\nprimes.issubset(odds)\n>>> True\n\nüêç <b>Note.</b> Set <i>A</i> is a <b>subset</b> of set <i>B</i> if, and only if, the <b>intersection</b> of <i>A</i> and <i>B</i> is <i>A</i>.\n\nissupserset() returns True if the content of set A is a superset of set B, and False if it is not a superset.\n\nodds.issuperset(primes)\n>>> True\n\nüêç <b>Note.</b> Set <i>A</i> is a <b>superset</b> of set <i>B</i> if, and only if, set <i>B</i> is a subset of <i>A</i>.\n\n\n\nAccessing un-assigned elements in Dictionaries\nAttempting to retrieve an element of a dictionary that doesn‚Äôt exist is the same as requesting an index of a list that doesn‚Äôt exist - Python will raise an Exception. For example, if I attempt to retrieve the definition of a field that hasn‚Äôt been defined, then I get an error.\nenvironmental_disciplines['xenohydrology']\n\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\n<ipython-input-46-d4d91bf18209> in <module>\n----> 1 environmental_disciplines['xenohydrology']\n\nKeyError: 'xenohydrology'\nWhile it‚Äôs easy to determine what indicies are in a list using the len() command, it‚Äôs sometimes hard to know what elements are in a dict (but we‚Äôll learn how soon!). Regardless, to avoid getting an error when requesting an element from a dict, you can use the get() function. The get() function will return None if the element doesn‚Äôt exist:\nunknown_definition = environmental_disciplines.get('xenohydrology')\nprint(unknown_definition)\n>>> None\nThe get() function will also allow you to pass an additional argument. This additional argument specifies a ‚Äúdefault‚Äù value which will be returned for any undefined elements:\nenvironmental_disciplines.get('xenohydrology', 'Discipline not defined.')\n>>> 'Discipline not defined.'\nlist_of_disciplines = ['climatology', 'ecology', 'meteorology', 'geology', 'biogeochemistry']\n\nüìö  <b> Practice 4. </b> \nUsing the list of discplines given above, write a <code>for</code> loop that either prints the definition of the discipline, or prints 'Discipline not defined.'\n\nThere is a lot more to learn about dictionaries, including methods for deleting elements, merging dictionaries, and learning about additional collection types like OrderedDict that allow you to preserve the arrangement of dictionary elements (essentially making them sequences). We will keep coming back to them throughout the class. If you want to learn more, check out the great material in our reading: Dictionaries"
  },
  {
    "objectID": "Exercise1-4_Structured-Data.html#tuples",
    "href": "Exercise1-4_Structured-Data.html#tuples",
    "title": "",
    "section": "3. Tuples ",
    "text": "3. Tuples \n\nTLDR: Tuples are a kind of list that can‚Äôt be altered. They are not very common in data science applications, but you might run across them from time to time. ‚ÄúNamed Tuples‚Äù allow for the creation of simple structured data ‚Äúobjects‚Äù that don‚Äôt require much coding overhead.\n\nTuples are a type of sequence, similar to list, which you‚Äôve already seen. They primary difference between a tuple and a list is that a tuple is immutable, which means that it‚Äôs value cannot be changed once it is defined. A tuple is implemented using ():\nnum_tuple = (4, 23, 654, 2, 0, -12, 4391)\nstr_tuple = ('energy', 'water', 'carbon')\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\n# Define tuple variables\nnum_tuple = (4, 23, 654, 2, 0, -12, 4391)\nstr_tuple = ('energy', 'water', 'carbon')\n\n\nAs with a list, a tuple may contain mixed data types, but this is not usually recommended.\nBecause they are both sequences, tuples and lists share many of the same methods. For example, just like lists, the len() command returns the length of the tuple.\nlen(str_tuple)\n>>> 3\nThe min() and max() commands can also be used to find the minimum and maximum values in a tuple. For a tuple of strings, this corresponds to the alphabetically first and last elements.\nmin(str_tuple)\n>>> 'carbon'\n\nmax(str_tuple)\n>>> 'water'\n\n‚úèÔ∏è <b> Try it. </b> \nUse the <code>len()</code>, <code>min()</code>, and <code>max()</code> commands to find the length, minimum, and maximum of <code>num_tuple</code>.\n\n\n\nCode\n# Find the length of num_tuple\n\n# Minimum value of num_tuple\n\n# Maximum value of num_tuple\n\n\n\n\n\nOther ways to create tuples\nTuples can also be constructed by:\n\n\nUsing a pair of parentheses to indicate an empty tuple: ()\n\nUsing a trailing comma for a tuple with a single element: a, or (a,)\n\nSeparating items with commas: a, b, c or (a, b, c)\n\nusing the tuple() built-in function: tuple(iterable).\n\n\nüêç <b>Note.</b> An <i>iterable</i> is any object that is capable of returning its contents one at a time. Strings are iterable objects, so <code>tuple('abc')</code> returns <code>('a', 'b', 'c')</code>.\n\ntuple('earth')\n>>> ('e', 'a', 'r', 't', 'h')\n\nüìö  <b> Practice 1. </b> \nCreate three separate <b>tuples</b> containing the latitude and longitudes of the following cities: \n\nLos Angeles, CA (34.05, -118.25)\nJohannesburg, South Africa (-26.20, 28.05)\nCairo, Egypt (30.03, 31.23)\nCreate a fourth tuple that is made up of the three tuples (i.e.¬†a ‚Äútuple of tuples‚Äù).\n\n\n\n\nCode\n# Define a three new tuples, one for each city.\n\n# los_angeles = \n\n# johannesburg = \n\n# singapore = \n\n# Create a new tuple that is a tuple made up of the three city location tuples:\n# tuple_of_tuples = \n\n\n\n\nIndexing \nAs you learned with lists, any element of a sequence data type can be referenced by its position within the sequence. To access an element in a sequence by its index, use square brackets [].\nIndividual elements of tuples are accessed in the exact same manner as lists:\nnum_tuple[0]\n>>> 4\nnum_tuple[-2]\n>>> -12\nword_tuple = tuple('antidisestablishmentarianism')\n\nword_tuple[14]\n>>> 's'\n\nword_tuple[::3]\n>>> 'aistlhnrnm'\n\n‚úèÔ∏è <b> Try it. </b> \nUse indexing to create a new tuple from the 2nd element in <code>str_tuple</code>. Find the 3rd element of this new tuple.\n\n\n\nCode\n# new_tuple = \n\n# 3rd element of new_tuple:\n\n\n\n\n\n\nImmutability \nAll objects in python are either mutable or immutable. A mutable object is one whose value can change. In contrast, an immutable object has a fixed value. You‚Äôve already been introduced to a few immutable objects including numbers, strings and now, tuples. These objects cannot be altered once created.\n\nüêç <b>Note.</b>  If you attempt to modify the value of an existing tuple, you will get a <code>TypeError</code> exception from the Python interpreter.\n\nnum_tuple[0] = 3\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n<ipython-input> in <module>\n----> 1 num_tuple[0] = 1\n\nTypeError: 'tuple' object does not support item assignment\n    \n\n\n\n\nTuple Operations \nBecause they are immutable, tuples do not have the same robust set of functions that lists have. Attempting to change a tuple (for example, by trying to append elements) will raise an AttributeError, because the append method isn‚Äôt available to tuple objects.\n\ntuple_of_colors = ('red', 'blue', 'green', 'black', 'white')\ntuple_of_colors.append('pink') # <- UH-OH!\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\n<ipython-input-8-857308f688f6> in <module>\n----> 1 tuple_of_colors.append('pink')\n\nAttributeError: 'tuple' object has no attribute 'append'\nInstead of appending data to an existing tuple, when you want to change the contents of a tuple, you need to either create a new one, or modify the variable by re-defining it.\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\ntuple_of_colors = ('red', 'blue', 'green', 'black', 'white')\ntuple_of_colors = tuple_of_colors + ('pink',)\nprint(tuple_of_colors)\n\n\n\n\n\n\nOPTIONAL: DIVING DEEPER: Named Tuples (Python 3.6+) \nTuples are convenient for storing information that you do not want to change. However, remembering which index should be used for each value can lead to errors, especially if the tuple has a lot of fields and is constructed far from where it is used.\nAs an example, we created the coordinate location of Cairo, Egypt as:\ncairo_location = (30.03, 31.23)\nBut wait‚Ä¶ Are those coordinates stored (latitude, longitude) or (longitude, latitude)? You might think it is easy to sort this out for most cities, but for Cairo it‚Äôs really difficult!\nPython has an additional immutable collection data type called a namedtuple which assigns names, as well as the numerical index, to each member. The namedtuple is part of the standard python library but it is not immediately available. In order to use the namedtuple data type, you first need to import it to your working environment. We will be using the import command quite a bit in order to extend what python can do and take advantage of all the tools that people have developed for environmental data science. For now, we need to import namedtuple from the collections library within python. The code for that looks like this:\nfrom collections import namedtuple\nOnce we import the namedtuple, we can create a new kind of custom data type that we can use to store our locations:\nLocation = namedtuple('Location', ['latitude', 'longitude'])\nIn the code above, the first argument to the namedtuple function is the name of the new tuple object type you want to create. We called this new object type a Location. The second argument is a list of the field names that the Location objects will have. In general, Location objects on Earth are defined by two pieces of information: the latitude and the longitude.\nNow that we‚Äôve defined this new Location object type, we can create a new Location object using this code:\ncairo_location = Location(latitude=30.03, longitude=31.23)\nNote that this code isn‚Äôt that different than the code we used to make a tuple:\ncairo_location = tuple(30.03, 31.23)\nThe difference is that we are using our custom namedtuple type called Location, and we are able to specify exactly which values correspond to the latitude and longitude fields. We can retrieve any field in our Location tuple by specifying the field:\ncairo_location.latitude\n>>> 30.03\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\nfrom collections import namedtuple\n\nLocation = namedtuple('Location', ['latitude', 'longitude'])\ncairo_location = Location(latitude=30.03, longitude=31.23)\ncairo_location.latitude, cairo_location.longitude\n\n\n\n\nCode\nfrom IPython.core.display import HTML\ndef css_styling():\n    styles = open(\"./styles/exercises.css\", \"r\").read()\n\ncss_styling()"
  },
  {
    "objectID": "Lab-2_Energy_Balance.html#shortwave-radiation",
    "href": "Lab-2_Energy_Balance.html#shortwave-radiation",
    "title": "",
    "section": "2.1. Shortwave radiation",
    "text": "2.1. Shortwave radiation\nThe vast majority of energy entering the Earth‚Äôs atmosphere is shortwave radiation from the sun, R^{\\ \\downarrow}_{_{SW}}, and falls in the ultraviolet, visible, and infrared portions of the electromagnetic spectrum. As we saw in Exercise 1.1, the flux density of the sun‚Äôs energy at the Earth‚Äôs atmosphere, known as the solar constant, is about 1370 W m-2. This is the maximum value of R^{\\downarrow}_{_{SW}}, but this quantity can fluctuate based on seasonal and diurnal geometry, attenuation by the atmosphere, and the amount of clouds and aerosols in the atmosphere. Of the solar radiation that does pass through the atmosphere, about 30% is reflected by the Earth‚Äôs surface, leading to outgoing shortwave radiation, R^{\\uparrow}_{_{SW}}. The ratio of reflected to incoming shortwave radiation is known as albedo, \\alpha.\n\\begin{equation}\n\\tag{2.2}\n    \\alpha \\ = \\ \\frac{R^{\\uparrow}_{_{SW}}}{R^{\\downarrow}_{_{SW}}}\n\\end{equation}\nBecause ~30% of incoming solar radiation is reflected on average, the Earth‚Äôs average global albedo is 0.3. This value varies between 0 and 1, however, based on the surface. Dark objects like asphalt absorb most of the incident radiation causing them to have a very low albedo. In contrast, light objects like freshly fallen snow have an albedo close to 1 as they reflect nearly all incident energy.\nUsing Equation 2.2, we can write the net shortwave radiation (i.e.¬†the difference between incoming and outgoing shortwave radiation) as\n\\begin{equation}\n\\tag{2.3}\n    R^{\\downarrow}_{_{SW}} \\ - \\ R^{\\uparrow}_{_{SW}} \\ = \\ (1 \\ - \\ \\alpha) R^{\\downarrow}_{_{SW}}\n\\end{equation}"
  },
  {
    "objectID": "Lab-2_Energy_Balance.html#longwave-radiation",
    "href": "Lab-2_Energy_Balance.html#longwave-radiation",
    "title": "",
    "section": "2.2. Longwave radiation",
    "text": "2.2. Longwave radiation\nSome incoming solar radiation is absorbed by larger particles in the Earth‚Äôs atmosphere, causing the atmosphere to warm. The heat generated by this absorption is emitted in the far infrared portion of the elecromagnetic spectrum, some of which radiates to the surface to produce incoming longwave radiation, R^{\\downarrow}_{_{LW}}. The value of R^{\\downarrow}_{_{LW}} varies depending on the temperature profile of the atmosphere and the amount of water vapor and other particles present. As the surface of the Earth heats up, thermal energy is re-emitted as outgoing longwave radiation, R^{\\uparrow}_{_{LW}}. This quantity depends on the temperature and emissivity of the surface, \\varepsilon. Both incoming and outgoing longwave radiation can be calculated from the Stefan-Boltzmann law, which describes the energy emitted from an object in terms of its temperature:\n\\begin{equation}\n\\tag{2.4}\n    j^* \\ = \\ \\varepsilon \\sigma T^{4}\n\\end{equation}\nwhere \\sigma is the Stefan-Boltzman constant with a value of 5.67 \\times 10^{-8} \\text{ W m}^{-2} \\text{ K}^{-4}.\nThus, we can rewrite Equation 2.1 to express net radiation in terms of these relationships in Equations 2.3 and 2.4:\n\\begin{equation}\n\\tag{2.5}\n    R^{}_{n} \\ = \\ (1-\\alpha) \\ R^{\\downarrow}_{_{SW}} \\ + \\ \\varepsilon_a \\sigma {T^{}_{a}}^{4} \\ - \\ \\varepsilon_s \\sigma {T^{}_{s}}^{4}\n\\end{equation}\nwhere \\varepsilon_a and \\varepsilon_s are the emissivities and T_a and T_s are the temperatures (in Kelvin) of the air and the surface, respectively.\nThe sum of the incoming shortwave radiation (corrected for albedo) and incoming longwave radiation represents the total energy available to the system, Q_{av}. We can rewrite Equation 2.5 in terms of available energy:\n\\begin{equation}\n\\tag{2.6}\n    Q_{av} \\ = \\ (1-\\alpha) \\ R^{\\downarrow}_{_{SW}} \\ + \\ \\varepsilon_a \\sigma {T^{}_{a}}^{4} \\ = \\ R^{\\downarrow}_{_{SW}} \\, - \\, R^{\\uparrow}_{_{SW}} \\, + \\, R^{\\downarrow}_{_{LW}}  \\ = \\varepsilon_s \\sigma {T^{}_{s}}^{4}\n\\end{equation}"
  },
  {
    "objectID": "Lab-2_Energy_Balance.html#problems",
    "href": "Lab-2_Energy_Balance.html#problems",
    "title": "",
    "section": "Problems",
    "text": "Problems\n\n2.1. Determine the albedo of the landscape.\n\nüìö  <b> Question 2.1. </b> \nCalculate daily albedo values using the average daily $R^{\\downarrow}_{_{SW}}$ and $R^{\\uparrow}_{_{SW}}$ values. What is the mean daily albedo of the landscape over the entire dataset?\n\n\n\n2.2. Estimate the surface temperature of the earth from Q_{av}\n\nüìö  <b> Question 2.2. </b> \nCalculate $Q_{av}$ from $R^{\\downarrow}_{_{SW}}$, $R^{\\uparrow}_{_{SW}}$, and $R^{\\downarrow}_{_{LW}}$. Using the mean value of $Q_{av}$ over the entire dataset, use Equation 2.6 to calculate the apparent surface temperature of the earth, $T_s$, in both $^{\\circ}$C and $^{\\circ}$F assuming all of the available energy is used to heat the surface. Assume the surface has the same emissivity as the atmosphere, $\\varepsilon_s \\ = \\ 0.95$.\n\n\n\n2.3. Net radiation\nNow, calculate the actual net radiation from the dataset.\n\nüìö  <b> Question 2.3. </b> \nUse Equation 2.1 and the actual values of outgoing longwave radiation to calculate net radiation. Plot net radiation from August to December for 2016 and 2019 on the same plot (Hint: use <code>rad.index.dayofyear</code> on the x-axis to display the time series on top of one another). Label your plot appropriately.\n\n\n\n2.4. Diurnal radiation\nNext, let‚Äôs look at the diurnal variation in radiation values. Pick a single day of your choosing and plot all four components of radiation, as well as net radiation. You can use a boolean mask on your DataFrame to select a single date. For instance, to select the 11th of October 2019:\nrad[rad.index.date == datetime.date(2019,10,11)]\n\nüìö  <b> Question 2.4. </b> \nPlot net radiation, as well as its four components, over the course of your chosen day. Which component is the largest? When is $R_n$ at its highest during the day? Its lowest? As always, be sure to label your plot appropriately."
  },
  {
    "objectID": "Lab-2_Energy_Balance.html#ground-heat-flux",
    "href": "Lab-2_Energy_Balance.html#ground-heat-flux",
    "title": "",
    "section": "3.1. Ground Heat Flux",
    "text": "3.1. Ground Heat Flux\nThe transfer of energy between two materials in contact with one another is known as conduction. Conduction is driven by temperature gradients between the two surfaces. In the Earth system context, thermal conduction of heat into the soil is quantified by the ground heat flux, G. In most landscapes, very little energy is stored in the ground, so G is often ignored in the landscape energy balance."
  },
  {
    "objectID": "Lab-2_Energy_Balance.html#sensible-heat-flux",
    "href": "Lab-2_Energy_Balance.html#sensible-heat-flux",
    "title": "",
    "section": "3.2. Sensible Heat Flux üå°Ô∏è",
    "text": "3.2. Sensible Heat Flux üå°Ô∏è\nSensible heat flux, H, refers to the loss of energy from the surface to the atmosphere via convection. Like conduction, convection is driven by differences in temperature, but this time between the surface and the air. That is,\n\\begin{equation}\n\\tag{3.2}\n    H \\ \\propto \\ T_s - T_a\n\\end{equation}\nThis proportionality between sensible heat flux and the temperature difference is determined by the properties of the surface and the turbulent flow across the surface:\n\\begin{equation}\n\\tag{3.2}\n    H \\ = \\ k_H \\rho_a c_p (T_s - T_a)\n\\end{equation}\nwhere k_H is the atmospheric conductivity, \\rho_a is the density of air, and c_p is the specific heat capacity of air (at constant pressure). Heat capacity refers to the amount of energy required to change the temperature of a substance. Though c_p varies slightly with air temperature, to simplify our calculations we will assume a constant value of 1004.67 \\text{ J kg}^{-1} \\text{ K}^{-1} for c_p.\nThe atmospheric conductivity depends on the roughness of the surface and the wind speed. While we cannot measure this quantity directly, we can use eddy covariance to calculate H. In the air, heat is transported by the turbulent flow of air in multiple layers. By averaging the product of the fluctuations of temperature and vertical wind, we can determine the amount of energy transported to or from the surface via the air ‚Äì i.e.¬†the sensible heat flux. Thus, our equation for H becomes\n\\begin{equation}\n\\tag{3.3}\n    H \\ = \\ \\overline{\\rho_{a}} \\ c_p \\ \\overline{w'T'}\n\\end{equation}\nThe overbars in this equation represent averages taken over a period of time when the mean vertical flow is negligible (conventionally 30 minutes). This method relies on sensors to measure the fluctuations of temperature, wind, and gas concentrations at very high frequencies in order to adequately sample the eddies that are responsible for transport. The two sensors - an anemometer and a gas analyzer ‚Äì must be a close together as possible to effectively sample the same pocket of air at the same time.\n\nThe gas analyzer provides a measurement of the concentration of water vapor in the air, which allows for calculation of air density over time. The average air density over any period of time can be expressed as the sum of the average density of dry air, \\overline{\\rho_d}, and the average vapor density, \\overline{\\rho_v}:\n\\begin{equation}\n\\tag{3.4}\n    \\overline{\\rho_{a}} \\ = \\ \\overline{\\rho_{v}} + \\overline{\\rho_d}\n\\end{equation}\nBecause we know the concentration of water vapor in the air, we can determine the atmospheric vapor pressure (or partial pressure of water vapor in the air), \\overline{e_a}. Using the ideal gas law, which relates the amount, pressure, and temperature of a gas, we can calculate vapor density:\n\\begin{equation}\n\\tag{3.5}\n    \\overline{\\rho_v} \\ = \\ \\frac{M_{_{\\text{H}_2\\text{O}}} \\cdot \\overline{e_a}}{R \\ \\overline{T_a}}\n\\end{equation}\nwhere M_{_{\\text{H}_2\\text{O}}} is the molar mass of water, R is the ideal gas constant, and \\overline{T_a} is the average air temperature.\nSimilarly, we can compute the dry air density over the same time period using the partial pressure of dry air, which is simply the difference between total air pressure, \\overline{P_a}, and the vapor pressure:\n\\begin{equation}\n\\tag{3.6}\n    \\overline{\\rho_d} \\ = \\ \\frac{M_{_{\\text{air}}} \\left( \\overline{P_a} \\ - \\ \\overline{e_a}\\right)}{R \\ \\overline{T_a}}\n\\end{equation}\nwhere M_{_{\\text{air}}} is the molar mass of dry air."
  },
  {
    "objectID": "Lab-2_Energy_Balance.html#latent-heat-flux",
    "href": "Lab-2_Energy_Balance.html#latent-heat-flux",
    "title": "",
    "section": "3.3. Latent Heat Flux üíß",
    "text": "3.3. Latent Heat Flux üíß\nLatent heat flux, \\lambda E, is the energy flux associated with phase changes (evaporation and condensation) between water at the Earth‚Äôs surface and water vapor in the air. \\lambda E is driven by gradients of vapor pressure between the surface (e_s) and the air (e_a):\n\\begin{equation}\n\\tag{3.7}\n    \\lambda E \\ \\propto \\ e_s - \\ e_a\n\\end{equation}\nThis relationship also depends on the density and total pressure of the air, the atmospheric conductivity to vapor transport, k_E, and the latent heat of vaporization of water, \\lambda_v (the energy required to convert one mole of H2O from liquid to gas at 100^{\\circ}C):\n\\begin{equation}\n\\tag{3.8}\n    \\lambda E \\ = \\ k_E \\lambda_v \\rho_a \\frac{M_{_{\\text{air}}}}{M_{_{\\text{H}_2\\text{O}}}} \\frac{e_s - e_a}{P_a}\n\\end{equation}\nLike the sensible heat flux, it is difficult to measure \\lambda E directly, but we can calculate it using eddy covariance:\n\\begin{equation}\n\\tag{3.9}\n    \\lambda E \\ = \\ \\overline{\\rho_a} \\lambda_v \\overline{w' \\chi_{v}'}\n\\end{equation}\nwhere \\chi_v is the mole fraction of water vapor in the air.\nWhile Equation 3.9 provides a rough approximation of latent heat flux, in practice, a number of corrections must be made to this equation to account for the separation of the sensors and the varying density of air due to both sensible and latent heat fluxes. These corrections have been implemented in a function (lhf.py) for ease of our computations. Thus, we can import the function and calculate \\lambda E as follows:\nfrom lhf import lhf_wpl\n\nlhf_wpl(df)\nFor now, we‚Äôll just import the function.\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\nfrom lhf import lhf_wpl"
  },
  {
    "objectID": "Lab-2_Energy_Balance.html#problems-1",
    "href": "Lab-2_Energy_Balance.html#problems-1",
    "title": "",
    "section": "Problems",
    "text": "Problems\n\n3.1. Density of air\nBefore calculating H, it‚Äôs useful to calculate the vapor density and densities of dry and wet air.\n\nüìö  <b> Question 3.1. </b> \nUse equations 3.4, 3.5, and 3.6 to calculate $\\rho_v$, $\\rho_d$, and $\\rho_a$. Hint: be sure to convert temperature to K and check your units!. To make your life easier later on, add $T$ in K and each of the densities to the original <span class=\"code\">DataFrame</span> with the following names: <code>'T_K'</code>, <code>'rho_v'</code>, <code>'rho_d'</code>, and <code>'rho_a'</code>.\n\n\n\n3.2. Calculate H\nNow that you‚Äôve determined \\rho_a, you can use this value to calculate sensible heat flux.\n\nüìö  <b> Question 3.2. </b> \nUse Equation 3.3 to determine sensible heat flux, $H$.\n\n\n\n3.3. Latent heat flux\n\nüìö  <b> Question 3.3. </b> \nUse the <code>lhf_wpl</code> function to determine latent heat flux, $\\lambda E$.\n\n\n\n3.4 Comparing turbulent fluxes\nNow that you‚Äôve calculated both sensible and latent heat, compare how the two vary. Consider the conditions under which H and \\lambda E are positive or negative. What physical processes drive these fluctuations?\n\nüìö  <b> Question 3.4. </b> \nPlot sensible and latent heat for the last week of each year (beginning on December 25th). Be sure your plot(s) is/are appropriately scaled and labeled. How do they compare? When does $H$ exceed $\\lambda E$? When does $\\lambda E$ exceed $H$? Why do are the fluxes so different for the same week of 2016 and 2019 (Hint: there is one column of data you've been provided that you have not yet used.)?"
  },
  {
    "objectID": "Exercise1-2_Lists.html",
    "href": "Exercise1-2_Lists.html",
    "title": "",
    "section": "",
    "text": "‚¨ÖÔ∏è Previous Exercise | üè† Index | ‚û°Ô∏è Next Exercise |"
  },
  {
    "objectID": "Exercise1-2_Lists.html#lists",
    "href": "Exercise1-2_Lists.html#lists",
    "title": "",
    "section": "Lists",
    "text": "Lists\nA list is a Python object used to contain multiple values. Lists are ordered and changeable. They are defined as follows:\nnum_list = [4, 23, 654, 2, 0, -12, 4391]\nstr_list = ['energy', 'water', 'carbon']\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\n# Define list variables\nnum_list = [4, 23, 654, 2, 0, -12, 4391]\nstr_list = ['energy', 'water', 'carbon']\n\n\nWhile you can create lists containing mixed data types, this is not usually recommended.\nThe len() command returns the length of the list.\nlen(str_list)\n>>> 3\nThe min() and max() commands are used to find the minimum and maximum values in a list. For a list of strings, this corresponds to the alphabetically first and last elements.\nmin(str_list)\n>>> 'carbon'\n\nmax(str_list)\n>>> 'water'\n\n‚úèÔ∏è <b> Try it. </b> \nUse the <code>len()</code>, <code>min()</code>, and <code>max()</code> commands to find the length, minimum, and maximum of <code>num_list</code>.\n\n\n\nCode\n# Find the length of num_list\n\n# Minimum value of num_list\n\n# Maximum value of num_list\n\n\n\n\n\nIndexing\nThe index is used to reference a value in an iterable object by its position. To access an element in a list by its index, use square brackets [].\n\nüêç <b>Note.</b> Python is zero-indexed. This means that the first element in the list is 0, the second is 1, and so on. The last element in a list with $n$ elements is $n - $1.\n\nnum_list[2]\n>>> 654\nYou can also access an element based on its position from the end of the list.\nnum_list[-2]\n>>> -12\n\n‚úèÔ∏è <b> Try it. </b> \nFind the 2nd element in <code>str_list</code> in two different ways. Remember that Python is zero-indexed!\n\n\n\nCode\n# Option 1\n\n# Option 2\n\n\nAccessing a range of values in a list is called slicing. A slice specifies a start and an endpoint, generating a new list based on the indices. The indices are separated by a :.\n\nüêç <b>Note.</b>  The endpoint index in the slice is <i>exclusive</i>. To slice to the end of the list, omit an endpoint.\n\nnum_list[2:6]\n>>> [654, 2, 0, -12]\n\nnum_list[0:4]   \n>>> [4, 23, 654, 2]\n\nnum_list[:4]    \n>>> [4, 23, 654, 2]\n\nnum_list[-6:-1] \n>>> [23, 654, 2, 0,-12]\nIt is also possible to specify a step size, i.e.¬†[start:stop:step]. A step size of 1 would select every element, 2 would select every other element, etc.\nnum_list[0:4:2]  \n>>> [4, 654]\n\nnum_list[::2]    \n>>>[4, 654, 0, 4391]\nA step of -1 returns the list in reverse.\nnum_list[::-1]\n>>> [4391, -12, 0, 2, 654, 23, 4]\n\nüìö  <b> Practice 1. </b> \nDefine a new list of <b>floats</b> with <b>8 elements</b> called <code>my_list</code>. \n\nFind the 5th element in your list.\nCreate a new list containing every other value in your original list.\nUsing slicing and two different methods of indexing, remove the first and last values in your list.\n\n\n\n\nCode\n# Define a new list called my_list.\n\n# Find the 5th element.\n\n# New list with every other value.\n\n# Remove first and last values. \n\n\nLike lists, strings can also be indexed using the same notation. This can be useful for many applications, such as selecting files in a certain folder for import based on their names or extension.\nword_str = 'antidisestablishmentarianism'\n\nword_str[14]\n>>> 's'\n\nword_str[::3]\n>>> 'aistlhnrnm'\n\nüìö  <b> Practice 2. </b> \nUse indexing to extract the second letter of the third element ('a') in <code>str_list</code>.\n\n\n\n\n\nList Operations\nElements can be added to a list using the command list.append().\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\ncolors = ['red', 'blue', 'green', 'black', 'white']\ncolors.append('pink')\nprint(colors)\n\n\nYou can add an element to a list in a specific position using the command list.insert().\ncolors.insert(4, 'purple')\nprint(colors)\n>>> ['red', 'blue', 'green', 'black', 'purple', 'white', 'pink']\n\n‚úèÔ∏è <b> Try it. </b> \nAdd <code>'purple'</code> to the list <code>colors</code> between <code>'green'</code> and <code>'black'</code>.\n\nThere are multiple ways to remove elements from a list. The commands list.pop() and del remove elements based on indices.\ncolors.pop()       # removes the last element\ncolors.pop(2)      # removes the third element\ndel colors[2]      # removes the third element\ndel colors[2:4]    # removes the third and fourth elements\nThe command list.remove() removes an element based on its value.\ncolors.remove('red')\nprint(colors)\n>>> ['blue', 'green', 'black', 'purple', 'white', 'pink']\n\n‚úèÔ∏è <b> Try it. </b> \nRemove <code>'pink'</code> and <code>'purple'</code> from <code>colors</code>, using <code>del</code> for one of the strings and <code>list.remove()</code> for the other.\n\nYou can sort the elements in a list (numerically or alphabetically) in two ways. The first uses the command list.sort().\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\nrand_list = [5.1 , 3.42 , 3.333 , 100.4 , 0.5 , 26.0 , 7.44 , 5.8 , 39.0]\nrand_list.sort()\nprint(rand_list)\n\n\nSetting reverse=True within this command sorts the list in reverse order:\nrand_list = [5.1 , 3.42 , 3.333 , 100.4 , 0.5 , 26.0 , 7.44 , 5.8 , 39.0]\nrand_list.sort(reverse=True)\nprint(rand_list)\n>>> [100.4, 39.0, 26.0, 7.44, 5.8, 5.1, 3.42, 3.333, 0.5]\nSo far, all of the list commands we‚Äôve used have been in-place operators. This means that they perform the operation to the variable in place without requiring a new variable to be assigned. By contrast, standard operators do not change the original list variable. A new variable must be set in order to retain the operation.\n\n‚úèÔ∏è <b> Try it. </b> \nVerify that <code>rand_list</code> was, in fact, sorted in place by using the <code>min()</code> and <code>max()</code> functions to determine the minmum and maximum values in the list and printing the first and last values in the list.\n\n\n\nCode\n# Print the min and max values in rand_list.\n\n# Print the first and last values in rand_list.\n\n\nThe other method of sorting a list is to use the sorted() command, which does not change the original list. Instead, the sorted list must be assigned to a new variable.\nrand_list = [5.1 , 3.42 , 3.333 , 100.4 , 0.5 , 26.0 , 7.44 , 5.8 , 39.0]\nsorted_list = sorted(rand_list)\nprint(rand_list[0])\nprint(sorted_list[0])\n>>> 5.1\n    0.5\nTo avoid changing the original variable when using an in-place operator, it is wise to create a copy. There are multiple ways to create copies of lists, but it is important to know the difference between a true copy and a view. A view of a list can be created as follows:\nstr_list = ['energy', 'water', 'carbon']\nstr_list_view = str_list\nAny in-place operation performed on str_list_view will also be applied to str_list. To avoid this, create a copy of str_list using any of the following methods:\nstr_list_copy = str_list.copy()\n# or\nstr_list_copy = str_list[:]\n# or\nstr_list_copy = list(str_list)\n\nüìö  <b> Practice 3. </b> \nCreate a copy of <code>my_list</code>, which you assigned above. \n\nUsing indexing or list operators, remove the first and last elements of your copied list.\nSort both the original list and the copied list in reverse order.\nUse the len() function and a boolean operator to determine which list is longer.\n\n\n\n\nCode\n# Create a copy of mylist.\n\n# Sort both lists from largest to smallest.\n\n# Determine which list is longer.\n\n\nIn addition to adding single elements to a list using list.append() or list.insert(), multiple elements can be added to a list at the same time by adding multiple lists together.\nrainbow  = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet']\nshades = ['coral', 'chartreuse', 'cyan', 'navy']\nprint( rainbow + shades )\n>>> ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet', 'coral', 'chartreuse', 'cyan', 'navy']\n\nüìö  <b> Practice 4. </b> \nAdd <code>rand_list</code> and <code>my_list</code> together in a new list called <code>float_list</code>. Print the result.\n\nSingle lists can be repeated by multiplying by an integer.\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\nstr_list2 = str_list * 2\nnum_list4 = num_list * 4\nprint( str_list2 )\nprint( num_list4 )\n\n\n\n\nGenerating sequential lists\nSequential lists are valuable tools, particularly for iteration, which we will explore in the next exercise. The range() function is used to create an iterable object based on the size of an integer argument.\nrange(4)\n>>> range(0, 4)\nTo construct a sequential list from the range() object, use the list() function.\nlist(range(4))\n>>> [0, 1, 2, 3]\nUsing multiple integer arguments, the range() function can be used to generate sequential lists between two bounds: range(start, stop [, step]).\n\nüêç <b>Note.</b> \nLike indexing, all Python functions using <span style=\"font-style: italic\"> start </span> and <span style=\"font-style: italic\"> stop </span> arguments, the <span style=\"font-style: italic\"> stop </span> value is <span style=\"font-weight: bold\"> exclusive </span>.\n\nrange_10 = list(range(1,11))\nodds_10 = list(range(1,11,2))\nprint(range_10)\nprint(odds_10)\n>>> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    [1, 3, 5, 7, 9]\n\nüìö  <b> Practice 5. </b> \nUse the <code>range()</code> function to construct a list of all hundreds (e.g. 100, 200, etc.) between 0 and 1000, inclusive.\n\n\n\nCode\n# Construct a list of hundreds from 0 to 1000\n\n# Print your list\n\n\n\n\nCode\nfrom IPython.core.display import HTML\ndef css_styling():\n    styles = open(\"./styles/exercises.css\", \"r\").read()\n    return HTML(styles)\ncss_styling()"
  },
  {
    "objectID": "Exercise2-3_Matplotlib.html",
    "href": "Exercise2-3_Matplotlib.html",
    "title": "",
    "section": "",
    "text": "‚¨ÖÔ∏è Previous Exercise | üè† Index | ‚û°Ô∏è Next Exercise |"
  },
  {
    "objectID": "Exercise2-3_Matplotlib.html#introduction-to-matplotlib",
    "href": "Exercise2-3_Matplotlib.html#introduction-to-matplotlib",
    "title": "",
    "section": "Introduction to matplotlib",
    "text": "Introduction to matplotlib\n\nAs always, we will begin by importing the required libraries and packages. For plotting, itself, we will use a module of the matplotlib library called  pyplot. The  pyplot module consists of a collection of functions to display and edit figures. As you advance with Python and with data analysis, you may want to explore additional features of  matplotlib, but  pyplot will suit the vast majority of your plotting needs at this stage.\nThe standard import statement for  matplotlib.pyplot  is:\nimport matplotlib.pyplot as plt\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\n# Imports\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n\n\nAnatomy of a matplotlib plot\nThe core components of a matplotlib plot are the Figure and the Axes. The Figure is the overall window upon which all components are drawn. It serves as the blank container for plots, as well as other things, such as a legend, color bar, etc. You can (and will) create multiple independent figures, and each figure can hold multiple Axes. To the figure you will add Axes, the area where the data are actually plotted and where associated ticks, labels, etc. live.\nWhen working with a single plot, we will mostly deal with the Figure object and its routines, but we will see the Axes become important as we increase the complexity of our plots.\n\n\n\nBasic plotting\n\n\nWe will start with the most basic plotting routines: plt.plot() and plt.scatter(). The first, plt.plot(), is used to generate a connected line plot (with optional markers for individual data points). plt.scatter(), as the name suggests, is used to generate a scatter plot.\nEach time you want to create a new figure, it is wise to first initialize a new instance of the matplotlib.figure.Figure class on which to plot our data. While this is not required to display the plot, if you subsequently plot additional data without a new Figure instance, all data will be plotted on the same figure. For example, let‚Äôs generate a few functions, y_{\\sin} = \\sin{(x)} and y_{\\cos} = \\cos{(x)}:\n# Generate a 1D array with 300 points between -5 and 5\nx = np.linspace(-5,5,300)\n# Generate sine wave\nysin = np.sin(x)\n# Generate cosine wave\nycos = np.cos(x)\nWe can plot these on the same figure without instancing plt.figure() as follows:\n# Plot sine wave\nplt.plot(x,ysin)\n# Plot cosine wave\nplt.plot(x,ycos)\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\n# Generate a 1D array with 100 points between -5 and 5\nx = np.linspace(-5,5,100)\n# Generate sine wave\nysin = np.sin(x)\n# Generate cosine wave\nycos = np.cos(x)\n\n# Plot sine wave\nplt.plot(x,ysin)\n# Plot cosine wave\nplt.plot(x,ycos)\n\n\nTo create multiple graphs in separate figure windows, however, you need to create new Figure instances as follows:\nfig = plt.figure()\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\n# Plot sine wave\nfig1 = plt.figure()\nplt.plot(x,ysin)\n\n# Plot cosine wave\nfig2 = plt.figure()\nplt.plot(x,ycos)\n\n\nThis also allows you to access the Figure object later by refering to the variable fig. Thus, even when you want to plot all data on a single plot, it is best to always start by initializing a new Figure.\nTo generate a scatter plot instead of a line, we can use plt.scatter():\n# Generate new x and y with fewer points for legibility\nxscat = np.linspace(-5,5,25)\nyscat = np.sin(xscat)\n\n# Plot sine function as scatter plot\nplt.scatter(xscat,yscat)\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\n# Generate new x and y with fewer points for legibility\nxscat = np.linspace(-5,5,25)\nyscat = np.sin(xscat)\n\n# Plot sine function as scatter plot\nplt.scatter(xscat,yscat)\n\n\nYou can also create a scatter plot using plt.plot() with keyword arguments, which allow you to change things like the color, style, and size of the lines and markers. We will explore some of these keyword arguments in the next section.\n\n\nKeyword arguments\n\n\nIn addition to the required x and y parameters, there are a number of optional keyword arguments that can be passed to the matplotlib plotting functions. Here, we will consider a few of the most useful: color, marker, and linestyle.\n\nColors\nThe first thing you might wish to control is the color of your plot. Matplotlib accepts several different color definitions to the color keyword argument, which is a feature of most plotting functions.\nFirst, colors can be passed as strings according to their HTML/CSS names. For example:\nplt.plot(x, y, 'green')\nIn total, there are 140 colors allowed in HTML; their names are shown below.\n\n\n\ncolors\n\n\nAs you can see in the image above, the basic colors can also be defined by a single-letter shortcut. These are shown in the table below.\n\n\n\n\n\n\n\nLetter code\nColor name\n\n\n\n\n‚Äòr‚Äô\nred\n\n\n‚Äòg‚Äô\ngreen\n\n\n‚Äòb‚Äô\nblue\n\n\n‚Äòc‚Äô\ncyan\n\n\n‚Äòm‚Äô\nmagenta\n\n\n‚Äòy‚Äô\nyellow\n\n\n‚Äòk‚Äô\nblack\n\n\n‚Äòw‚Äô\nwhite\n\n\n\nAnother way of specifying colors is to use an RGB(A) tuple, where the brightness of each channel (R, G, or B, which correspond to red, green, and blue) is given as a float between 0 and 1. An optional fourth value, A or alpha, value can be passed to specify the opacity of the line or marker.\nplt.plot(x, y, color=(0.2,0.7,1.0))\nA grayscale value can be used by passing a number between 0 and 1 as a string. In this representation, '0.0' corresponds to black and '1.0' corresponds to white.\nplt.plot(x, y, color='0.25')\nMy personal favorite way to define colors is to use  color hex codes, which represent colors as hexadecimals ranging from 0 to FF. Color hex codes consist of a hash character # followed by six hex values (e.g.¬†#AFD645). Hex codes must be passed as strings (e.g.¬†'#AFD645') in matplotlib and are perhaps the most flexible way to select colors.\nplt.plot(x, y, color='#C6E2FF')\nIn the cell below, five functions are plotted in different colors, each specified by a different definition.\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\n# Initialize empty figure\nfig1 = plt.figure()\n# Plot sine wave with different colors\nplt.plot(x, np.sin(x - 0), color='darkblue')     # HTML name\nplt.plot(x, np.sin(x - 1), color='m')            # Short letter code\nplt.plot(x, np.sin(x - 2), color=(0.0,0.8,0.81)) # RGB tuple\nplt.plot(x, np.sin(x - 3), color='0.65')         # Grayscale between 0 and 1\nplt.plot(x, np.sin(x - 4), color='#B8D62E')      # Hex code\n\n\n\n\nLinestyles\nUsing the linestyle keyword argument, you can change the style of the line plotted using plt.plot(). These can be specified either by their name or a shortcut. A few of the style options (and their matplotlib shortcuts) are shown in the table below. To see a full list of linestyle options, see the docs.\n\n\n\n\n\n\n\nShort code\nLine style\n\n\n\n\n‚Äò-‚Äô\nsolid\n\n\n‚Äò‚Äì‚Äô\ndashed\n\n\n‚Äò:‚Äô\ndotted\n\n\n‚Äò-.‚Äô\ndashdot\n\n\n\nAs we‚Äôve already seen, the default linestyle is solid. The syntax for changing a line‚Äôs style is:\nplt.plot(x, y, linestyle='dashed')\nor, more commonly:\nplt.plot(x, y, linestyle='--')\nLet‚Äôs adjust the style of our waveform plot using the linestyle keyword argument.\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\n# Initialize empty figure\nfig1 = plt.figure()\n# Plot sine wave with different colors + linestyles\nplt.plot(x, np.sin(x - 0), color='darkblue', linestyle='-')\nplt.plot(x, np.sin(x - 1), color='m', linestyle='dashed')\nplt.plot(x, np.sin(x - 2), color=(0.0,0.8,0.81), linestyle=':') \nplt.plot(x, np.sin(x - 3), color='0.65', linestyle='solid')\nplt.plot(x, np.sin(x - 4), color='#B8D62E', linestyle='-.')\n\n\n\n\nMarkers\nMarkers can be used in plt.plot() and plt.scatter(). There are several available markers in matplotlib, and you can also define your own. A few of the most useful are shown in the table below.\n\n\n\nMarker code\nSymbol\nDescription\n\n\n\n\n‚Äòo‚Äô\n‚óè\ncircle\n\n\n‚Äò.‚Äô\n‚ãÖ\npoint\n\n\n**‚Äô*‚Äô**\n‚òÖ\nstar\n\n\n‚Äò+‚Äô\n+\nplus\n\n\n‚Äòx‚Äô\n\\times\nx\n\n\n‚Äò^‚Äô\n‚ñ≤\ntriangle\n\n\n‚Äòs‚Äô\n‚óº\nsquare\n\n\n\nNote that unlike color and linestyle, the marker keyword argument only accepts a code to specify the marker style.\nplt.scatter(x, y, marker='+')\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\n# Initialize empty figure\nfig1 = plt.figure()\n# Plot sine wave as scatter plot with different colors + markers\nplt.scatter(xscat, yscat-0, color='darkblue', marker='o')\nplt.scatter(xscat, yscat-1, color='m', marker='.')\nplt.scatter(xscat, yscat-2, color=(0.0,0.8,0.81), marker='+')\nplt.scatter(xscat, yscat-3, color='0.65', marker='*')\nplt.scatter(xscat, yscat-4, color='#B8D62E', marker='s')\n\n\nUsing the marker keyword argument with the plt.plot() function creates a connected line plot, where the data points are designated by markers and connected by lines.\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\n# Initialize empty figure\nfig1 = plt.figure()\n# Plot sine wave with different colors + markers\nplt.plot(xscat, np.sin(xscat - 0), color='darkblue', marker='o')\nplt.plot(xscat, np.sin(xscat - 1), color='m', marker='.')\nplt.plot(xscat, np.sin(xscat - 2), color=(0.0,0.8,0.81), marker='+')\nplt.plot(xscat, np.sin(xscat - 3), color='0.65', marker='*')\nplt.plot(xscat, np.sin(xscat - 4), color='#B8D62E', marker='s')\n\n\n\n\nExplicit definitions vs.¬†shortcuts\nUp to now, we have used explicit definitions to specify keyword arguments. While this is generally preferable, matplotlib does allow color, linestyle, and marker codes to be combined into a single, non-keyword argument. For example:\n# Plot a dashed red line\nplt.plot(x, y, 'r--')\nSeveral examples are presented in the cell below.\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\n# Initialize empty figure\nfig1 = plt.figure()\n# Plot sine wave with different colors + markers\nplt.plot(xscat, yscat-0, 'b-o')    # Solid blue line with circle markers\nplt.plot(xscat, yscat-1, 'm--*')   # Dashed magenta line with star markers\nplt.plot(xscat, yscat-2, 'c+')     # Cyan plus markers\nplt.plot(xscat, yscat-3, 'k')      # Solid black line\nplt.plot(xscat, yscat-4, 'y-s')    # Solid yellow line with square markers\n\n\nAs you can see, the downside of this method is that you are limited to the eight colors that have a single-letter code. To use other colors, you must use explicitly defined keyword arguments.\nIn addition to those we explored in this section, other useful keyword arguments include linewidth and markersize, which do exactly what you‚Äôd expect them to do. For a full list of keyword arguments (you should know what‚Äôs coming by now), see the docs.\n\n\n\nAxes settings\n\n\nNext, we will explore how to scale and annotate a plot using axes routines that control what goes on around the edges of the plot.\n\nLimits, labels, + ticks\nBy default, matplotlib will attempt to determine x- and y-axis limits, which usually work pretty well. Sometimes, however, it is useful to have finer control. The simplest way to adjust the display limits is to use the plt.xlim() and plt.ylim() methods:\n# Set axis limits\nplt.xlim(xmin, xmax)\nplt.ylim(ymin, ymax)\nIn the example below, adjust the numbers (these can be int or float values) to see how the plot changes.\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\n# Initialize empty figure\nfig1 = plt.figure()\n# Plot sine wave \nplt.plot(x, ysin, color='darkblue')\n\n# Set axis limits\nplt.xlim(-5,5)\nplt.ylim(-2,2)\n\n\nYou may also find it useful to adjust the ticks and/or tick labels that matplotlib  displays by default. The plt.xticks() and plt.yticks() methods allow you to control the locations of both the ticks and the labels on the x- and y-axes, respectively. Both methods accept two list or array-like arguments, as well as optional keyword arguments. The first corresponds to the ticks, while the second controls the tick labels.\n# Set x-axis ticks at 0, 0.25, 0.5, 0.75, 1.0 with all labeled\nplt.xticks([0,0.25,0.5,0.75,1.0])\n# Set y-axis ticks from 0 to 100 with ticks on 10s and labels on 20s\nplt.yticks(np.arange(0,101,10),['0','','20','','40','','60','','80','','100'])\nIf the labels are not specified, all ticks will be labeled accordingly. To only label certain ticks, you must pass a list with empty strings in the location of the ticks you wish to leave unlabeled (or the ticks will be labeled in order).\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\n# Initialize empty figure\nfig1 = plt.figure()\n# Plot sine wave \nplt.plot(x, ysin, color='darkblue')\n\n# Set x-axis limits\nplt.xlim(-5,5)\n\n# Set axis ticks\nplt.xticks([-4,-3,-2,-1,0,1,2,3,4],['-4','','-2','','0','','2','','4'])\nplt.yticks([-1,-0.5,0,0.5,1])\n\n\nAs with any plot, it is imperative to include x- and y-axis labels. This can be done by passing strings to the plt.xlabel() and plt.ylabel() methods:\n# Set axis labels\nplt.xlabel('x-axis')\nplt.ylabel('y-axis')\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\n# Initialize empty figure\nfig1 = plt.figure()\n# Plot sine wave \nplt.plot(x, ysin, color='darkblue')\n\n# Set x-axis limits\nplt.xlim(-5,5)\n\n# Set axis ticks\nplt.xticks([-4,-3,-2,-1,0,1,2,3,4],['-4','','-2','','0','','2','','4'])\nplt.yticks([-1,-0.5,0,0.5,1])\n\n# Set axis labels\nplt.xlabel('x-axis')\nplt.ylabel('y-axis')\n\n\nA nice feature about matplotlib is that it supports TeX formatting for mathematical expressions. This is quite useful for displaying equations, exponents, units, and other mathematical operators. The syntax for TeX expressions is 'r$TeX expression here$'. For example, we can display the axis labels as x and \\sin{(x)} as follows:\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\n# Initialize empty figure\nfig1 = plt.figure()\n# Plot sine wave \nplt.plot(x, ysin, color='darkblue')\n\n# Set x-axis limits\nplt.xlim(-5,5)\n\n# Set axis ticks\nplt.xticks([-4,-3,-2,-1,0,1,2,3,4],['-4','','-2','','0','','2','','4'])\nplt.yticks([-1,-0.5,0,0.5,1])\n\n# Set axis labels\nplt.xlabel(r'$x$')\nplt.ylabel(r'$\\sin{(x)}$')\n\n\n\n\nLegends + titles\nAdding a title to your plot is analogous to labeling the x- and y-axes. The plt.title() method allows you to set the title of your plot by passing a string:\nplt.title('Title')\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\n# Initialize empty figure\nfig1 = plt.figure()\n# Plot sine wave \nplt.plot(x, ysin, color='darkblue')\nplt.plot(x, ycos, color='#B8D62E')\n\n# Set x-axis limits\nplt.xlim(-5,5)\n\n# Set axis ticks\nplt.xticks([-4,-3,-2,-1,0,1,2,3,4],['-4','','-2','','0','','2','','4'])\nplt.yticks([-1,-0.5,0,0.5,1])\n\n# Set axis labels\nplt.xlabel(r'$x$')\nplt.ylabel(r'$y$')\n\n# Set title\nplt.title('Sinusoidal functions')\n\n\nWhen multiple datasets are plotted on the same axes it is often useful to include a legend that labels each line or set of points. Matplotlib has a quick way of displaying a legend using the plt.legend() method. There are multiple ways of specifying the label for each dataset; I prefer to pass a list of strings to plt.legend():\n# Plot data\nplt.plot(x1, y1)\nplt.plot(x2, y2)\n\n# Legend\nplt.legend(labels=['Data1', 'Data2'])\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\n# Initialize empty figure\nfig1 = plt.figure()\n# Plot sine wave \nplt.plot(x, ysin, color='darkblue')\nplt.plot(x, ycos, color='#B8D62E')\n\n# Set x-axis limits\nplt.xlim(-5,5)\n\n# Set axis ticks\nplt.xticks([-4,-3,-2,-1,0,1,2,3,4],['-4','','-2','','0','','2','','4'])\nplt.yticks([-1,-0.5,0,0.5,1])\n\n# Set axis labels\nplt.xlabel(r'$x$')\nplt.ylabel(r'$y$')\n\n# Set title\nplt.title('Sinusoidal functions')\n\n# Legend\nplt.legend(labels=['sin(x)','cos(x)'])\n\n\nAnother way of setting the data labels is to use the label keyword argument in the plt.plot() (or plt.scatter()) function:\n# Plot data\nplt.plot(x1, y1, label='Data1')\nplt.plot(x2, y2, label='Data2')\n\n# Legend\nplt.legend()\nNote that you must still run plt.legend() to display the legend.\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\n# Initialize empty figure\nfig1 = plt.figure()\n# Plot sine wave \nplt.plot(x, ysin, label='sin(x)', color='darkblue')\nplt.plot(x, ycos, label='cos(x)', color='#B8D62E')\n\n# Set x-axis limits\nplt.xlim(-5,5)\n\n# Set axis ticks\nplt.xticks([-4,-3,-2,-1,0,1,2,3,4],['-4','','-2','','0','','2','','4'])\nplt.yticks([-1,-0.5,0,0.5,1])\n\n# Set axis labels\nplt.xlabel(r'$x$')\nplt.ylabel(r'$y$')\n\n# Set title\nplt.title('Sinusoidal functions')\n\n# Legend\nplt.legend()\n\n\n\n\n\nSubplots + multiple axes\n\n\nNow that we‚Äôve established the basics of plotting in matplotlib, let‚Äôs get a bit more complicated. Oftentimes, you may want to plot data on multiple axes within the same figure. The easiest way to do this in matplotlib is to use the plt.subplot() function, which takes three non-keyword arguments: nrows, ncols, and index. nrows and ncols correspond to the total number of rows and columns of the entire figure, while index refers to the index position of the current axes. Importantly (and annoyingly), the index for subplots starts in the upper left corner at 1 (not 0)!. The image below contains a few examples of how matplotlib arranges subplots.\n\nThe most explicit way of adding subplots is to use the fig.add_subplot() command to initialize new axes as variables:\n# Initialize empty figure\nfig = plt.figure()\n# Add four axes\nax1 = fig.add_subplot(2,2,1)\nax2 = fig.add_subplot(2,2,2)\nax3 = fig.add_subplot(2,2,3)\nax4 = fig.add_subplot(2,2,4)\nThis allows you to access each Axes object later to plot data and adjust the axes parameters.\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\n# Initialize empty figure\nfig = plt.figure()\n# Add four axes\nax1 = fig.add_subplot(2,2,1)\nax2 = fig.add_subplot(2,2,2)\nax3 = fig.add_subplot(2,2,3)\nax4 = fig.add_subplot(2,2,4)\n\n\nTo plot data, we use ax.plot() or ax.scatter(). These methods are analogous to plt.plot() and plt.scatter() for acting on the Axes, rather than the Figure object.\n# Plot data\nax1.plot(x, y)\nax2.plot(x, y)\nax3.plot(x, y)\nax4.plot(x, y)\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\n# Initialize empty figure\nfig = plt.figure()\n# Add four axes\nax1 = fig.add_subplot(2,2,1)\nax2 = fig.add_subplot(2,2,2)\nax3 = fig.add_subplot(2,2,3)\nax4 = fig.add_subplot(2,2,4)\n\n# Plot data\n# Plot sine wave with different colors on different axes\nax1.plot(x, np.sin(x - 0), color='darkblue')\nax2.plot(x, np.sin(x - 1), color='m')\nax3.plot(x, np.sin(x - 2), color=(0.0,0.8,0.81))\nax4.plot(x, np.sin(x - 4), color='#B8D62E')\n\n\n\nFigure vs.¬†Axes methods\nPerhaps the trickiest part about subplots ‚Äì and Axes methods in general ‚Äì¬†is adjusting the axes settings. While most Figure functions translate directly Axes methods (e.g.¬†plt.plot() \\rightarrow ax.plot(), plt.legend() \\rightarrow ax.legend()), commands to set limits, ticks, labels, and titles are slightly modified. Some important Figure methods and their Axes counterparts are shown in the table below.\n\n\n\n\n\n\n\nFigure command\nAxes command\n\n\n\n\nplt.xlabel()\nax.set_xlabel()\n\n\nplt.ylabel()\nax.set_ylabel()\n\n\nplt.xlim()\nax.set_xlim()\n\n\nplt.ylim()\nax.set_ylim()\n\n\nplt.xticks()\nax.set_xticks()\n\n\nplt.yticks()\nax.set_yticks()\n\n\n\nThese are different primarily because the Figure functions are inherited from MATLAB, while the Axes functions are object-oriented. Generally, the arguments are similar ‚Äì if not identical ‚Äì¬†between the two.\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\n# Initialize empty figure\nfig = plt.figure()\n# Add four axes\nax1 = fig.add_subplot(2,2,1)\nax2 = fig.add_subplot(2,2,2)\nax3 = fig.add_subplot(2,2,3)\nax4 = fig.add_subplot(2,2,4)\n\n# Plot data\n# Plot sine wave with different colors on different axes\nax1.plot(x, np.sin(x - 0), color='darkblue')\nax2.plot(x, np.sin(x - 1), color='m')\nax3.plot(x, np.sin(x - 2), color=(0.0,0.8,0.81))\nax4.plot(x, np.sin(x - 4), color='#B8D62E')\n\n# Set axes limits, labels, + ticks\nfor i,ax in enumerate([ax1,ax2,ax3,ax4]):\n    # Set x limits \n    ax.set_xlim(-5,5)\n    # Set title\n    ax.set_title(r'$\\sin{(x - %d)}$' % i)\n    # Only label x ticks and x-axis on bottom row\n    if i < 2:\n        ax.set_xticklabels([])\n    else:\n        ax.set_xlabel('x')\n    # Only label y ticks and y-axis on left column\n    if i == 0 or i == 2:\n        ax.set_ylabel('y')\n    else:\n        ax.set_yticklabels([])\n\nplt.tight_layout()\n\n\nIn the last example, we included a command, plt.tight_layout(), which automatically formats the figure to fit the window. This is most useful when using an IDE with a separate plotting window, rather than with in-line plots like those in a notebook. To get a sense of what plt.tight_layout() does, try re-running the above cell with this command commented out.\nTo go beyond regularly gridded subplots and create subplots that span multiple rows and/or columns, check out GridSpec.\n\nüìö  <b> Practice 1. </b> \nRecreate the plot below. You do not need to match the colors exactly, but do not rely on <span class=\"codeb\">matplotlib</span> defaults. Note: do not worry about the equation(s); these are included to indicate which functions to plot.\n\n\n\nüìö  <b> Practice 2. </b> \nRecreate the plot below. You do not need to match the colors exactly, but do not rely on <span class=\"codeb\">matplotlib</span> defaults. Note: do not worry about the equation(s); these are included to indicate which functions to plot.\n\n\n\n\n\nWorking with real data\n\n\nAs we learned in the previous exercise, working with real-world data usually complicates things, and plotting is no exception. In particular, working with time series can get a bit messy. Let‚Äôs take a look at our BSRN data as an example.\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\n# Import data\nbsrn = pd.read_csv('../data/BSRN_GOB_2019-10.csv',index_col=0,parse_dates=True)\n\n\nNow that we‚Äôve imported our data, let‚Äôs make a quick plot of incoming shortwave radiation over time.\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\n# Initialize empty figure\nfig = plt.figure()\n# Plot incoming SW radiation\nplt.plot(bsrn.index,bsrn.SWD_Wm2)\n# Label y-axis\nplt.ylabel(r'Incoming SW radiation (W m$^{-2}$)')\n\n\nThe x-axis looks rather messy because the tick labels are timestamps, which are, by nature, very long. Luckily, matplotlib has a module called dates for dealing with datetime objects.\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\nimport matplotlib.dates as mdates\n\n\nWithout going into too much detail, we can use some of the more advanced Axes settings to format and rotate the tick labels such that they no longer overlap, and we can use matplotlib.dates to format the timestamps. In short, we will use the mdates.DateFormatter() function to format the timestamps according to C formatting codes.\nThe following example demonstrates this, and includes a good code chunk for formatting timestamps to add to your repertoire. It is important to note that the formatting methods employed here are Axes methods, which means that we must operate on an Axes object, rather than the Figure.\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\n# Initialize empty figure and axes\nfig = plt.figure()\nax = fig.add_subplot(1,1,1)\n# Plot incoming SW radiation\nax.plot(bsrn.index,bsrn.SWD_Wm2)\n# Label y-axis\nax.set_ylabel(r'Incoming SW radiation (W m$^{-2}$)')\n\n# Format timestamps\nax.xaxis.set_major_formatter(mdates.DateFormatter('%d-%b-%y'))\n# Format and rotate ticks\nplt.setp(ax.get_xticklabels(), rotation=45, fontsize=10, ha='right')\nax.get_xticklabels()\n\n\n\nüìö  <b> Practice 3. </b> \nPlot temperature and relative humidity (ideally using subplots) over the month of October 2019 at the BSRN station. Be sure to format the timestamps and include axis labels, a title, and a legend, if necessary.\n\n\nüìö  <b> Practice 4. </b> \nSaturation vapor pressure, $e^*(T_a)$, is the maximum pressure of water vapor that can exist in equilibrium above a flat plane of water at a given temperature. It can be calculated from the Tetens equation:\n$$e^{*}(T_{a}) \\, = \\, a \\, e^{\\frac{b\\, \\cdot \\, T_{_a}}{T_{_a}\\, + \\, c}} $$\nwhere T_a is the air temperature in ¬∞C, a = 0.611 \\, \\text{kPa}, b = 17.502, and c = 240.97^{\\circ} \\text{C}. \n\n\nCalculate e^*(T_a) in kPa for all temperatures in bsrn.\n\n\nPlot temperature vs.¬†saturation vapor pressure for the BSRN station. Be sure to format your plot appropriately and include axis labels, a title, and a legend, if necessary.\n\n\nCompare your plot to Figure 3-1 in Campbell and Norman (1998). Do they look more or less the same?\n\n\n\n\nüìö  <b> Practice 5. </b> \nThe difference between saturation vapor pressure and ambient air pressure is called vapor pressure deficit, $\\textit{VPD}$. $\\textit{VPD}$ can be calculated from saturation vapor pressure and relative humidity, $h_r$, as follows:\n$$ \\textit{VPD} \\, = \\, e^*(T_a) \\cdot (1 \\, - \\, h_r)$$\nwhere h_r is expressed as a fraction.\n\n\nCalculate the vapor pressure deficit for the BSRN data.\n\n\nCalculate the mean hourly e^*(T_a) and \\textit{VPD} over the entire month.\n\n\nPlot e^*(T_a) and \\textit{VPD} as a function of time of day. (Bonus: if you want to get fancy, plot both variables on one plot using  ax.twinx().)\n\n\nHow does relative humidity vary throughout the day? Why?\n\n\nCompare your plot(s) to Figure 3-3 in Campbell and Norman (1998). How do the values of e^*(T_a) and \\textit{VPD} for the BSRN station compare to those at constant vapor pressure in Figure 3-3?\n\n\n\n\n\n\n\nCode\n# IGNORE THIS CELL\nfrom IPython.core.display import HTML\ndef css_styling():\n    styles = open(\"./styles/exercises.css\", \"r\").read()\n    return HTML(styles)\ncss_styling()"
  },
  {
    "objectID": "Exercise3_Scipy.html",
    "href": "Exercise3_Scipy.html",
    "title": "",
    "section": "",
    "text": "‚¨ÖÔ∏è Previous Exercise | üè† Index | ‚û°Ô∏è Bonus Content! |"
  },
  {
    "objectID": "Exercise3_Scipy.html#determine-yearly-rainfall-totals.",
    "href": "Exercise3_Scipy.html#determine-yearly-rainfall-totals.",
    "title": "",
    "section": "Determine yearly rainfall totals.",
    "text": "Determine yearly rainfall totals.\nThe most common ‚Äì but not always the most useful ‚Äì interval of rainfall characterization is annual. Let‚Äôs see what years we have available to investigate annual rainfall, using the pd.unique() function.\n\n‚úèÔ∏è <b> Try it. </b> \nUse the <code>pd.unique()</code> function to get a list of the unique years contained in the <code>Year</code> column of our dataframe, <code>df</code>. Assign this list of years to a new array called <code>all_years</code>\n\nIf all goes well, you should get results that look like this:\n\n> print(all_years)\n\n[1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985\n 1986 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999\n 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013\n 2014 2015 2016 2017]\nIt looks like we have almost five decades of rainfall data. The first thing we might want to do with this data is look at yearly summaries.\n\n\n\nüìö  <b> Practice 1. (The following steps can be combined into a single line of code)</b> \n\n\nDetermine the annual rainfall totals for each year.\n\n\nUse method chaining combined with the df.groupby() function to get the sum of every year‚Äôs rainfall.\n\n\nUse the argument min_count in the sum() command to force pandas to only include sums of rainfall for years with at least 350 days of data.\n\n\nAssign these totals to a new Series variable called yearly_rainfall_total.\n\n\n\nIf all goes correctly, you should get results that look like this:\n> yearly_rainfall_total.head()\n\nYear\n1972    681.228\n1973        NaN\n1974    378.968\n1975    791.464\n1976    363.220\nName: Rainfall (mm), dtype: float64"
  },
  {
    "objectID": "Exercise3_Scipy.html#quantifying-rainfall-variability",
    "href": "Exercise3_Scipy.html#quantifying-rainfall-variability",
    "title": "",
    "section": "Quantifying rainfall variability",
    "text": "Quantifying rainfall variability\nWe can use the coefficient of variation to describe rainfall variability. The coefficient of variation, CV, of a group of numbers is the ratio of the standard deviation, \\sigma, to the mean, \\mu. We can calculate the population CV of a sample, \\widehat{CV}, as the ratio of standard deviation of the sample, s, and the sample mean, \\bar{x}:\n \\widehat{CV} = \\frac{s}{\\bar{x}} \n\n‚úèÔ∏è <b> Try it. </b>    \nCreate a histogram of yearly rainfall amounts using the hist() command that is a built-in method of any pandas.Series.   Note: Your variable, yearly_rainfall_total should be a pandas.Series object.\n\nWe have a very pronounced mode, with a large degree of variation. Let‚Äôs calculate the \\widehat{CV}.\n\n‚úèÔ∏è <b> Try it. </b>    \nUse the formula above to calculate the \\widehat{CV} for the data in yearly_rainfall_total.\n\n\\widehat{CV} has some problems dealing with small sample sizes (n) and tends to be biased low. We can create an unbiased estimator, \\widehat{CV}^{*} using the following function{^1}:\n \\widehat{CV}^{*} = \\left(1 + \\frac{1}{4n}\\right)\\widehat{CV} \n{^1} technically, \\widehat{CV}^{*} is only valid for normally-distributed data, but we will use it anyway as an example.\n\nüìö  <b> Practice 2.</b>\nCreate a function that calculates the $\\widehat{CV}^{*}$ for a set of data and use the function to determine the $\\widehat{CV}^{*}$ value for our yearly rainfall data."
  },
  {
    "objectID": "Exercise3_Scipy.html#examining-daily-rainfall-probabilities-and-amounts",
    "href": "Exercise3_Scipy.html#examining-daily-rainfall-probabilities-and-amounts",
    "title": "",
    "section": "Examining daily rainfall probabilities and amounts",
    "text": "Examining daily rainfall probabilities and amounts\nAs we see from the analysis of yearly and monthly rainfall, the climatology of this location is characterized by a fairly high degree of variability. The same is true of many tropical drylands.\n\n1. What is the chance that it will rain?\nIn order to get at the rainfall process itself, let‚Äôs look at the distribution of rainfall events. We can find all the days of rainfall by simply filtering our DataFrame to find days when rain was greater than zero. To do this, we can use the loc() function.\nThe following line of code returns a new dataframe that contains only the rows where 'Rainfall (mm)' is greater than zero:\nrainy_days = df.loc[ (df['Rainfall (mm)'] > 0) ]\n\nüìö  <b> Practice 3.</b>\nCalculate the overall probability of daily rainfall.\n<ol class=\"alpha\">\n    <li> Create a <code>DataFrame</code> containing only rainy days (when rainfall is greater than zero) called <code>rainy_days</code></li>\n    <li> Create a <code>DataFrame</code> consisting of all observation days (when rainfall is not equal to <code>NaN</code>) called <code>all_days</code></li>\n    <li> Use the ratio of the length of <code>rainy_days</code> and <code>all_days</code> to determine the probability of rainfall and save this as a new variable called <code>prob_rain</code>.</li>\n</ol>\n\nIf all goes well, then you should get the following value for prob_rain:\n\n> print(prob_rain)\n0.13211859564472098\n\n\n\n\nMonthly Rainfall Totals and Probabilities\nOver the entire time period, the probability of rainfall was about 13%, which means that it rains - on average - a little less than once per week (approximately every 7.7 days). However, most regions have strong seasonality in rainfall. Our data comes from a site that is located very close to the equator in central Kenya. This means that the movement of the ITCZ across the tropics causes changes in the likelihood of rainfall from month to month. We should therefore look at monthly rainfall probabilies rather than simply the annual average.\n\nüìö  <b> Practice 4.</b>\n<ol class=\"alpha\">\n    <li> Determine the probability of rainfall for each month. Add these values to a list called <code>lambda_by_month</code>. Hint: You can combine test criteria using logical operators (i.e. <code>&</code> and <code>|</code>).\n    <li>Create a bar graph of the monthly rainfall probabilites. Label your plot appropriately.\n</ol>\n\n\n\n2. What is the amount that it will rain?\nWe‚Äôve already subsetted all of our data for days with rain and stored this in the variable rainy_days. Let‚Äôs look at the distribution of rain amounts:\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\nrainy_days['Rainfall (mm)'].hist(bins=50)\n\n\nAs opposed to the annual rainfall distribution, the distribution of daily storm totals (or daily rainfall) has a much clearer distribution. This pattern of daily rainfall ‚Äì a positively skewed distribution with a short-tail ‚Äì is very consistent with what we see across tropical drylands, and even more broadly across any location where rainfall is dominated by convective processes. We might ask what the average storm total is‚Ä¶\n\n‚úèÔ∏è <b> Try it. </b>    \nCalculate the average rainfall amount on rainy days over the data record. Save this quantity as a new variable called <code>avg_rainfall_depth</code>."
  },
  {
    "objectID": "Exercise3_Scipy.html#fitting-rainfall-depths-to-an-exponential-distribution",
    "href": "Exercise3_Scipy.html#fitting-rainfall-depths-to-an-exponential-distribution",
    "title": "",
    "section": "Fitting rainfall depths to an exponential distribution",
    "text": "Fitting rainfall depths to an exponential distribution\nA simple rainfall model makes two assumptions; (1) that events arrive according to a Poisson process, and (2) that rainfall depths are distributed according to an exponential distribution. These two assumptions are accompanied by the need for two rainfall parameters; (1) the probability of rainfall events, \\lambda_r, and the average depth of rainfall events \\alpha. We‚Äôve already seen how to estimate both of these parameters from rainfall data, so here we are going to focus on testing the appropriateness of the model assumptions during the growing season for Laikipia, Kenya.\n\nStep 1. Fit the distribution\nTo fit the distribution, we are going to use some more functions from python‚Äôs suite of numerical analysis. In this case we are going to use some functions from scipy. The scipy.stats module has a large suite of distribution functions pre-defined, which we can use to develop a fit for our data. Using any of these distributions for fitting our data is very easy. The distribution we are most interested in is the exponential distribution, which is called expon in the stats module.\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\nimport scipy.stats as st\n\ndistribution = st.expon\ndata = rainy_days['Rainfall (mm)']\nparams = distribution.fit(data, loc=0) # Force the distribution to be built off of zero\n\nprint(params)\n\narg = params[:-2]\nloc = params[-2]\nscale = params[-1]\n\n\n\n\nStep 2. Calculate fitted PDF and error with fit in distribution\nTo test the fit of our distribution, we can compare the empirical histogram to that predicted by our model. To do this, we first use our data to generate the empirical histogram. In this exampkle, we break the data into 30 bins, and we generate a histrogram of density rather than counts. This allows for an easier comparison between our empirical data and the fitted probability distribution function. Here are the steps:\n\nGenerate a histogram, from the data. Save the bin locations in x and the density of values in y\nShift the x bin locations generated from the histogram to the center of bins.\nCalculate the value of the fitted pdf(x) for each of the bins in x.\nDetermine the residual sum of the squares, SS_{error}, and total sum of squares, SS_{yy}, according to:\n\n SS_{error} = \\sum_{i=1}^{n} \\left(y_i - f(x_i)\\right)^2   SS_{yy} = \\sum_{i=1}^{n} \\left(y_i - \\bar{y}\\right)^2 \n\nCalculate the r^2 of the fit, according to\n\n r^2 = 1- \\frac{SS_{error}}{SS_{yy}} \n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\n# Step 1. Generate a density histogram of the data \ny, x = np.histogram(data, bins=30, density=True)\n\n# Step 2. Shift the x bin locations to the center of bins.\nx = (x + np.roll(x, -1))[:-1] / 2.0\n\n# Step 3. Calculate the values of pdx(x) for all x.\npdf = distribution.pdf(x, loc=loc, scale=scale, *arg)\n\n# Step 4. Determine the residual and total sum of the squares.\nss_error = np.sum(np.power(y - pdf, 2.0))\nss_yy = np.sum(np.power(y - y.mean(), 2.0))\n\nr_2 = 1 - ( ss_error / ss_yy )\nprint(r_2)\n\n\nThese results suggest that an exponential distribution is a really good fit for our observed data on rainfall amounts."
  },
  {
    "objectID": "Exercise3_Scipy.html#modeling-rainfall",
    "href": "Exercise3_Scipy.html#modeling-rainfall",
    "title": "",
    "section": "Modeling rainfall",
    "text": "Modeling rainfall\nLet‚Äôs make a very simple model of rainfall that assumes a Poisson process (i.e.¬†a memoryless process). We just saw that this approach is probably too simple, and later we will look at how we could improve the model. But it helps to start with the most simple approach and then add complexity as needed.\nOur model will be built with the following assumptions:\n\nThe probability of an ‚Äúevent‚Äù (i.e.¬†rainfall) occuring on any given day is given by the parameter \\lambda_r, which has units day^{-1}\nThe total depth of rainfall on days with rain is a random variable, drawn from an exponential distribution with mean, \\alpha, which has units of mm.\n\nThis type of model is a ‚Äúmarked Poisson process‚Äù and is a special case of a Poisson process on a number line (in our case, the number line is time), where each event is characterized by a random ‚Äúmark‚Äù that is independent of the event.\n\nStep 1. Simulating Poisson events\nWe have a variety of means to simulate a Poisson process, and all of them will require the use of a random number generator. The numpy package has lots of different builtin functions to generate pseudo-random numbers, and we can use one of these.\nTo simulate the likelihood of a Poisson event, we can draw a sample from a uniform distribution in [0,1] and compare that to our probability of an event. If the value we draw is less than or equal to our probability, then an event occurs, otherwise no event occurs. The probability density function, f(x) of a uniform distribution sampled over the half open interval from a to b, [a,b) is given by\n\nf(x) = \\frac{1}{b - a}\n\nWe can sample from this distribution using the np.random.uniform() function:\n\ns = np.random.uniform(low=0,high=1)\nThe np.random.uniform() function also takes the optional argument size, which specifies the number of random samples to return. This allows for the generation of large lists of random samples without using a for loop or list comprehension approaches.\n# Returns an array of 2 random draws.\ns = np.random.uniform(low=0, high=1, size=2) \n\n# Returns an array of 2 rows each with 10 random draws\ns_mat = np.random.uniform(low=0, high=1, size=[2, 10])\n\n‚úèÔ∏è <b> Try it. </b>    \nUsing a $\\lambda_r$ value equal to your calculated value of <code>prob_rain</code> and assuming that the length of a growing season, $T_{seas}$, is 160 days, simulate a season of rainfall \"events\", where the value of a day is <code>1</code> if rainfall occurs, and <code>0</code> if not.</div>\n\n\nüí° You can use the pd.astype() command to force Boolean (True/False) values into integers (1,0)\n\n\n\nStep 2. Adding marks to events\nOur approach for creating marks (i.e.¬†daily rainfall depths) is to sample them randomly from an exponential distribution with mean \\alpha. The exponential probability density function f(x) for x\\gt0 as a function of \\alpha is expressed as\n\nf(x) = \\frac{1}{\\alpha} \\exp\\left(-\\frac{x}{\\alpha}\\right),\n\nJust as with sampling from a uniform distribution (and as with most everything in python/pandas), there‚Äôs a function for that. In this case, we are going to use the‚Ä¶ you guessed it‚Ä¶ np.random.exponential() function. It is used similarly to the np.random.uniform() function, but with a single parameter to describe the distribution:\ns = np.random.exponential(scale=11.5) \nThe scale parameter is the mean of the distribution, which in our simulations will be \\alpha (mm), the average rainfall depth on days with rain. Just as with np.random.uniform(), we can generate lists or arrays of samples from the exponential distribution.\n\ns = np.random.exponential(scale=11.5, size=2) # Returns an array of 2 random draws.\n\ns_mat = np.random.uniform(scale=11.5, size=[2, 10]) # Returns an array of 2 rows each with 10 random draws.\n\n‚úèÔ∏è <b> Try it. </b>    \nUse the average storm depth (<code>avg_rainfall_depth</code>), probability of rainfall you calculated earlier, and the same $T_{seas}$ as before, generate a season of rainfall.</div>\n\nüí° The product of 0 and any rainfall amount is still 0. That means you don‚Äôt need to worry about which days have rain and which don‚Äôt when multiplying a list of rainfall_amounts and a binary list of rain_days.\n\n\n\nSimulating multiple years of rainfall\n\nüìö  <b> Practice 5.</b>\nUsing your <code>prob_rain</code> and your <code>avg_rainfall_depth</code>:\n<ol class=\"alpha\">\n    <li> Generate 100 years of rainfall.</li>\n    <li> Plot a histogram of the annual totals.</li>\n    <li>Calculate the $\\widehat{CV}$ of seasonal rainfall.</li>\n</ol>\n\n\n\nCode"
  },
  {
    "objectID": "Exercise3_Scipy.html#conditional-probabilities-given-that-today-was-rainy-will-it-rain-tomorrow",
    "href": "Exercise3_Scipy.html#conditional-probabilities-given-that-today-was-rainy-will-it-rain-tomorrow",
    "title": "",
    "section": "Conditional Probabilities: Given that today was rainy, will it rain tomorrow?",
    "text": "Conditional Probabilities: Given that today was rainy, will it rain tomorrow?\nFinally, we want to look to see if we can predict rainfall. The easiest way to think about predictability is to ask whether or not knowing what happened today significantly alters our expectation about what will happen tomorrow. There are two options:\n\nIf every day is random and unpredictable, then rainfall tomorrow will be independent of what happened today.\nIf what happens today affects tomorrow, then we should see dependency between today and tomorrow‚Äôs rainfall.\n\nWe can test the independence of rainfall likelihood by testing to see if rainfall on day t affects the probability of rainfall on day t+1.\nFormally, we can write the probability that rainfall, R, on some day t,is greater than zero as P[R_t>0]. If $ P[R_t>0] = P[R_t>0 | R_{t-1} >0] $, then we can say that P[R_t] and P[R_{t-1}] are independent.\nFirst, we use the index property of rainy_days, which is just a list of all the index values (or rows) in our original data, df, where rainfall was greater than zero. Then we increment the index and save all these rows from the original data into a new variable, days_after_rain.\n\nüìö  <b> Practice 6.</b>\n<ol class=\"alpha\">\n    <li> Make a list of the index locations of <code>rainy_days</code> using the <code>index</code> attribute of <code>rainy_days</code>.</li>\n    <li> Create a new dataframe called <code>days_after_rain</code> that contains only the days after rainy days. You will need to use our original <code>df</code> dataframe to get this new dataframe.</li>\n    <li>Calculate the probability of rainfall following rainy days using your new <code>days_after_rain</code> variable. Call this new probability <code>prob_rain_after_rain</code></li>\n    <li>Compare the probability of rainfall following rainy days (<code>prob_rain_after_rain</code>) to the overall probability of rainfall (<code>prob_rain</code>). Based on these values, is an assumption of independence in the rainfall process valid?</li>\n</ol>"
  },
  {
    "objectID": "Exercise3_Scipy.html#simulating-annual-rainfall-with-monthly-values",
    "href": "Exercise3_Scipy.html#simulating-annual-rainfall-with-monthly-values",
    "title": "",
    "section": "Simulating annual rainfall with monthly values",
    "text": "Simulating annual rainfall with monthly values\nOne improvement we can make to our model is to have monthly values for our rainfall probabilities. To get these monthly \\lambda_r values, we need to determine the probability of rainfall for each month by dividing the number of rainy days per month by the total number of observations in each month, which we did in Practice 4. For now, we assume stationarity in the monthly values, which means that we are assuming that the values of \\lambda_r in each month are the same through out the entire record (i.e.¬†Jan 1938 has the same properties as Jan 2008).\n\nüí° It‚Äôs worth thinking about how you could test our stationarity assumption. If you have an idea of how to do so, go ahead and give it a shot!\n\nTo improve our simulation of annual rainfall, we are going to use our monthly values to specify daily values of \\lambda_r using the monthly values we just calculated. The use of a variable \\lambda value in a Poisson process creates what is known as an ‚Äúinhomogenous Poisson process‚Äù (or, alternatively, ‚Äúnonhomogeneous‚Äù‚Ä¶ unfortunatetly, there isn‚Äôt much homogeneity in what we call it!). These types of processes allow the properties of the process to change in space and time. Our implementation ‚Äì using monthly values ‚Äì is a little clunky, and we‚Äôd prefer to have the \\lambda values change more smoothly throughout the year. However, we probably don‚Äôt have sufficient data to allow for this, even if we could accomodate the more complicated coding it would require.\nIn order to generate our nonhomogenous process, we will first generate a daily array of month numbers for the year 2018. This is really easy in python using datetime + timedelta (which we need to import).\n    from datetime import timedelta, datetime\n    datetimes = np.arange(\n        datetime(2018,1,1), datetime(2018,12,31),\n        timedelta(days=1)).astype(datetime)\n    month_value_by_day = np.array([datetime.month for datetime in datetimes])\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\nfrom datetime import timedelta, datetime\ndatetimes = np.arange(datetime(2018,1,1), datetime(2019,1,1), timedelta(days=1)).astype(datetime)\nmonth_value_by_day = np.array([datetime.month for datetime in datetimes])\n\n\nNow we have a 12-element np.array of \\lambda_r values, organized by month number, which we‚Äôve stored in lambda_by_month and we have a list of 365 days that contains the month number for each day, which we‚Äôve stored in month_value_by_day. We can use these two variables to get a new variable that contains the correct \\lambda value for each day.\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\ndaily_lambda_values = np.array([lambda_by_month[i-1] for i in month_value_by_day])\n\n\nWith daily values of \\lambda_r, we only need to follow the same cookbook we used to make the stationary simulation.\n    simulated_rainy_days = (\n        np.random.uniform(\n            low=0, high=1, size=len(daily_lambda_values)\n        ) <= daily_lambda_values).astype(int)\n    simulated_rainfall_values = np.random.exponential(\n        scale=alpha, size=len(daily_lambda_values)\n    )\n\n‚úèÔ∏è <b> Try it. </b>    \nUse the code above to create a new daily rainfall simulation using our daily values of $\\lambda_r$. Plot the daily rainfall data. You can easily plot your rainfall data using the <code>datetimes</code> object we already created as the basis of our x-axis.</div>"
  },
  {
    "objectID": "Lab-1_Catchment_Water_Balance.html#instructions",
    "href": "Lab-1_Catchment_Water_Balance.html#instructions",
    "title": "",
    "section": "1. Instructions",
    "text": "1. Instructions\nWork through the exercise, writing code where indicated. To run a cell, click on the cell and press ‚ÄúShift‚Äù + ‚ÄúEnter‚Äù or click the ‚ÄúRun‚Äù button in the toolbar at the top. Note: Do not restart the kernel and clear all outputs. If this happens, run the last cell in the notebook before proceeding.\n\nüêç ¬† ¬† This symbol designates an important note about Python structure, syntax, or another quirk.\n\n\nüìä ¬† ¬† This symbol designates an important note about Environmental Data methods, sources, and access.\n\n\n‚ñ∂Ô∏è ¬† ¬† This symbol designates a cell with code to be run.\n\n\n‚úèÔ∏è ¬† ¬† This symbol designates a partially coded cell with an example.\n\n\nüìö ¬† ¬† This symbol designates a practice question."
  },
  {
    "objectID": "Lab-1_Catchment_Water_Balance.html#setting-up-the-lab",
    "href": "Lab-1_Catchment_Water_Balance.html#setting-up-the-lab",
    "title": "",
    "section": "2. Setting up the Lab",
    "text": "2. Setting up the Lab\nhydrodata is a Python library designed to aid in watershed analysis. Hydrodata is capable of downloading, preprocessing, and visualizing climatological, hydrological, and geographical datasets pertaining to a given watershed. Supported datasets include: Daymet climate, USGS streamflow, and data from the National Land Cover Dataset.\n\n2.1 Hydrodata\nIt‚Äôs easy to use hydrodata to get streamflow data for any USGS gauge. In the background for this lab, we will be looking at some gauges across southern California. Your lab will focus on a stream gauge near to some favorite (or personally interesting) place in the U.S.\nfrom hydrodata import Station\nimport hydrodata.datasets as hds\n\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\nimport pandas as pd\nfrom hydrodata import Station\nimport hydrodata.datasets as hds\n%matplotlib inline\nimport warnings\nwarnings.filterwarnings(\"ignore\") # Don't output warnings\n\n\nModuleNotFoundError: No module named 'pandas'"
  },
  {
    "objectID": "Lab-1_Catchment_Water_Balance.html#background",
    "href": "Lab-1_Catchment_Water_Balance.html#background",
    "title": "",
    "section": "3. Background",
    "text": "3. Background\nThis lab is going to give you some first exposure to doing analysis in pandas and creating your own Jupyter notebooks for presenting results and information. The main concept we will be considering is mass balance. Along with energy and momentum, mass is one of the three consitutents that are conserved in environmental systems. More generally, physical systems can be written as a statement of mass, energy, or momentum. The key to creating these statements (or equations) of balance is determining the bounds of the system (its geographic extent and structure) as well as the specific processes acting across those boundaries.\nLet‚Äôs take a look at a typical river basin, the upper portions of the Sisquoc River, which is a westward flowing river in northeastern Santa Barbara County, California. The Sisquoc is a tributary of the Santa Maria River, which is formed when the Sisquoc River meets the Cuyama River at the Santa Barbara County and San Luis Obispo County border just north of Garey. The river is 57.4 miles (92.4 km) long and originates on the north slopes of Big Pine Mountain, at approximately 6,320 feet (1,930 m). Big Pine Mountain is part of the San Rafael Mountains, which are part of the Transverse Ranges. Sisquoc is the Chumash word meaning ‚Äúquail‚Äù and the Sisquoc River is a designated National Wild and Scenic River managed by the US Forest Service.\nWe can use the hydrodata library Station object, which we imported earlier. To create an instance of the Station class, we need to specify a USGS station_id, which is a unique code that identifies each of the USGS gauging locations across the United States. In addition, we need to specify a start and anend date for our data request. These dates are used to determine what streamflow data to collect, as well as other meteorological data, which we will see later in the background section.\nFor this lab, we will be looking at the 2016, 2017, and 2018 water years. Water years are a bit like school years - they start in the fall instead of on January 1st. Specifically, a single water year begins on October 1 and ends on September 30th of the following year. Water years are designated by the calendar years in which they end (e.g.¬†WY 2015 began on October 1, 2014 and ended on September 30, 2015). Therefore, we will start our collection on the 1st of October 2015 and end our data on September 30, 2018.\nstation_id = '11138500'  # This is a USGS station ID. Later, I will show you how to find one on your own!\nstart = '2015-10-01'     # Start date is the Oct. 1, 2015 which is the start of the 2016 water year.\nend = '2018-09-30'       # End date is the Sept 30, 2018 which is the end of the 2018 water year.\n\n# Create our watershed object using the station_id, start, and end dates\nwshed = Station(start=start, end=end, station_id=station_id, data_dir=\"data/\")\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\nstation_id = '11138500'  # This is a USGS station ID. Later, I will show you how to find one on your own!\nstart = '2015-10-01'     # Start date is the Oct. 1, 2015 which is the start of the 2016 water year.\nend = '2018-09-30'       # End date is the Sept 30, 2018 which is the end of the 2018 water year.\n\n# Create our watershed object using the station_id, start, and end dates\nwshed = Station(start=start, end=end, station_id=station_id, data_dir=\"../data/lab_1/\")"
  },
  {
    "objectID": "Lab-1_Catchment_Water_Balance.html#visualizing-watersheds",
    "href": "Lab-1_Catchment_Water_Balance.html#visualizing-watersheds",
    "title": "",
    "section": "3.1 Visualizing watersheds",
    "text": "3.1 Visualizing watersheds\nA watershed (or catchment, or drainage basin) is any area of land where precipitation collects and drains off into a common outlet, such as into a river, bay, or other body of water. The watershed includes all the surface water from rain, runoff, snowmelt, hail, sleet and nearby streams that run downslope towards the shared outlet, as well as the groundwater underneath the Earth‚Äôs surface. Watersheds are hierarchical, which means they connect into other watersheds at lower elevations, with smaller sub-drainage basins, which in turn drain into another common outlet. This pattern of self-similar, hierarchical structures means that watersheds and their associated stream networks form a stochastic fractal network that collectively routes water and sediment over the Earth‚Äôs surface. Visualizing a watershed requires defining an outlet, which identifies the lowest point of the catchment and the location through which all surface water drains. In this lab, we will define the outlet of a watershed as the location of a USGS streamflow gauge. By linking the definition of our watersheds to the location of streamflow gauges, we will be able to examine the mass balance of the watershed. Before diving into the principles of mass balance as they apply to watersheds, let‚Äôs first spend a little time learning how to acquire and visualize watersheds based on the location of a USGS streamgauge.\n\n3.1.1 Viewing Watershed Hydrography\nWe can use some of the dataset interfaces provided by hydrodata to map the stream channels within our watershed.\n\nüìä <b>HNDPlus</b>: The best source for hydrography data is the National Hydrography Dataset known as <a href=\"https://www.usgs.gov/core-science-systems/ngp/national-hydrography/nhdplus-high-resolution\">NHDPlus</a>. The NHDPlus High Resolution (HR) is a national, geospatial model of the flow of water across the landscape and through the stream network. The NHDPlus HR is built using the National Hydrography Dataset High Resolution data at 1:24,000 scale or better, the 1/3 arc-second (10 meter ground spacing) 3D Elevation Program data, and the nationally complete Watershed Boundary Dataset. \n\nAccess to the NHDPlus dataset is provided by the NLDI object, which is part of hydrodata‚Äôs datasets class, which we imported earlier as hds. To query these datasets, we use the following code:\n# Find the hydrography associated with this station using the wshed.station_id:\ntributaries = hds.NLDI.tributaries(wshed.station_id)\nmain_channel = hds.NLDI.main(wshed.station_id)\nstations = hds.NLDI.stations(wshed.station_id)\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\n# Find the hydrography associated with this station using the wshed.station_id:\ntributaries = hds.NLDI.tributaries(wshed.station_id)\nmain_channel = hds.NLDI.main(wshed.station_id)\nstations = hds.NLDI.stations(wshed.station_id)\n\n\nWe can then plot these data using internal hydrodata plotting functions, which are special versions of matplotlib plotting functions with extra features for viewing our stream channels.\n\n# Create a plot of the basin boundaries, main channel, tributaries, and station locations. \nax = wshed.basin.plot(color='white', edgecolor='black', zorder=1, figsize = (10, 10))\ntributaries.plot(ax=ax, label='Tributaries', zorder=2)\nmain_channel.plot(ax=ax, color='green', lw=3, label='Main', zorder=3)\nstations.plot(ax=ax, color='black', label='All stations', marker='s', zorder=5)\nax.legend(loc='upper left');\nax.figure.set_dpi(100);\nax.set_title(u'Sisquoc River near Sisquoc, CA ({lon:.2f}\\U000000b0W, {lat:.2f}\\U000000b0N)'.format(\n    lon=abs(my_station.lon),\n    lat=my_station.lat))\n\nüêç <b>A Brief Aside About Python & Unicode.</b> In the code above, we include a <code>u</code> preceding the string in the <code>ax.set_title()</code> command. The letter <code>u</code> before a string is an indicatation that python should convert any <a href=\"https://en.wikipedia.org/wiki/Unicode\"><code>unicode</code></a> symbols within the string when displaying it. In this case, we included <code>\\U000000b0</code>, which is the unicode symbol for a degree sign (¬∞), so our figure title will include these symbols when we run the code. \nYou can find the most recent unicode definitions for over one hundred and fifty thousand written characters, symbols, and emojis at https://unicode-table.com/en/. Any of these Unicode representations can be expressed in a python string using an encoding that starts with a /code> and is followed by exactly 8 values. Therefore, to use any unicode value in your python strings - for example, the smiling emoji, üòÅ, which is listed as unicode symbol U+1F601 - you would include the unicode number (1F601) inside an 8-digit python unicode representation that would look like this: 001F601. The most common unicode symbols that were developed first, like the ¬∞ sign, only have 4 digits (U+00b0), so we must add 4 zeros before the symbol to get to a the 8-element representation that python requires: 00000b0.\n\n\n‚ñ∂Ô∏è <b> Run the cell below. (Feel free to experiment with some unicode characters in the title!)</b>\n\n\n\nCode\n# Create a plot of the basin boundaries, main channel, tributaries, and station locations. \nax = wshed.basin.plot(color='white', edgecolor='black', zorder=1, figsize = (10, 10))\ntributaries.plot(ax=ax, label='Tributaries', zorder=2)\nmain_channel.plot(ax=ax, color='green', lw=3, label='Main', zorder=3)\nstations.plot(ax=ax, color='black', label='All stations', marker='s', zorder=5)\nax.legend(loc='upper left');\nax.figure.set_dpi(100);\nax.set_title(u'Sisquoc River near Sisquoc, CA ({lon:.2f}\\U000000b0W, {lat:.2f}\\U000000b0N)'.format(\n    lon=abs(wshed.lon),\n    lat=wshed.lat))\n\n\nIn the map above, we can the main branch (green line) of the portion of the Sisquoc River above the town of Sisquoc, CA. The river is flowing in an East-West direction. You can also get a sense of the basin strucuture, which is very typical for a headwater river. There are many side tributaries that extend outward from the main branch, and the overall shape of the basin is such that it is widest just below the mid-point of the main branch. The fractal structure of the draininge network is very apparent.\n\nüìä <b> Fractal River Basins.</b>\nIf you‚Äôd like to learn more about the fractal geometry of river networks and their importance for governing mass and energy fluxes across the land surface, check out Fractal River Basins: Chance and Self-Organization written by Ignacio Rodriguez-Iturbe and Andrea Rinaldo.\n\n\n\n3.1.2 Viewing Basin Topography Using Digital Elevation Data\nWe can get a better sense of this topography using Digital Elevation Data released by the USGS.\n\nüìä <b>National Elevation Dataset.</b> The National Elevation Dataset (NED) is a seamless raster product primarily derived from USGS 10- and 30-meter Digital Elevation Models (DEMs). NED data are available from The National Map Viewer as 1 arc-second (approximately 30 meters) for the CONUS, and at 1/3 and 1/9 arc-seconds (approximately 10 and 3 meters, respectively) for parts of the United States. The NED can be accessed through the <a href=\"https://www.usgs.gov/core-science-systems/national-geospatial-program/national-map\">National Geospatial Program</a>. The next generation of US elevation data is being created as part of the <a href=\"https://www.usgs.gov/core-science-systems/ngp/3dep\">3DEP</a> program. This program's goal is to complete acquisition of nationwide lidar (IfSAR in AK) by 2023 to provide the first-ever national baseline of consistent high-resolution elevation data ‚Äì both bare earth and 3D point clouds ‚Äì collected in a timeframe of less than a decade. \n\nThe hydrodata library makes it easy to query the National Elevation Dataset to obtain 1 arc-second (~30 meter) digital elevation model (DEM) for any watershed in the United States. Because we already have our basin boundaries, we can make a targeted request to get only the elevation data inside our basin. Then we just make another figure that depicts the elevation data for our basin using a builtin method that is part of the class created by our data request:\n\n# Grab the watershed Digital Elevation Data from the USGS:\ndem = hds.dem_bygeom(wshed.geometry, resolution=1)\ndem.plot(size=8);\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\n# Grab the watershed Digital Elevation Data from the USGS:\ndem = hds.nationalmap_dem(wshed.geometry, resolution=1)\ndem.plot(size=8);"
  },
  {
    "objectID": "Lab-1_Catchment_Water_Balance.html#a-catchment-as-a-physical-system",
    "href": "Lab-1_Catchment_Water_Balance.html#a-catchment-as-a-physical-system",
    "title": "",
    "section": "3.2 A Catchment as a Physical System",
    "text": "3.2 A Catchment as a Physical System\nIn hydrological sciences, we use the idea of a catchment (or river basin) as the boundary of a system through which water flows. Because water has a relatively constant density (1 g H2O = 1 cm3 H2O), we can measure water balance in terms of water volume (m3) in addition to water mass (103 kg).\nThe water balance of a catchment is determined by the sum of inputs and outputs of water. If inputs are greater than outputs, the catchment is gaining water. If outputs are greater than inputs, the catchment is losing water. In the special case where outputs and inputs are equal, the catchment is neither gaining nor losing water, and the amount of water in the catchment is constant with time, meaning it is in steady state.\nThe primary input of water into the land surface is through precipitation (P [m3]). Precipitation usually takes the form of either rain or snow. There are two main ways that water exits a catchment: (1) the transport of water out of the catchment through streamflow (or river discharge); and (2) the transport of water back into the atmosphere in the form of vapor, which is released from either soils (evaporation, E [m3]) or plants (transpiration, T [m3]). For simplicity, we often combine evaporation and transpiration into a single quantity, evapotranspiration (ET).\nHaving specified the important inputs and outputs, the change in storage of water in the catchment (\\Delta S, [m3]) can be written as:\n \\Delta S = P - ET - Q \nIn small basins, most of this stored water, S, is held in the soil. In larger basins, the storage of water in groundwater can be very important, as can the net movement of groundwater into and out of the basin. Finally, in basins where freezing conditions are common, large amounts of water can be stored as snow and ice.\nUsually, we calculate the water balance over discrete time intervals, \\Delta t (e.g.¬†days, or years), in which case, the equation becomes:\n\\frac{\\Delta S}{\\Delta t} = P(t) - ET(t) - Q(t) \nand we have implicitly re-defined the units of P, ET, and Q to be mass per time, [m3/t]."
  },
  {
    "objectID": "Lab-1_Catchment_Water_Balance.html#obtaining-precipitation-discharge-and-rainfall-data-for-a-usgs-station",
    "href": "Lab-1_Catchment_Water_Balance.html#obtaining-precipitation-discharge-and-rainfall-data-for-a-usgs-station",
    "title": "",
    "section": "3.3 Obtaining Precipitation, Discharge, and Rainfall data for a USGS station",
    "text": "3.3 Obtaining Precipitation, Discharge, and Rainfall data for a USGS station\nSo far, we‚Äôve been able to define a catchment upstream of a USGS gauge and visualize basin stream networks and topography. In order to study our simple basin water balance, we will need to obtain data on each of the three main fluxes: Q, P, and ET.\n\n3.3.1 Discharge Data for our Station\nThe hydrodata allows us to access streamflow data stored in the National Water Information System (NWIS), which contains water resource data for almost 1.5 million locations across the United States and US Territories. The NWIS contains all station data on streamflow. In addition, it also has all federally-collected data on groundwater levels and water quality. The water quality data includes information on water temperature, conductance, nutrients, pH, pesticides, and volatile organic compounds. In this lab, we will only be looking at streamflow (discharge) data, but you should definitely explore some of the other data available!\nWe can obtain daily discharge data for our station using the nwis_streamflow method and specifying a station_id, start, and end. These three attributes were stored in the wshed object when we initialized it, so we can grab the values that way. The nwis_streamflow conveniently returns our data as a pandas DataFrame, with a single column of streamflow values indexed by their datetime and reported in cubic meters per second. We use the column method and index.name attribute to clarify what variable and units our new DataFrame contains.\nQ = hds.nwis_streamflow(wshed.station_id, wshed.start, wshed.end)\nQ.columns = ['Q [m^3/s]']\nQ.index.name = 'Datetime'\nQ['Dates'] = Q.index\nQ.head()\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\nQ = hds.nwis_streamflow(wshed.station_id, wshed.start, wshed.end)\nQ.columns = ['Q [m^3/s]']\nQ.index.name = 'Datetime'\nQ['Dates'] = Q.index\nQ.head()\n\n\n\n\n3.3.2 Precipitation Data for our Station\nUnfortunately, most USGS streamflow gauges aren‚Äôt at locations where rainfall data is also collected. Even if they were, rainfall varies across even small basins, so we‚Äôd still need to have some idea of what the average rainfall was over the entire watershed. Helpfully, the hydromet library includes the ability to query the Daily Surface Weather and Climatological Summaries (Daymet), which is hosted at Oak Ridge National Laboratory‚Äôs (ORNL‚Äôs) Distributed Active Archive Center (DAAC).\n\nüìä <b>The ORNL DAAC:</b> The ORNL DAAC is the world's largest archive of biogeochemical and spatial environmental data. It contains most of NASA's Earth Observing System satellite data, as well as many contributed data on environmental patterns and processes. In fact, the author's PhD <a href=\"https://daac.ornl.gov/S2K/guides/kt_stem_map.html\">dissertation data</a> from 2000 on the location, sizes, and characteristics of 1,000s of savanna trees in southern Africa is hosted on this site. The DAAC maintains a suite of <a href=\"https://daac.ornl.gov/tools/\">tools</a> that can be used to query and subset some its largest datasets. Many of these tools - like Daymet - have associated Python libraries that can make access even easier. \n\nJust as with the NWIS and the NLDI, we will access our daymet data using an interface that is defined in hydrodata‚Äôs datasets module. To begin with, we will just retrieve the meterological data for a single location. The specific method we will use is the daymet_byloc function. This function requires the latitiude and longitude of our location, as well as start and end dates for the observations.\n\ndaymet = hds.daymet_byloc(wshed.lon, wshed.lat, start=wshed.start, end=wshed.end)\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\ndaymet = hds.daymet_byloc(wshed.lon, wshed.lat, start=wshed.start, end=wshed.end)\ndaymet.head()\n\n\nWe can see that - just like our discharge data stored in Q - the hds.daymet_loc function has returned a pandas Dataframe object that contains columns for:\n\nLength of daylight in seconds: dayl (s)\nPrecipitation in mm/day: prcp (mm/day)\nAverage incoming solar radiation in Watts per m2: srad (W/m^2)\nSnow water equivalent in kg/m2: swe (kg/m^2)\nMaximum daily temperature in degrees Celsius: tmax (deg c)\nMinimum daily temperature in degrees Celsius: tmin (deg c)\nAverage water vapor pressure in Pascals: vp (Pa)\n\nFor this lab, we are only interested in the Precipitation data, although the snow water equivalent data could be important for a cooler basin. Therefore we simply create a new DataFrame containing only the prcp (mm/day) data. We also create a column of the dates for each observation as we did with the discharge data.\n\nP = pd.DataFrame(daymet['prcp (mm/day)'])\nP.columns = ['P [mm/day]']\nP['Dates'] = P.index\nP.head()\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\nP = pd.DataFrame(daymet['prcp (mm/day)'])\nP.columns = ['P [mm/day]']\nP.index.name = 'Datetime'\nP['Dates'] = P.index\nP.head()\n\n\n\n\n3.3.3 Evapotranspiration Data for our Station\nEvapotranspiration data is the hardest to obtain as there are very few direct observations of evapotranspiration (but we will work with some of these direct measurements in our next lab!). Because evapotranspiration is dependent on atmospheric conditions and the amount of energy available to evaporate water at the surface, most attempts to characterize evapotranspiration focus on the potential rate at which water vapor can be transported from the surface into the atmosphere. However, in places where the availability of water limits the rate of evapotranspiration, the potential evapotranspiration (PET) can be much higher than actual rates. This makes determiniation of actual evapotranspiration quite difficult in water-limited regions.\nEstimation of actual evapotranspiration can be accomplished using either mass balance approaches, energy balance approaches, or a combination of both. For this lab, we are going to use a model-based estimate of actual evapotranspiration called the Operational Simplified Surface Energy Balance (SSEBop) model, which was developed at the USGS‚Äôs Earth Resources Observation and Science (EROS) Center. This approach is presented in Senay (2018) and Senay et al., (2013). Unfortunately, there‚Äôs no web service available for subsetting the data. Therefore, the hydrodata routine, ssebopeta_bygeom first downloads the entire national dataset for the requested period and then subsets the data based on the provided geometry locally. For this reason, it‚Äôs not nearly fast as other operations and the bottleneck is download speed, which can vary greatly based on available bandwidth.\n\nüìä <b>EROS Data Center</b> EROS is home to the world's largest collection of remotely sensed images of the Earth‚Äôs land surface and the primary source of Landsat satellite images and data products. NASA‚Äôs Land Processes Distributed Active Archive Center (LP DAAC) is also located at EROS. EROS developed the SSEBop model that we are using in today's lab. A recent comparison of methods for estimating actual evapotranspiration can be found <a href=\"https://pubs.usgs.gov/sir/2017/5087/sir20175087.pdf\">here</a>.\n\nWe can access the SSEBop model estimates of evapotranspiration using the ssedopeta_byloc method:\n\nET = hds.ssebopeta_byloc(wshed.lon, wshed.lat, start=wshed.start, end=wshed.end)\n\nüìä <b>SSEBop Data Availability</b> The SSEBop output at EROS isn't provided in real-time. <b>As of May 2020 only data through the end of 2018 were available</b>. More details on these products can be found <a href=\"https://earlywarning.usgs.gov/ssebop/modis/daily\">here</a>.\n\n\nDownloading a single water year of ET data\nAs mentioned above, downloading the SSEBop data can take quite some time. We‚Äôve written a helper function that downloads a single water year of ET data at a time. The function requires a station_id as the first argument, and the requested water year as the second argument. It returns a pandas DataFrame containing ET values for each day in the water year.\nfrom get_ET_wateryear import get_ET_wateryear\n\nET_2015 = get_ET_wateryear(station_id, 2015)\n\n‚ñ∂Ô∏è <b> Run the cell below. </b> <br><hr style=\"border-top: 0.5px solid gray;\"> NOTE: Currently, there are no methods to subset the SSEBop output before download. It takes a <i>very</i> long time to download the daily national estimates for three full years (1,096 files). So we've pre-loaded the data as a CSV file for you in the class <code>data</code> folder, and we will use that for now. When you complete your lab work, you can use the <code>get_ET_wateryear()</code> function to get data for your gauge.\n\n\n\n\nCode\n# Instead, load the data from a csv using the pd.read_csv() command:\nET = pd.read_csv('../data/lab_1/SSEBop_11123500.csv', usecols=['ET [mm/day]', 'datetime'], \n                 index_col='datetime', parse_dates=True)\n\n# Just as with our P and Q data, we assign the index and create a column of dates.\nET.index.name = 'Datetime'\nET['Dates'] = ET.index\nET.head()\n\n\n\n\n\n3.3.4 Summing Fluxes by Water Year\nAs we analyze our basin‚Äôs water balance, we will want to quickly look at the total amount of a flux at a gauge location for a single water year. To do so, we‚Äôd need to create a function that averages the correct months (October to September of the following year). To do so, we need to add a column that is water year. This is easy to do. First we create a water_year function.\ndef water_year(date):\n    \"\"\" Determines the water year for a Dateteime date\n    \n    Parameters\n    ----------\n    \n        date : Datetime obj\n            A datetime stored as the pandas datetime object. \n    \n    Returns\n    -------\n        water_year : int\n            An integer corresponding to the water year of the datetime\n    \"\"\" \n    if date.month>=10:\n        return date.year+1\n    else:\n        return date.year\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\ndef water_year(date):\n    \"\"\" Determines the water year for a Dateteime date\n\n    Parameters\n    ----------\n\n        date : Datetime obj\n            A datetime stored as the pandas datetime object. \n\n    Returns\n    -------\n        water_year : int\n            An integer corresponding to the water year of the datetime\n    \"\"\" \n    if date.month>=10:\n        return date.year+1\n    else:\n        return date.year\n\n\nHaving defined the water_year() function, we can easily apply this function to every value in the Dates column of the P dataframe. We assign this value to a new column in the P dataframe, which we will call water_year.\n\nP['water_year'] = P['Dates'].apply(water_year)"
  },
  {
    "objectID": "Lab-1_Catchment_Water_Balance.html#additional-hydromet-plotting-tools",
    "href": "Lab-1_Catchment_Water_Balance.html#additional-hydromet-plotting-tools",
    "title": "",
    "section": "3.4 Additional Hydromet Plotting tools",
    "text": "3.4 Additional Hydromet Plotting tools\nThe hydrodata package includes a handy utility for plotting streamflow and rainfall. We can import this utility and use our data on Q and P to plot the timeseries of both over the past three years with the signatures function.\nfrom hydrodata import plot as hydroplot\n\nhydroplot.signatures({\"Q\": (Q['Q [m^3/s]'], wshed.drainage_area)}, P['P [mm/day]'])\n\n‚ñ∂Ô∏è <b> Run the cell below.\n\n\n\nCode\nfrom hydrodata import plot as hydroplot\n\nhydroplot.signatures({\"Q\": (Q['Q [m^3/s]'], wshed.drainage_area)}, P['P [mm/day]'])\n\n\nThe graphs above depict the timeseries of daily data as well as monthly and annual plots. Finally, it also includes a Flow Duration Curve plot, which shows the percent of time that flow was above different thresholds from the highest to the lowest values. These curves give a sense of how dynamic a river basin is with respect to discharge as well as the distribution of flow amounts. Reading the x-axis of the flow duration curve, we can see that the 50% exceedence flow (i.e.¬†the average amount of streamflow) is somewhere around 0.005 mm/day, which is very low. That corresponds to the fact that we only really see high flows in the Sisquoc during the 2017 water year, and only very small peaks in flow for the 2016 and 2018 water years."
  },
  {
    "objectID": "Lab-1_Catchment_Water_Balance.html#assessing-basin-water-balance",
    "href": "Lab-1_Catchment_Water_Balance.html#assessing-basin-water-balance",
    "title": "",
    "section": "4.1 Assessing Basin Water Balance",
    "text": "4.1 Assessing Basin Water Balance\n\n4.1.0 Assign a water year for each entry in the Q, ET, and P dataframes.\n\nüìö  <b> Question 4.1.0. </b> \nUse the <code>water_year()</code> function that we created in Section 3.3.4 to create a new <code>water_year</code> column in the DataFrames for your three fluxes (Note: You may want ‚Äì but are not required ‚Äì to combine the three DataFrames into a single DataFrame that contains separate columns for <code>Q [mm/day]</code>, <code>P [mm/day]</code>, and <code>ET [mm/day]</code>.  \n\n\n\n4.1.1 Convert Discharge to units of mm/day\n\nüìä <b>Converting Units of Q</b> The units of <code>Q</code> that you have are in cubic meters per second, while your units of <code>P</code> and <code>ET</code> are both in units of millimeters per day. You need to convert the <code>Q</code> values to mm/day. To do so, we need to figure out the discharge amount per unit area of the basin, which is converting the <i>flow</i> (amount per time) to a <i>flux</i> amount per time per unit area).\n\nHere are some helpful conversions and their rationale:\n\nThere are 86,400 seconds in one day. Therefore: $ 1 = 86,400 $\nConvert 1 \\frac{ \\mbox{m}^3}{\\mbox{day}} of streamflow to depth by dividing by the basin area in m^2. (recall there are 1,000,000 m2 per km2)\n\n\nüìö  <b> Question 4.1.1. </b> \nUse the conversions above to create a function that converts a streamflow in units of cubic meters per second into units of mm/day. Use the docstrings below to help make your function.\n\n\n\nCode\ndef Q_mm(Q_cms, basin_area=None):\n    \"\"\" Convert discharge in units of m^3/s into units of mm/day.\n    \n    # The lines below are a doctest. \n    # If your function is working correctly, you should get 86.4\n    # when you call it using Q_mm(1, basin_area=1)\n    \n    >>> Q_mm(1, basin_area=1)\n    86.4\n    \n    Parameters\n    ----------\n    \n        Q_cms : float\n            Streamflow in units of [m^3/s]\n    \n        basin_area : float\n            Upstream area of basin at location of flow measurement, km^2\n    \n    Returns\n    -------\n        Q_mm : float\n            Streamflow in units of mm/day\n    \n    \n    \n    \"\"\"\n\n    # Add your code here!\n\n\n\nüêç <b>Doctests.</b> \nThe <code>docstrings</code> in the cell above contain a <code>doctest</code>. A <code>doctest</code> is a portion of the <code>docstring</code> that begins with <code>>>></code>. This code can be run using the <code>doctest</code> module, which then checks to make sure that the result of the code is the same as the value in the line below the doctest string. In this case, the <doctest> would check to see that when we call <code>Q_mm(1, basin_area=1)</code>, the function returns <code>86.4</code> (the correct value). Doctests ensure that your code is doing what you want, and are a good way to check your functions.\n\nWe can run doctests for any function in a Jupyter notebook by importing the doctest module and then using the run_docstring_examples method:\nimport doctest\ndoctest.run_docstring_examples(Q_mm, globals(), verbose=True)\n\n‚úèÔ∏è <b> Try it. </b> \nOnce you've written your <code>Q_mm</code> function so it returns Q in mm/day, run the docstrings using the code above to make sure it works. \n\n\n\n4.1.2 Apply your Q_mm function to the Q dataframe to get a new column of Q in mm/day.\n\nüìö  <b> Question 4.1.2. </b> \nUse the <code>apply</code> method and your <code>Q_mm</code> function to create a new column, <code>'Q [mm/day]'</code> that has values of streamflow in mm/day. \n\n\n\n4.1.3 Create a plot of the daily change in storage over the three water years.\nNow that you have Q, P, and ET all in the same units (mm/day), you can determine the daily change in storage:\n$ S = P - ET - Q $\n\nüìö  <b> Question 4.1.3. </b> \nCreate a new DataFrame with the change in storage and plot the data for the three water years.\n\n\n\n4.1.4 Determine average monthly water balance\nUse your measure of the change in storage to create a plot that contains the average monthly water balance across the three years of data. There will be one value of change in storage for each month of the water year.\n\nüìö  <b> Question 4.1.4. </b> \nUse your measure of the change in storage to create a plot that contains the average monthly water balance across the three years of data. There will be one value of change in storage for each month of the water year.\n\n\n\n4.1.5 Assess the degree to which this basin is in steady state\nAs discussed above, under steady-state conditions the change in storage, \\Delta S, is zero and our equation reduces to:\n$ P = ET + Q$\n\nüìö  <b> Question 4.1.5. </b> \nUse your three years of data to determine if this basin is in steady state over the entire time period.\n\n\n\n4.1.6 Determine Basin Runoff Coefficients\nThe runoff ratio or runoff coefficient, R_c, is defined as the fraction of rainfall that leaves a basin through streamflow over a period of time.\n$ R_{c} = $\nThe runoff coefficient is larger value for areas with low infiltration and high runoff (pavement, steep gradient), and lower for permeable, well vegetated areas (forest, flat land). The ratio is important for flood control, channel construction, and for possible flood zone hazard delineation. A high R_c value may indicate flash flooding areas during storms as water moves fast overland on its way to a river channel or a valley floor.\n\nüìö  <b> Question 4.1.6.</b> \nCalculate the runoff ratio for the months with the 5 highest rainfalls during the three year record."
  },
  {
    "objectID": "Lab-1_Catchment_Water_Balance.html#choose-your-own-basin.",
    "href": "Lab-1_Catchment_Water_Balance.html#choose-your-own-basin.",
    "title": "",
    "section": "4.2 Choose your own basin.",
    "text": "4.2 Choose your own basin.\nUse all of the example and assignment text to create an analysis of a USGS basin of your choosing. You can browse a map of all stream gauge locations in the US at the maps.waterdata.usgs.gov site. Select a basin that is near a place you‚Äôve lived, or a part of the country that you have visited or has some meaning to you.\nYour analysis should include:\n\nA plot of the basin hydrography\nA plot of the basin topography\nA plot of average rainfall, streamflow and runoff ratio by month\nA single year of waterbalance analysis. Note: Because obtaining ET data is slow, you should pick a single year between 2000 and 2018 to calculate your basin waterbalance. Use the get_ET_wateryear() function.\n\n\nSome Local Gauges of Possible Interest:\n\nCarpinteria Creek in Carpinteria, Station ID 11119500\n\ncarpinteria_id = '11119500' \n\nMission Creek in Santa Barbara, Station ID 11119750\n\nmission_id = '11119750'\n\nAtascadero Creek in Goleta, Station ID 11120000\n\natascadero_id = '11120000'"
  },
  {
    "objectID": "Exercise1-0_HelloWorld.html",
    "href": "Exercise1-0_HelloWorld.html",
    "title": "",
    "section": "",
    "text": "üè† Index | ‚û°Ô∏è Next Exercise |"
  },
  {
    "objectID": "Exercise1-0_HelloWorld.html#introduction-to-python",
    "href": "Exercise1-0_HelloWorld.html#introduction-to-python",
    "title": "",
    "section": "Introduction to Python",
    "text": "Introduction to Python\n\n\n\nPrint statements\nThe most basic function in Python is the print() function, which simply prints out a line.\nprint( 'This is a print statement.' )\n\n >>>  This is a print statement.\n\n\n‚ñ∂Ô∏è Run the cell below.\n\n\n\nCode\nprint( 'This is a print statement.' )\n\n\nThis is a print statement.\n\n\n\nüìö Practice 1. In the following cell, use the print() command to print the line ‚ÄúHello, World!‚Äù)\n\n\n\nCode\nprint(\"Hello World\")\n\n\nHello World\n\n\n\n\n\n\nUser input\nThe input() command is an important Python function that can be used in a program to prompt for user input.\n\n‚úèÔ∏è Try it. Run the following cell to see how the input() function works, inputing your first name when prompted.\n\n\n\nCode\nname = 'Me'\n#name = input( 'What is your first name? ' )\nprint( 'My name is ' + name + '.' )\n#print(name)\nname = \"You\"\nprint(name)\n\n\nMy name is Me.\nYou\n\n\n\n\n\n\nComments\nIn programming, a comment is a piece of text that the computer ignores when running the program. Comments are usually used at the top of a program to provide a description of the program, name and information of the author, dependencies, etc., as well as throughout the script to explain lines of code. Commenting is a critical element of proper coding etiquette.\nThere are two types of comments: in-line comments and block comments. In-line comments are used to provide context at the end of a line of code, while block comments come before a ‚Äúblock‚Äù or chunk of code.\n\nüêç <b>Note.</b>\nIn Python, there are two ways of writing comments. For in-line comments and most short comments, the <span style=\"font-weight:bold\"> # </span> character is used. For large block comments, such as those at the beginning of a file or function, three quotations <span style=\"font-weight:bold\">  '''  </span> are used to enclose comments. Both single and double quotations are interpreted the same, as long as they are not used together.\n\nThe following example is a function (a type of Python object we will cover later on) that uses both methods of commenting. As you can see, without the comments, it would be difficult to understand what the function does, what parameters it takes, and what the intermediate steps are to reach the end.\ndef homo_affine_matrix(p, p_prime):\n    '''\n    Finds the unique homogeneous affine transformation that transforms a set of 3 points \n    from one coordinate system to that of a second set of points in 3-D space\n    \n    Parameters\n    ----------\n    p : array\n        original set of points as a row vector: ((p1, p2, p3))\n    p_prime : array\n        Transformed points as a row vector: ((p1_prime, p2_prime, p3_prime))\n    \n    Returns\n    -------\n    array\n        4 x 3 affine transformation matrix.\n        \n    Source: Adapted by B. Morgan from https://math.stackexchange.com/a/222170 (robjohn)\n    '''\n    \n    # Construct intermediate matrix\n    Q       = p[1:]       - p[0]\n    Q_prime = p_prime[1:] - p_prime[0]\n\n    # Calculate rotation matrix\n    R = np.dot(np.linalg.inv(np.row_stack((Q, np.cross(*Q)))),\n               np.row_stack((Q_prime, np.cross(*Q_prime))))\n\n    # Calculate translation vector\n    t = p_prime[0] - np.dot(p[0], R)\n\n    # Calculate affine transformation matrix\n    return np.column_stack((np.row_stack((R, t)),\n                            (0, 0, 0, 1)))\n \n\n‚ñ∂Ô∏è Run the cell below.\n\n\n\nCode\n# This comment will not be read by the computer.\n2 + 2 \n\n\n4\n\n\n\n\n\n\nCode\n# IGNORE THIS CELL\nfrom IPython.core.display import HTML\ndef css_styling():\n    styles = open(\"./styles/exercises.css\", \"r\").read()\n    return HTML(styles)\ncss_styling()"
  },
  {
    "objectID": "index.html#learning-goals",
    "href": "index.html#learning-goals",
    "title": "EDS 217 - Python for Environmental Data Science",
    "section": "Learning Goals",
    "text": "Learning Goals\n(what you will be able to do) - Read and write basic-to-intermediate scripts and programs in the Python programming language - Conduct reproducible analyses within interactive jupyter notebook environments - Perform analyses on structured data using numpy - Load, aggregate, analyze, and display data using pandas - Learn basics of matplotlib for plotting data. - Use scipy functions to develop fits of distributions to empirical data - Apply all of these tools to analyze environmental datasets - Develop a short tutorial on how to use a python data science library for environmental analysis^*\n^* Final group presentation"
  },
  {
    "objectID": "index.html#new-for-week-2-trypy",
    "href": "index.html#new-for-week-2-trypy",
    "title": "EDS 217 - Python for Environmental Data Science",
    "section": "New For Week 2: TryPy",
    "text": "New For Week 2: TryPy\nTo create more open-ended opportunities for you to apply your python skills, I‚Äôve ported over some exercises from EDS221. They are essentially the same, but now you will work on solving the problems using Python instead of R."
  },
  {
    "objectID": "index.html#trypy-exercises",
    "href": "index.html#trypy-exercises",
    "title": "EDS 217 - Python for Environmental Data Science",
    "section": "TryPy Exercises",
    "text": "TryPy Exercises\n\nDay 1 - Introduction to Python\nThe materials for Day 1 are designed to introduce the basics of working with Python.\nIntro to Python Data Science\nThe Zen of Python\nExercise 1-0 - Hello World\nExercise 1-1 - Variables & Operators\n\n\nDay 2 - Introduction to Python\nOn Day 2, we will explore lists and learn the fundamentals of controlling the flow of programs.\nGetting Help\nExercise 1-2 - Lists and Indexing\n(Simple example of enumerate and zip)\nExercise 1-3 - Ifs or Elses\n\n\nDay 3 - Introduction to Python\nOn Day 3, we will journey into advanced topics related to Python, including structured data and object-oriented programming concepts.\nExercise 1-4 - Structured Data\nExercise 1-5 - Functions ü¶Å, Objects üêØ, and Classes üêª, Oh my!\n\n\nDay 4 - Numpy üßÆ\nOur journey into Python‚Äôs Data Science toolkit begins with NumPy, a library designed to perform advanced calculations on matrices.\nExercise 2-1 - NumPy\n\n\nDay 5 - Pandas üêº\nWe end our first week with arguably the most important library in the Python data science ecosystem: Pandas.\nExercise 2-2 - Pandas\n\n\nDay 6 - Matplotlib üìà\nNow that we‚Äôve learned how to import, manage, and analyze data using pandas, it‚Äôs time to make some graphs! Matplotlib is the primary libary used for plotting data in Python (although there are some great alternatives), so we will start there.\nExercise 2-3 - Matplotlib\n\n\nDay 7 - Scipy üî¨\nPrediction and forecasting requires understanding how to fit distributions and functions to data sets. Today we will combine what we‚Äôve learned so far and take a brief look at SciPy, which is a large library of tools that can be used to fit distributions.\nExercise 3 - SciPy\n\n\nDays 8 & 9 - Group Projects ‚úèÔ∏è\nOur final activity will be a group project in which you work with a team of 2-3 of your classmates to create a brief tutorial introducting one of the many other libraries available to conduct environmental data science in Python. You will develop your tutorial using the same Jupyter Notebook structures that we‚Äôve been using throughout the class. On our last day, we‚Äôll spend the afternoon conducting a Python Data Science Show and Tell\n\n\nBonus Content\nHere are a couple more advanced - and interactive - examples of environmental data science. We won‚Äôt get to these during our brief time together, but feel free to explore them any time you feel like learning more about what you can do with Python!\n\nCatchment Water Balance in Python\nLandscape Energy Balance in Python"
  },
  {
    "objectID": "Exercise1-5_FunctionsObjectsClasses.html",
    "href": "Exercise1-5_FunctionsObjectsClasses.html",
    "title": "",
    "section": "",
    "text": "‚¨ÖÔ∏è Previous Exercise | üè† Index | ‚û°Ô∏è Next Exercise |"
  },
  {
    "objectID": "Exercise1-5_FunctionsObjectsClasses.html#functions",
    "href": "Exercise1-5_FunctionsObjectsClasses.html#functions",
    "title": "",
    "section": "Functions",
    "text": "Functions\nA function is simply a set of instructions that you wish to use repeatedly on varying data. Sometimes a function is used to group a complex set of instructions that allows you to compartmentalize your code in ways that improve its readability. There are three types of functions in Python: builtin functions, user-defined functions, and anonymous functions. We have already seen many builtin functions, and you will meet many more in the coming weeks. This exercise focuses on user-defined and anonymous functions, both of which are important for advanced data analysis.\n\nUser-defined Functions (UDFs)\nA UDF is created using some very specific syntax. First, a function is delcared using the def keyword. The name of the function - and any arguments it takes - follows the def keyword, followed by a :. The combination of def and : is a similar construction to other control statements in Python that you‚Äôve already seen, such as for + :, and if + :. The code block below is the simplest possible function.\ndef my_function():\n    pass\nThe pass keyword means ‚Äúdo nothing‚Äù. Therefore, we have defined a function that: (1) does not take any arguments; (2) does nothing, and then (3) returns nothing.\n\nüêç <b>Note.</b> Technically, a function that lacks a <code>return</code> statement will still return a value. But the value it returns is <a href=\"https://docs.python.org/3/c-api/none.html\"><code>None</code></a>, which is python-ese for nothing. Just like the concept of <a href=https://www.amazon.com/Zero-Biography-Dangerous-Charles-Seife/dp/0140296476>`0`</a>, the concept of <code>None</code> will turn out to be quite useful!\n\nThe next function below still does not take any arguments and it still doesn‚Äôt do anything. It does, however, include a return statement. As the note above indicates, the return statement isn‚Äôt necessary in Python functions; they will just automatically return None if you don‚Äôt specify otherwise. However, using the return statement is required if you ever want to work with any output from your functions.\ndef my_function():\n    return True\nNext, we can take a look at an example of a function that takes an argument (a) and returns a value (also a)‚Ä¶ but it still doesn‚Äôt actually do anything!\ndef my_function(a):\n    return a\nHopefully your functions will be more useful than the ones above that do nothing. However, we‚Äôve introduced these three ‚Äúdo-nothing functions‚Äù in order to highlight three important aspects of all functions. The ability to (1) pass an argument into a function, (2) transform data within - or based on - the value of a function argument, and (3) return some new data or result based on those manipulations. These three factors combine to make functions extremely useful. Finally the code below provides an example of a function that has all three components and does something that should be quite familiar to you at this point.\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\ndef my_function(msg):\n    print(msg)\n\nmy_function(\"Hello World\")\n\n\n\n\nCode\n# Define a simple function\ndef convert_F_to_C(temp_F):\n    temp_C = (temp_F-32)*5./9.\n    return temp_C\n\n\nThe function above takes a Temperature in Fahrenheit and converts it to Celsius. It then returns this new value.\n\n‚úèÔ∏è <b> Try it. </b> \nCall the <code>convert_F_to_C()</code> function with the value 98.6 (¬∞F). It should return 37.0.\n\n\n\nCode\nconvert_F_to_C(98.6)\n\n\n\n\nFunction Arguments & Parameters\nWhen we define a function, we specify the parameters the function requires. The definition of convert_F_to_C contains a single parameter, temp_F. When we call a function, we supply arguments to the function which are then mapped to the function parameters. Providing the argument 98.6 to the function maps this number to the temp_F parameter. So wherever temp_F appears in the function, 98.6 is used instead. What happens if we call a function without supplying arguments for the parameters?\n\nconvert_F_to_C() # Uh-oh... we didn't provide an argument for the temp_F parameter.\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n<ipython-input-3-60e83d2545ed> in <module>\n----> 1 convert_F_to_C()\n\nTypeError: convert_F_to_C() missing 1 required positional argument: 'temp_F'\nIn the error above, we see that not providing a required argument raises a TypeError, and provides some additional detail regarding what went wrong. In this case, we are told that we are mssing one required positional argument, which needs to be assigned to the temp_F parameter.\n\nSpecifying default parameters\nWhen defining a function, it is possible to set a default value for any parameter. This is done by assigning the parameter the default value right inside the parameter list:\ndef convert_F_to_C(temp_F=0):\n    temp_C = (temp_F-32)*5./9.\n    return temp_C\n\nüêç <b>Note.</b> Functions are no different than variables (or any other object in Python). Therefore, any function you create in a notebook can be re-defined by simply editing the function and re-running the cell! \n\n\n‚úèÔ∏è <b> Try it. </b> \nRe-define the <code>convert_F_to_C()</code> function so that the default value of <code>temp_F</code> is 0. Test what happens if you call this re-defined function without an argument. \n\n\n\nCode\ndef convert_F_to_C(temp_F):\n    temp_C = (temp_F-32)*5./9.\n    return temp_C\n\nconvert_F_to_C()\n\n\n\n\nRequired arguments\nArguments that are included in the parameter list and do not have default values are called required arguments. In the convert_temp_to_C function below, both temp and unit are required parameters.\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\ndef convert_temp_to_C(temp, unit='F'):\n    \"\"\" Converts a temperature to Celsius\n    \n    Parameters\n    ----------\n        temp : float\n            Temperature value to convert\n        unit : str\n            temp units ('K' or 'F')\n       \n    Returns\n    -------\n        temp_C : float\n            The value of temp converted to Celsius\n            \n    \"\"\"\n    if unit.capitalize() == 'K':\n        temp_C = temp - 273.15\n    elif unit.capitalize() == 'F':\n        temp_C = (temp-32)*5/9\n    \n    return temp_C\n\n\nYou can also see that we have added some comments to the function right below the definition. These commments are known as Docstrings, and they are critical to allow users to understand what your program is doing. The use of \"\"\" to begin and end the docstrings signifies we are writing a multi-line comment (as opposed to # which specifys a single line comment in Python). The first line of a function‚Äôs docstrings should always be a short description of what the function does. The rest of the docstrings should specify the required arguments that the function needs and what values it returns, if any.\n\nüêç <b>The ABC of Python:</b> Always. Be. Commenting.\n\n\nüêç <b>Note.</b> You can see the function definition and <b>docstrings</b> for any function (if they exist) by using the builtin <code>help()</code> function.\n\n\n‚úèÔ∏è <b> Try it. </b> \nUse the <code>help()</code> function to see the function definition and docstrings for the <code>convert_temp_to_C</code> function.\n\n\nüìö  <b> Practice 1. </b> \nCreate a new function, <code>convert_temp_to_K</code> that converts a temperature to Kelvin from either Fahrenheit or Celsius, depending on user-supplied arguments. \n\n\n\nKeyword arguments\nIn both convert_temp_to_C and convert_temp_to_K, the order of parameters is very important. If we tried calling the convert_temp_to_C function like this: convert_temp_to_C('F', 212.0) we would get an error! The reason we get an error is because the function definition assumes that the first argument should be mapped to the first parameter temp and the second argument should be mapped to the second parameter unit. That‚Äôs why the TypeError refered to temp_Fas a required positional argument in the section above. This assumption that arguments be mapped to parameters in a specific order can make working with complicated functions that have many parameters almost impossible. For this reason, Python provides the ability to pass keyword arguments to functions.\nRather than making assumptions about how arguments map to parameters based on their order, keyword arguments specify exactly how arguments are mapped to parameters within a function. This is done by assigning an argument to a specific parameter within the function call.\nFor example, instead of writing convert_temp_to_C('F', 212.0), we can instead call the same function using convert_temp_to_C(unit='F', temp=212.0).\n\nüêç <b>Note.</b> Python doesn't require you to change anything about a function's definition to take advantage of keyword arguments. For this reason, it's good practice to use keyword arguments whenever possible.\n\n\n‚úèÔ∏è <b> Try it. </b> \nCall the <code>convert_temp_to_K</code> function that you created using keyword arguments.\n\nAn important consideration when using keyword arguments is that they must all follow any positional arguments that are passed to a function. In other words, if you are calling a function with a mix of positional arguments and keyword arguments, the positional arguments need to all be listed first. So, using our simple temperature conversion function as an example, convert_temp_to_C(212.0, unit='F') is valid, but convert_temp_to_C(temp=212.0, 'F') is not.\n\n\nAnonymous functions\nSometimes we may just want to create a very simple function without having to go through all the trouble of using def to define the function, writing docstrings and adding a return statement. For these ‚Äúone-liners‚Äù Python has the concept of anonymous functions. Instead of using def, these functions are declared using lambda notation, so they are often refered to as lambda functions. Because they are meant to be simple, a lambda function declaration is always contained in a single line:\nQ = lambda T: 5.67e-8 * T**4\nThe function above calculates the Energy Flux, Q [W/m^2], for a blackbody object at a specified temperature, T [Kelvin], assuming an emissivity of 1:\nQ = 5.67x10^{-8} \\times T^4\nWe can use this lambda function just like any other function:\nQ(50+273.15)\n>>> 618.3006455416394\n\nüìö  <b> Practice 2. </b> \nCreate a <code>lambda</code> function in the cell below that converts a Celsius temperature to Kelvin.</div>\n\n\n\n\nDocumenting Functions\nAs we saw above, the use of docstrings can greatly improve your ability to understand what a program requires in terms of arguments and what the function returns. There is no standard for docstrings, but there are some best practices. A good docstring should contain:\n\nA brief description of what the function does.\nA more detailed explanation of how the functions works, if necessary.\nInformation on any arguments - both required and optional - that may be passed into the function.\nInformation on any parameter default values.\nInformation on any exceptions that the function raises.\nAny information about side effects the function may cause, or restrictions on when the function can be used.\n\nThe last couple of items on the list above aren‚Äôt very common, but the first four are essential components of all function docstrings. While it is fine to develop your own docstring style, here‚Äôs another example of what a docstring should look like:\ndef Q(T, epsilon=1, unit='C'):\n    \"\"\" Calculates energy emitted by an object with temperature T\n\n    Uses the Stefan-Bolzmann Law to calculate total radiative \n    emmittance in W/m^2 based on temperature and emissivity:\n    \n    Q = epsilon * sigma * T**4\n    \n    where sigma is the Stefan-Boltzmann constant (5.67e-8 W/m^2/K^4),\n    epsilon is the emissitivity (0-1), and T is temperature in Kelvin.\n\n    Parameters\n    ----------\n        T: float\n            Temperature of object\n        epsilon: float, optional\n            emissivity of object [0-1] (default is 1)\n        unit: str, optional\n            units of T, either 'F', 'C', or 'K' (default is 'C')\n    \n    Returns\n    -------\n        Q: float\n            Energy emitted by object [W/m^2]\n    \"\"\"\n\n    # Set Stefan-Boltzmann constant:\n    SIGMA = 5.67e-8 # W/m2/K^4                    \n                \n    # If T is in Fahrenheit, convert to C:\n    if unit == 'F':\n        T = (T - 32) * (5./9.)\n        unit = 'C' # Re-assign unit to C\n        \n    # If T is in Celsius, convert to Kelvin\n    if unit == 'C':\n        T = T + 273.15\n    \n    # Calculate Q and return the value\n    Q = epsilon * SIGMA * T**4\n    return Q\n\nüìö  <b> Practice 3. </b> \nWrite a complete set of docstrings for your function a <code>convert_temp_to_K</code>. Check to make sure they work using the <code>help()</code> function.</div>"
  },
  {
    "objectID": "Exercise1-5_FunctionsObjectsClasses.html#classes",
    "href": "Exercise1-5_FunctionsObjectsClasses.html#classes",
    "title": "",
    "section": "Classes",
    "text": "Classes\nClasses are Python objects that contain both attributes (i.e.¬†data) and methods (i.e.¬†functions). Classes are the essence of any object-oriented programming (OOP) language. A Class is created using the class keyword:\n\nclass Temperature:\n    value = 74.0\n    unit = 'F'\n    \nThe above code defines a new class called Temperature. It then assigns two attributes to the class, value and unit. This simple class has no methods. We will get to those next!\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\nclass Temperature:\n    value = 74.0\n    unit = 'F'\n\n\n\nCreating an Instance of a Class\nWe create an instance of the class by calling it (like we call a function) and assigning the output of the call to a new variable:\nmy_temp = Temperature()\n\n\nAccessing Class Data\nClass objects are mutable, so it‚Äôs possible to change the data in a class. We can access ‚Äì and alter ‚Äì the attributes of a class using . notation:\nprint(my_temp.value) # Use . notation to access attributes of a class.\n>>> 74.0\n\nmy_temp.value = 83.2  # Assign a new value to this instance of Temperature.\nprint(my_temp.value)  # Check to see if the value has been changed...\n>>> 83.2\n\nüìö  <b> Practice 4. </b> \nCreate an instance of the <code>Temperature</code> class and print out the string: <code>\"The temperature is 74 ¬∞F\"</code>.\n\n\n\nClass Initialization\nIn the example above, we saw how to create an instance of a Temperature. But you probably noticed that every instance of our class will have the same temperature and unit: 74.0 degress F. While it‚Äôs possible to change these values later (in python parlance, we‚Äôd say ‚Äúafter the object is instanced‚Äù), it‚Äôd be better if we could initialize our class instances with the values we want. To do this, we will create our first class method, the __init__ method.\n\n\n__init__() method\nThe __init__() method is a special function that we create for classes that tells python how to create a new instance of the class. This function is included as part of a class‚Äôs definition, and usually should be the very first method that appears in the class.\n\nüêç <b>Note.</b> Python uses the \"double underscore + name + double underscore\" syntax (<code>__</code> + <code>init</code> + <code>__</code>) to define a suite of \"magic\" functions. The exact way to pronounce these strange functions isn't settled, but most people use \"dunder\" to refer to the double underscore, so <code>__init__()</code> is referred to as the \"dunder init dunder\" function, or \"dunder init\" for short.\n\nThe __init__() function is the initializer method for a Class. It gets passed whatever arguments are provided when a class is created. For example, if we called T = Temperature(10, 'F'), the __init__() method would automatically be passed these two arguments.\nWe define the __init__ method just like any other function, with one difference: It always includes self as its first argument:\n\nclass Temperature:\n    \n    def __init__(self, value=74.0, unit='F'):\n        self.value = value\n        self.unit = unit\n\n\nWhy self?\nIt‚Äôs not at all obvious why we need to add an extra parameter (which, by convention is always called self ) to the initializer method. Even weirder is the fact that we need to add this extra parameter, self to every class method! To beginning Pythonistas, the concept of self is deeply strange. However, there is a fairly straight-foward reason for its existence.\nPython functions ‚Äì like functions in most programming languages ‚Äì can only manipulate data that exist within the function itself. Speaking generally, Python functions aren‚Äôt supposed to manipulate data that they haven‚Äôt been passed via argument. The consequences of this ‚Äúseparation of namespaces‚Äù is that ‚Äì paradoxically ‚Äì a class method can‚Äôt operate on class data unless the class data itself is passed into the method!\nBy convention, we use the self parameter to allow us to work with the properties of a class within our class methods. If we didn‚Äôt include this extra parameter, the functions that we write inside of a class wouldn‚Äôt even be able to access the attributes of the class that they were inside of!\nEssentially, you can think of self as a placeholder for a class instance. In fact, Python automatically passes a class instance into any class function whenever that class function is called. The class instance argument is inserted by Python before any other arguments. Therefore, we include the self parameter at the beginning of every class method (remember methods and functions are the same thing), knowing that Python will pass a class instance into our function first, and all of the attributes of that instance will get assigned to the self parameter.\nThere are many, many other explanations out there about the need for the self parameter in class methods. Because the use of self in Python is such a confusing concept, there have also been formal proposals to get rid of self and warnings about its misuse in popular culture. There is even a blog post about the necessity self from the creator of self‚Ä¶ himself.\n\nüêç <b>Bottom Line.</b> Whenever you write a class function, you will need to include <code>self</code> as the first positional parameter in the function definition. In addition, whenever you want to access class attributes within a class method, you will need to use <code>self</code> as the object that contains the data.\n\n\nUsing the __init__() function\nWe almost never call the __init__() function directly. Instead, the Class constructor function calls it for us. We already saw that a class instance is created using the constructor function like my_temp = Temperature(). With our new __init__() function defined for the Temperature class, we can now create Temperature instances with any data we want:\nT = Temperature(83.2, 'F')\nprint(T.value)\n>>> 83.2\n\n‚úèÔ∏è <b> Try it. </b>  \nCopy the example code above to create an new <code>Temperature</code> class that contains an <code>__init__</code> method that sets the value and units. Create a few new <code>Temperature</code> instances with different values and units.\n\n\n\n\nUser Defined Class Methods\nWe often want to create our own methods that allow us to manipulate and work with class data. For example, now that we have a Temperature class, we might want to create a method that allows us to get the value of temperature in any unit. We can add this functionality by defining a class method. The class method is just the same as every other Python function, except, like __init__(), it has self as its first argument:\n\nclass Temperature:\n    \n    def __init__(self, value=74.0, unit='F'):\n        self.value = value\n        self.unit = unit\n        self.temp_K = self.get_K()\n\n    def get_K(self):\n        \n        unit = self.unit\n        T = self.value\n\n        # If T is in Fahrenheit, convert to C:\n        if unit == 'F':\n            T = (T - 32) * (5./9.)\n            unit = 'C' # Re-assign unit to C\n        \n        # If T is in Celsius, convert to Kelvin\n        if unit == 'C':\n            T = T + 273.15\n\n        return T\n    \nIn this example, we‚Äôve added a class function called get_K that always returns the Temperature object‚Äôs value in degrees Kelvin. You will notice that we can even use this function inside the __init__() function. This means that after creating an instance of an object, we will end up with the temp_K property of the object set for us automatically.\nWe can also run any class methods by calling it directly. Just as we used . notation to access class data, we use . notation to access class methods:\n\nmy_temp = Temperature(50,'C')\nmy_temp.get_K()\n>>> 323.15\n\n‚úèÔ∏è <b> Try it. </b>  \nCopy the example code above to create an new <code>Temperature</code> class that contains the <code>get_K</code> method, which is used to set the value of <code>temp_K</code> during intialization. Create a few new <code>Temperature</code> instances with different values and units and test to make sure <code>temp_K</code> is being set correctly. \n\n\nüìö  <b> Practice 4. </b> \nUse the cell below to create a new <code>Temperature</code> class that contains a user-defined class function of your own design. This function can do anything you want. It doesn't need to be fancy or even useful, just make sure you test your function by creating an instance of <code>Temperature</code> class and running the function.\n\n\n\nTwo additional - and very useful - Class ‚ÄúMagic‚Äù Methods\nIn addition to the __init__() function, there are some other useful ‚Äúmagic‚Äù class methods. The first, __repr__ is a function that allows you to define how a Class object represents itself. For example, check out this example for a string (str) variable:\n\nSIGMA = 5.67e-8 # Create a variable that contains the Stefan-Boltzmann constant\nSIGMA               # What happens if you just execute a line that contains the variable? \n>>> 5.67e-08\nYou see that when the variable SIGMA is invoked, the Python interpreter returns 5.67e-08, which is not exactly what you wrote when you assigned SIGMA. That‚Äôs because what is happening ‚Äúbehind the scenes‚Äù is that Python is calling the __repr__() function for the object SIGMA:\nSIGMA.__repr__()\n>>> 5.67e-08\nThere is a similar magic function, __str__() that is called whenever print() is invoked on an object:\nprint(SIGMA)\n>>> 5.67e-08\n\nSIGMA.__str__()\n>>> 5.67e-08\nIn the case of float variables (type(SIGMA) is float), __repr__() and __str__() return the same thing. But they don‚Äôt have to. Look at this example, using a datetime object, which is part of the standard Python library and the primary object for dealing with time/date information in Python:\nfrom datetime import datetime\n\ncurrent_time = datetime.now()\n\ncurrent_time\n>>> datetime.datetime(2020, 4, 17, 12, 50, 52, 778357) # Your time will be different!\n\nprint(current_time)\n>>> 2020-04-17 12:51:38.750213\nWe see that the representation of a datetime object (created by the class‚Äôs __repr__() function) is different than the class‚Äôs __str__() function.\nYou can create these functions inside a class in the same way you created the __init__() function:\nclass Temperature:\n    \n    def __init__(self, value=74.0, unit='F'):\n        self.value = value\n        self.unit = unit\n\n    def __repr__(self):\n        return \"Temperature({value},¬∞{unit})\".format(value=self.value,unit=self.unit)\n\n    def __str__(self):\n        return \"The temperature is {value} ¬∞{unit}\".format(value=self.value, unit=self.unit)\n\n‚úèÔ∏è <b> Try it. </b>  \nUse the example above to define a new <code>Temperature</code> class that adds <code>__repr__</code> and <code>__str__</code> methods. Test out the <code>__str__()</code> method by creating an instance and using the <code>print()</code> command. \n\n\n\nDocumenting Classes\nJust like functions, classes should contain docstrings. The format and content of docstrings is similar to a function, but there is a need for even more description. This is because the docstrings should include information about all of the attributes of the class as well as any class methods that are defined. So for a simple Weather class we might have something like this:\nclass Weather:\n    \"\"\"\n    A class used to represent the weather\n\n    Attributes\n    ----------\n    \n    temperature : float\n        air temperature, in deg-C\n        \n    relative_humidity : float\n        relative humidity, in %\n    \n    pressure : float\n        air pressure, in kPa\n    \n    Methods\n    -------\n    \n    sat_vap_pressure()\n        returns the saturation vapor pressure for the current weather condition\n        \n    \"\"\"\n    \n    def __init__(self, temp, RH, P):\n        \"\"\" \n        Parameters\n        ----------\n        temp : float\n            air temperature, in ¬∞C\n        \n        RH : float\n            relative humidity, in %\n        \n        P : float\n            pressure, in kPa\n        \"\"\"\n        \n        self.temperature = temp\n        self.relative_humidity = RH\n        self.pressure = P \n        \n    def sat_vap_pressure(self):\n        \"\"\" Determines Saturation Vapor Pressure\n        \n        Uses the Tetens equation to estimate saturation vapor pressure (svp) given air Temp.\n        \n        P = 0.61078 * exp((17.27 * T)/(T + 237.3))\n        \n        where P is svp in kPa and T is air temperature in ¬∞C.\n        \n        \n        Returns:\n        --------\n        \n        P, saturation vapor pressure, in kPa\n        \n        \"\"\"\n        from math import exp\n        \n        P = 0.61078 * exp(17.27*self.C)/(self.T + 237.3)\n        \n        return P\n\nüêç <b>ABC!</b> Notice how there are more docstrings in this definition than there is code! This is because the concept of abstraction ‚Äì creating classes and functions that represent general concepts and methods ‚Äì requires a high degree of documentation in order for the abstractions to be used correctly. The same code written in a notebook cell (without abstraction) would be easier to read and require much less documentation.\n\n\nüìö  <b> Practice 5. </b> \nUse the cell below to create a final version of your <code>Temperature</code> class that includes docstrings. Check to see if your docstrings are working using the <code>help()</code> function."
  },
  {
    "objectID": "Exercise1-5_FunctionsObjectsClasses.html#loading-functions-and-classes",
    "href": "Exercise1-5_FunctionsObjectsClasses.html#loading-functions-and-classes",
    "title": "",
    "section": "Loading functions and classes",
    "text": "Loading functions and classes\nIn the last practice cell, you probably noticed that your class definition is getting pretty large. While it‚Äôs nice to be able to edit this code easily in your notebook, once you have settled on a function or class definition, it is often helpful to move the definitions out of your notebook and just load them when you need them. Python uses the import function to load objects from external libraries and files.\n\nMoving your class definition to a new file\n\nüìö  <b> Practice 6. </b> \nFollow the directions below to save your final <code>Temperature</code> class definition into a new file called <code>temperature.py</code>\n\n\nGo to the JupyterLab File menu and click New -> Text File\n\n\n\nCopy the entire Temperature class definition you created during Practice 5 and paste it into the text file.\nRename the text file temperature.py. You can do this easily by right-clicking on the filename in the file‚Äôs tab (see the image below)\n\n\n\nüêç <b>Note:</b>Make sure you save your file with the <code>.py</code> extension and not <code>.txt</code>. You will know if you saved it correctly if the file appears with python code formating as in the image below:\n\n\n\nSave the new file. This will create a file called temperature.py in your current directory.\n\n\n\nImporting your class from the temperature.py file.\nAssuming you were able to save your file correctly, and that your Temperature class definition doesn‚Äôt have any errors in it, you can import the Temperature class into your notebook like this:\n\nfrom temperature import Temperature\n\nT = Temperature(98.6, unit='F')\n\n‚úèÔ∏è <b> Try it. </b>  \nLoad your <code>Temperature</code> class from the <code>temperature.py</code> file using the <code>import</code> command. Make some new Temperature instances to ensure that your class loaded correctly and works okay."
  },
  {
    "objectID": "Setting_up_local.html",
    "href": "Setting_up_local.html",
    "title": "Setting up your local Python",
    "section": "",
    "text": "Return to Course Home Page"
  },
  {
    "objectID": "Setting_up_local.html#general-plan",
    "href": "Setting_up_local.html#general-plan",
    "title": "Setting up your local Python",
    "section": "General Plan",
    "text": "General Plan\nThere are many ways to set up your local machine to run maintanable python data science code. In addition to the usual need to build your code within a repository, any strategy for local computation requires three critical components:\n\nA system for managing computing environments\nA system for managing python packages\nAn system for managing python code, which is usually an integrated development environment (IDE) in which editing and running code occur interactively."
  },
  {
    "objectID": "Setting_up_local.html#managing-computing-environments",
    "href": "Setting_up_local.html#managing-computing-environments",
    "title": "Setting up your local Python",
    "section": "1. Managing Computing Environments",
    "text": "1. Managing Computing Environments\nThere are many options for managing computing environments.\nThese days, a common method is to use containers, in which an entire computational system (including processes, memory, disk space) is spun up as an isolated service on your local (or remote). Systems such as docker or python-specific shiv allow for isolated packaging and execution of python programs.\nA more common approach on local machines is to use the condaenvironment management system. Conda is developed by Anaconda, and is the most widely used environment management system in python data science. Other local solutions include venv, which is part of the main python distribution.\nIn this exercise, we will use conda for our environment management. We can access conda through the terminal/command line, within a terminal inside an IDE, or through the Anaconda Navigator app."
  },
  {
    "objectID": "Setting_up_local.html#managing-python-packages",
    "href": "Setting_up_local.html#managing-python-packages",
    "title": "Setting up your local Python",
    "section": "2. Managing Python Packages",
    "text": "2. Managing Python Packages\nOnce a computing environment is created in conda, there is a need to manage the individual packages within the environment. Once again, there are many ways to accomplish this task in python.\nFirstly, conda itself is a sophisticated package management system too. conda is able to download and install almost any python package and often it is possible to install binaries of packages directly without the need for local compilation. conda also manages package dependencies, ensuring libraries are inter-operable.\nIn addition to conda, there is the Package Installer for Python pip. pip can install any package hosted on the Python Package Index (PyPI), as well as packages hosted on github and even packages you‚Äôve made on your local machine.\nRecently, a new entry to package management, poetry has started to become popular. poetry focuses on making package management - and especially dependency management between and amongst packages - much easier. It also simplifies building and packaging your own code for distribution.\nIn this class, we will use conda for our package management. Because conda also includes pip, we get all the advantages of conda (faster installs, easy integration with IDEs) without losing the broad capabilities of pip.\nConda can create new environments using a markup language specification called yaml. We will use an environment file created for our course to create an eds-217 environment on your local machine."
  },
  {
    "objectID": "Setting_up_local.html#installing-the-eds-217-python-environment.",
    "href": "Setting_up_local.html#installing-the-eds-217-python-environment.",
    "title": "Setting up your local Python",
    "section": "Installing the EDS-217 Python Environment.",
    "text": "Installing the EDS-217 Python Environment.\n\nUsing Anaconda NavigatorUsing conda at the command line\n\n\n\nSave this environment.yml file to your local machine (right-click to Save As).\nOpen Anaconda Navigator and click into the Environments pane on the left side of the Navigator window.\nIn the Environments pane, click the Import button at the bottom of the environments list.\nUse the file chooser to select the environment.yml file that you just downloaded. Make sure to enter eds-217 in the \"New environment name\" field of the Import Environment dialog panel.\nOnce the environment is installed, you are all set! You can close out of the Anaconda Navigator.\n\nNote: If you ever need to add libraries to this environment, you can use the same interface to install additional python modules.\n\n\n\nSave this environment.yml file to your local machine (right-click to Save As).\nOpen a terminal. This can be done either through RStudio, or using an installed terminal application in Mac OS or Windows.\nIn the terminal, cd (change directory) to the folder containing the environment.yml file that you downloaded in step 1.\nuse the conda command to create a new environment based on the specifications of the environment.yml file:\n\n> conda env create -f environment.yml\nNote: If you ever need to add libraries to this environment at the command line, you can use the conda command. First, make sure that you have activated the environment using:\n> conda activate eds-217\nThen you can install additional libraries using:\n> conda install <package_name>\nwhere <package_name> is the name of the library you want to install (it may not match the name of the import exactly, so be sure to search on Google for the correct import statement)"
  },
  {
    "objectID": "Setting_up_local.html#managing-code-and-execution-ides",
    "href": "Setting_up_local.html#managing-code-and-execution-ides",
    "title": "Setting up your local Python",
    "section": "3. Managing code and execution (IDEs)",
    "text": "3. Managing code and execution (IDEs)\nFinally, we come to the tool you will use most when coding on your local computer ‚Äì the Integrated Development Environment, or IDE. The possibilities for IDEs is even more expansive than for either of the other tools. Common python IDEs include:\n\nVisual Studio Code\nJupyter Notebooks\nJupyter Labs\nSpyder\nPyCharm\nData Spell\nAtom\nRStudio\n\nAny of these would work well for a python data science workflow, but definitely some have more features focused on data science than others. For example, PyCharm is more focused on software engineering, but a new IDE called Data Spell, by the same company (Jet Brains), is squarely centered on data science workflows.\nThe best IDE is usually the one you are most familiar with. For that reason, RStudio isn‚Äôt a bad choice for an IDE. Although you will only be able to write code in quarto (.qmd) files, RStudio will be sufficient for many of your python needs.\nHowever, if you need to edit .ipynb files natively (without conversion to .py or .qmd), you will probably want to use an IDE that is designed to efficiently parse these files and allow you to execute code directly.\nWe‚Äôve been using Jupyter (both notebooks and lab) this class, and you can continue to do so on your local machine. However, it‚Äôs probably best to use a non-browser IDE if possible, since that will provide more opportunities for customization and removes a layer of complication required when executing your code.\nToday we will look at both RStudio (for .qmd files) and Visual Studio Code (VSCode).\nHaving covered all the bases, we need to go ahead and get to work. Here are the steps for getting our class environment working on your machine, and within your IDE."
  },
  {
    "objectID": "Setting_up_local.html#using-the-eds-217-environment.",
    "href": "Setting_up_local.html#using-the-eds-217-environment.",
    "title": "Setting up your local Python",
    "section": "Using the eds-217 environment.",
    "text": "Using the eds-217 environment.\nThe conda manager tool will keep track of all the different environments you have created, and the packages installed in each of them. At any time, you can inspect all of your installed environments and their libraries using the Anaconda Navigator, or using the conda env list command.\nWhen you are using an IDE you will often be given the opportunity to connect an environment with your code. Before doing so, it is necessary to first activate the environment in a terminal (or PowerShell for Windows) and then execute a 1-time command to register the kernel.\nYou can always activate an environment at a terminal prompt by using\n> conda activate <environment_name>\nIn the case of eds-217, you would use:\n> conda activate eds-217\nTo register your python environment with IDEs, you usually need to run the following command within the activated environment:\n> python -m ipykernel install --user --name=<env_name> --display-name \"<env_name\"\n\nThis command will allow you to select the environment within Jupyter, as well as RStudio and Visual Studio Code.\nIn RStudio, this happens when you create a new .qmd file and associate it with a jupyter installation.\nIn Visual Studio Code, you can select an environment when you first execute a .ipynb file or when you initiate an IPython interactive terminal."
  },
  {
    "objectID": "index.html#course-outline",
    "href": "index.html#course-outline",
    "title": "EDS 217 - Python for Environmental Data Science",
    "section": "Course Outline",
    "text": "Course Outline\n\nNew For Week 2: TryPy\nTo create more open-ended opportunities for you to apply your python skills, I‚Äôve ported over some exercises from EDS221. They are essentially the same, but now you will work on solving the problems using Python instead of R.\n\nTryPy Exercises\n\n\n\nDay 1 - Introduction to Python\nThe materials for Day 1 are designed to introduce the basics of working with Python.\nIntro to Python Data Science\nThe Zen of Python\nExercise 1-0 - Hello World\nExercise 1-1 - Variables & Operators\n\n\nDay 2 - Introduction to Python\nOn Day 2, we will explore lists and learn the fundamentals of controlling the flow of programs.\nGetting Help\nExercise 1-2 - Lists and Indexing\n(Simple example of enumerate and zip)\nExercise 1-3 - Ifs or Elses\n\n\nDay 3 - Introduction to Python\nOn Day 3, we will journey into advanced topics related to Python, including structured data and object-oriented programming concepts.\nExercise 1-4 - Structured Data\nExercise 1-5 - Functions ü¶Å, Objects üêØ, and Classes üêª, Oh my!\n\n\nDay 4 - Numpy üßÆ\nOur journey into Python‚Äôs Data Science toolkit begins with NumPy, a library designed to perform advanced calculations on matrices.\nExercise 2-1 - NumPy\n\n\nDay 5 - Pandas üêº\nWe end our first week with arguably the most important library in the Python data science ecosystem: Pandas.\nExercise 2-2 - Pandas\n\n\nDay 6 - Matplotlib üìà\nNow that we‚Äôve learned how to import, manage, and analyze data using pandas, it‚Äôs time to make some graphs! Matplotlib is the primary libary used for plotting data in Python (although there are some great alternatives), so we will start there.\nSetting up your local Python\nExercise 2-3 - Matplotlib\n\n\nDay 7 - Scipy üî¨\nSeaborn + TryPy + Group work.\n\n\nExtra Stuff:\nPrediction and forecasting requires understanding how to fit distributions and functions to data sets. Today we will combine what we‚Äôve learned so far and take a brief look at SciPy, which is a large library of tools that can be used to fit distributions.\nExercise 3 - SciPy\n\n\nDays 8 & 9 - Group Projects ‚úèÔ∏è\nOur final activity will be a group project in which you work with a team of 2-3 of your classmates to create a brief tutorial introducting one of the many other libraries available to conduct environmental data science in Python. You will develop your tutorial using the same Jupyter Notebook structures that we‚Äôve been using throughout the class. On our last day, we‚Äôll spend the afternoon conducting a Python Data Science Show and Tell\n\n\nBonus Content\nHere are a couple more advanced - and interactive - examples of environmental data science. We won‚Äôt get to these during our brief time together, but feel free to explore them any time you feel like learning more about what you can do with Python!\n\nCatchment Water Balance in Python\nLandscape Energy Balance in Python"
  },
  {
    "objectID": "Seaborn.html",
    "href": "Seaborn.html",
    "title": "",
    "section": "",
    "text": "Return to Course Home Page\n\n\n\n\n‚¨ÖÔ∏è Previous Exercise | üè† Index | ‚û°Ô∏è Next Exercise |\n\nSeaborn üìà\n\n\n\nseaborn\n\n\nThis notebook provides a brief introduction to the Seaborn visualization library.\nSeaborn helps you explore and understand your data. Its plotting functions operate on dataframes and arrays containing whole datasets and internally perform the necessary semantic mapping and statistical aggregation to produce informative plots. Its dataset-oriented, declarative API lets you focus on what the different elements of your plots mean, rather than on the details of how to draw them.\nHere‚Äôs an example of seaborne‚Äôs capabilities.\n\n\nCode\n# Import seaborn\nimport seaborn as sns\n\n# Apply the default theme\nsns.set_theme()\n\n# Load an example dataset\ntips = sns.load_dataset(\"tips\")\n\n# Create a visualization\nsns.relplot(\n    data=tips,\n    x=\"total_bill\", y=\"tip\", col=\"time\",\n    hue=\"smoker\", style=\"smoker\", size=\"size\",\n)\n\n\nBehind the scenes, seaborn uses matplotlib to draw its plots. The plot above shows the relationship between five variables in the built-in tips dataset using a single call to the seaborn function relplot().\nNotice that you only need to provide the names of the variables and their roles in the plot.\nThis interface is different from matplotlib, in that you do not need to specify attributes of the plot elements in terms of the color values or marker codes.\nBehind the scenes, seaborn handled the translation from values in the dataframe to arguments that matplotlib understands. This declarative approach lets you stay focused on the questions that you want to answer, rather than on the details of how to control matplotlib.\n\nSeaborn relplot()\nThe function relplot() is named that way because it is designed to visualize many different statistical relationships. While scatter plots are often effective, relationships where one variable represents a measure of time are better represented by a line. The relplot() function has a convenient kind parameter that lets you easily switch to this alternate representation:\n\n\nCode\ndots = sns.load_dataset(\"dots\")\nsns.relplot(\n    data=dots, kind=\"line\",\n    x=\"time\", y=\"firing_rate\", col=\"align\",\n    hue=\"choice\", size=\"coherence\", style=\"choice\",\n    facet_kws=dict(sharex=False),\n)\n\n\nIf you compare the two calls to relplot() in the two examples so far, you will see that the size and style parameters are used in both the scatter plots (first example) and line plots (second example). However, they affect the two visualizations differently.\nIn a scatter plot, the size and style arguments affect marker area and symbol representation.\nIn a line plot, the size and style arguments alter the line width and dashing.\nAllowing the same arguments (syntax) to change meaning (semantics) across different contexts is more characteristic of natural languages than formal ones. In this case, seaborn is attempting to allow you to write in a ‚Äúgrammar of graphics‚Äù, which is the same concept underlying ggplot created by Hadley Wickham.\nThe benefit of adopting this less formal specification is that you do not need to worry about as many syntax details and instead can focus more on the overall structure of the plot and the information you want it to convey.\n\n\nComparing matplotlib to seaborn\nA focus of today‚Äôs activities is translation, so let‚Äôs look at translating some of the examples from yesterday‚Äôs matplotlib exercise into seaborn.\nFirst, as always, let‚Äôs import our important packages:\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\n# Imports\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n\n\n\nBasic line plots (sns.lineplot)\nYesterday we used a few functions, y_{\\sin} = \\sin{(x)} and y_{\\cos} = \\cos{(x)}:\n# Generate a 1D array with 300 points between -5 and 5\nx = np.linspace(-5,5,300)\n# Generate sine wave\nysin = np.sin(x)\n# Generate cosine wave\nycos = np.cos(x)\n\n# Now let's make a dataframe from these arrays:\ndf = pd.DataFrame({\n    'x': x,\n    'ysin': ysin,\n    'ycos': ycos\n    })\n\n\nWe can plot these on the same figure without instancing `plt.figure()` as follows:\n\n```python\n# Plot sine wave\nplt.plot(x,ysin)\n# Plot cosine wave\nplot.plot(x,ycos)\nSeaborn uses the lineplot command to plot line plots:\nsns.lineplot(data=df,x='x',y='ysin')\nsns.lineplot(data=df,x='x',y='ycos')\n\n\nCode\n# Generate a 1D array with 300 points between -5 and 5\nx = np.linspace(-5,5,300)\n# Generate sine wave\nysin = np.sin(x)\n# Generate cosine wave\nycos = np.cos(x)\n\n# Now let's make a dataframe from these arrays:\ndf = pd.DataFrame({\n    'x': x,\n    'ysin': ysin,\n    'ycos': ycos\n    })\n\nsns.lineplot(data=df,x='x',y='ysin')\nsns.lineplot(data=df,x='x',y='ycos')\n\n\n\nüìö  <b> Practice 2. </b> \n1. Load the <code>flights</code> dataset using the <code>sns.load_dataset(\"flights\")</code> command. \n1. Explore the dataframe (it contains passenger data by month and year).\n1. Use `sns.lineplot()` to plot the number of passengers throughout the data set.\n1. Create a new dataset that contains data on a specific month (your choice) to see how monthly passengers have changed over time. \n1. Create a plot that shows the average and range of passengers by year. (Hint: This is much easier than it sounds in seaborn!)\n\n\n\nCode\nfmri = sns.load_dataset(\"fmri\")\n\n\n\n\n\n\nWorking with real data\n\n\nAs we learned in the previous exercise, working with real-world data usually complicates things, and plotting is no exception. In particular, working with time series can get a bit messy. Let‚Äôs take a look at our BSRN data as an example.\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\n# Import data\nbsrn = pd.read_csv('../data/BSRN_GOB_2019-10.csv',index_col=0,parse_dates=True)\n\n\nNow that we‚Äôve imported our data, let‚Äôs make a quick plot of incoming shortwave radiation over time.\n\n‚ñ∂Ô∏è <b> Translate the cell below into seaborn. </b>\n\n\n\nCode\n# # Initialize empty figure\n# fig = plt.figure()\n# # Plot incoming SW radiation\n# plt.plot(bsrn.index,bsrn.SWD_Wm2)\n# # Label y-axis\n# plt.ylabel(r'Incoming SW radiation (W m$^{-2}$)')\n\n\n\n\nThe x-axis looks rather messy because the tick labels are timestamps, which are, by nature, very long. Luckily, matplotlib has a module called dates for dealing with datetime objects.\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\nimport matplotlib.dates as mdates\n\n\nWithout going into too much detail, we can use some of the more advanced Axes settings to format and rotate the tick labels such that they no longer overlap, and we can use matplotlib.dates to format the timestamps. In short, we will use the mdates.DateFormatter() function to format the timestamps according to C formatting codes.\nThe following example demonstrates this, and includes a good code chunk for formatting timestamps to add to your repertoire. It is important to note that the formatting methods employed here are Axes methods, which means that we must operate on an Axes object, rather than the Figure.\n\n‚ñ∂Ô∏è <b> Run the cell below. </b>\n\n\n\nCode\n# Initialize empty figure and axes\nfig = plt.figure()\nax = fig.add_subplot(1,1,1)\n# Plot incoming SW radiation\nax.plot(bsrn.index,bsrn.SWD_Wm2)\n# Label y-axis\nax.set_ylabel(r'Incoming SW radiation (W m$^{-2}$)')\n\n# Format timestamps\nax.xaxis.set_major_formatter(mdates.DateFormatter('%d-%b-%y'))\n# Format and rotate ticks\nplt.setp(ax.get_xticklabels(), rotation=45, fontsize=10, ha='right')\nax.get_xticklabels()\n\n\n\nüìö  <b> Practice 3. </b> \nPlot temperature and relative humidity (ideally using subplots) over the month of October 2019 at the BSRN station. Be sure to format the timestamps and include axis labels, a title, and a legend, if necessary.\n\n\n\n\n\nCode\n# IGNORE THIS CELL\nfrom IPython.core.display import HTML\ndef css_styling():\n    styles = open(\"./styles/exercises.css\", \"r\").read()\n    return HTML(styles)\ncss_styling()"
  }
]
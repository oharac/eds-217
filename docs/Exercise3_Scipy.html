<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.189">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>exercise3_scipy</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css">

<link rel="stylesheet" href="styles/activities.css">
</head>

<body class="floating">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#exercise-3-probability-and-stochastic-processes-with-scipy" id="toc-exercise-3-probability-and-stochastic-processes-with-scipy" class="nav-link active" data-scroll-target="#exercise-3-probability-and-stochastic-processes-with-scipy">Exercise 3: Probability and Stochastic Processes with Scipy</a>
  <ul class="collapse">
  <li><a href="#instructions" id="toc-instructions" class="nav-link" data-scroll-target="#instructions">Instructions</a></li>
  <li><a href="#imports" id="toc-imports" class="nav-link" data-scroll-target="#imports">Imports</a></li>
  <li><a href="#reading-in-the-data" id="toc-reading-in-the-data" class="nav-link" data-scroll-target="#reading-in-the-data">Reading in the data</a></li>
  <li><a href="#determine-yearly-rainfall-totals." id="toc-determine-yearly-rainfall-totals." class="nav-link" data-scroll-target="#determine-yearly-rainfall-totals.">Determine yearly rainfall totals.</a></li>
  <li><a href="#quantifying-rainfall-variability" id="toc-quantifying-rainfall-variability" class="nav-link" data-scroll-target="#quantifying-rainfall-variability">Quantifying rainfall variability</a></li>
  <li><a href="#examining-daily-rainfall-probabilities-and-amounts" id="toc-examining-daily-rainfall-probabilities-and-amounts" class="nav-link" data-scroll-target="#examining-daily-rainfall-probabilities-and-amounts">Examining daily rainfall probabilities and amounts</a>
  <ul class="collapse">
  <li><a href="#what-is-the-chance-that-it-will-rain" id="toc-what-is-the-chance-that-it-will-rain" class="nav-link" data-scroll-target="#what-is-the-chance-that-it-will-rain">1. What is the chance that it will rain?</a></li>
  <li><a href="#monthly-rainfall-totals-and-probabilities" id="toc-monthly-rainfall-totals-and-probabilities" class="nav-link" data-scroll-target="#monthly-rainfall-totals-and-probabilities">Monthly Rainfall Totals and Probabilities</a></li>
  <li><a href="#what-is-the-amount-that-it-will-rain" id="toc-what-is-the-amount-that-it-will-rain" class="nav-link" data-scroll-target="#what-is-the-amount-that-it-will-rain">2. What is the amount that it will rain?</a></li>
  </ul></li>
  <li><a href="#fitting-rainfall-depths-to-an-exponential-distribution" id="toc-fitting-rainfall-depths-to-an-exponential-distribution" class="nav-link" data-scroll-target="#fitting-rainfall-depths-to-an-exponential-distribution">Fitting rainfall depths to an exponential distribution</a>
  <ul class="collapse">
  <li><a href="#step-1.-fit-the-distribution" id="toc-step-1.-fit-the-distribution" class="nav-link" data-scroll-target="#step-1.-fit-the-distribution">Step 1. Fit the distribution</a></li>
  <li><a href="#step-2.-calculate-fitted-pdf-and-error-with-fit-in-distribution" id="toc-step-2.-calculate-fitted-pdf-and-error-with-fit-in-distribution" class="nav-link" data-scroll-target="#step-2.-calculate-fitted-pdf-and-error-with-fit-in-distribution">Step 2. Calculate fitted PDF and error with fit in distribution</a></li>
  </ul></li>
  <li><a href="#modeling-rainfall" id="toc-modeling-rainfall" class="nav-link" data-scroll-target="#modeling-rainfall">Modeling rainfall</a>
  <ul class="collapse">
  <li><a href="#step-1.-simulating-poisson-events" id="toc-step-1.-simulating-poisson-events" class="nav-link" data-scroll-target="#step-1.-simulating-poisson-events">Step 1. Simulating Poisson events</a></li>
  <li><a href="#step-2.-adding-marks-to-events" id="toc-step-2.-adding-marks-to-events" class="nav-link" data-scroll-target="#step-2.-adding-marks-to-events">Step 2. Adding marks to events</a></li>
  <li><a href="#simulating-multiple-years-of-rainfall" id="toc-simulating-multiple-years-of-rainfall" class="nav-link" data-scroll-target="#simulating-multiple-years-of-rainfall">Simulating multiple years of rainfall</a></li>
  </ul></li>
  <li><a href="#conditional-probabilities-given-that-today-was-rainy-will-it-rain-tomorrow" id="toc-conditional-probabilities-given-that-today-was-rainy-will-it-rain-tomorrow" class="nav-link" data-scroll-target="#conditional-probabilities-given-that-today-was-rainy-will-it-rain-tomorrow">Conditional Probabilities: Given that today was rainy, will it rain tomorrow?</a></li>
  <li><a href="#simulating-annual-rainfall-with-monthly-values" id="toc-simulating-annual-rainfall-with-monthly-values" class="nav-link" data-scroll-target="#simulating-annual-rainfall-with-monthly-values">Simulating annual rainfall with monthly values</a></li>
  </ul></li>
  <li><a href="#the-end" id="toc-the-end" class="nav-link" data-scroll-target="#the-end">The End</a></li>
  </ul>
</nav>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">
<hr>
<h4 class="anchored"> <a href="index.html">Return to Course Home Page</a></h4>
<hr>



<p><a href="./Exercise2-3_Matplotlib.html">⬅️ Previous Exercise</a> | <a href="./Index.html">🏠 Index</a> | <a href="Labs.ipynb">➡️ Bonus Content!</a> |</p>
<section id="exercise-3-probability-and-stochastic-processes-with-scipy" class="level1">
<h1>Exercise 3: Probability and Stochastic Processes with Scipy</h1>
<p><img src="assets/kenya_landscape.png" class="img-fluid"></p>
<p>Rainfall in many dryland ecosystems exhibits pronounced variability from year to year. Because rainfall occurs intermittently and with a low degree of predictability, we often are forced to characterize the occurrence and amount of rainfall in terms of <strong>probability</strong>. In this exercise, we will investigate the probabilistic nature of rainfall at various locations in Kenya. We will use these data to explore the concepts of probability and conditional probability, as well as probability density functions and cumulative density functions. We will use these data to develop a stochastic model of rainfall that can be used to generate novel time series of rainfall and develop inference into the likelihood of various daily, monthly, seasonal, and annual rainfall totals.</p>
<div class="boxhead2">
<pre><code>Exercise 3 Topics</code></pre>
</div>
<div class="boxtext2">
<ul class="a">
<li>
📌 Analyze the probabilities and distribution of daily rainfall.
</li>
<li>
📌 Fit an exponential distribution to rainfall depths.
</li>
<li>
📌 Use our fitted distribution and rainfall probabilities to generate a stochastic model of daily rainfall.
</li>
<li>
📌 Use conditional probabilities to examine the independent nature of the daily rainfall process.
</li>
<li>
📌 Modify our model to generate monthly variation in rainfall probabilities and plot the results.
</li>
</ul>
</div>
<hr style="border-top: 0.2px solid gray; margin-top: 12pt; margin-bottom: 0pt">

<section id="instructions" class="level3">
<h3 class="anchored" data-anchor-id="instructions">Instructions</h3>
<p>Work through the exercise, writing code where indicated. To run a cell, click on the cell and press “Shift” + “Enter” or click the “Run” button in the toolbar at the top. Note: Do not restart the kernel and clear all outputs. If this happens, run the last cell in the notebook before proceeding.</p>
<p style="color:#408000; font-weight: bold">
🐍 &nbsp; &nbsp; This symbol designates an important note about Python structure, syntax, or another quirk.
</p>
<p style="color:#008C96; font-weight: bold">
▶️ &nbsp; &nbsp; This symbol designates a cell with code to be run.
</p>
<p style="color:#008C96; font-weight: bold">
✏️ &nbsp; &nbsp; This symbol designates a partially coded cell with an example.
</p>
<p style="color:#008C96; font-weight: bold">
📚 &nbsp; &nbsp; This symbol designates a practice question.
</p>
<hr style="border-top: 1px solid gray; margin-top: 24px; margin-bottom: 1px">

</section>
<section id="imports" class="level3">
<h3 class="anchored" data-anchor-id="imports">Imports</h3>
<p>First, let’s load <span class="code">pandas</span> into our notebook. As usual, we use <code>pd</code> as the shortname for pandas and <code>np</code> as the shortname for <span class="code">numpy</span>.</p>
<div class="run">
<pre><code>▶️ &lt;b&gt; Run the cell below. &lt;/b&gt;</code></pre>
</div>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>matplotlib inline</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="reading-in-the-data" class="level3">
<h3 class="anchored" data-anchor-id="reading-in-the-data">Reading in the data</h3>
<p>All the data for our exercise are stored as <code>.csv</code> files. We will read the <code>.csv</code> file into a <code>DataFrame</code>. Note: be sure you have copied the file from the <code>data</code> folder.</p>
<div class="run">
<pre><code>▶️ &lt;b&gt; Run the cell below. &lt;/b&gt;</code></pre>
</div>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.read_csv(</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">"../data/mpala_ranch_house_rainfall.csv"</span>,</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    usecols<span class="op">=</span>[<span class="st">'Rainfall (mm)'</span>, <span class="st">'Date'</span>, <span class="st">'Year'</span>, <span class="st">'Month'</span>, <span class="st">'Day'</span>]</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> df.info()</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span><span class="kw">class</span> <span class="st">'pandas.core.frame.DataFrame'</span><span class="op">&gt;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>RangeIndex: <span class="dv">16602</span> entries, <span class="dv">0</span> to <span class="dv">16601</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>Data columns (total <span class="dv">5</span> columns):</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>Rainfall (mm)    <span class="dv">15751</span> non<span class="op">-</span>null float64</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>Date             <span class="dv">16602</span> non<span class="op">-</span>null <span class="bu">object</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>Year             <span class="dv">16602</span> non<span class="op">-</span>null int64</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>Month            <span class="dv">16602</span> non<span class="op">-</span>null int64</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>Day              <span class="dv">16602</span> non<span class="op">-</span>null int64</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>dtypes: float64(<span class="dv">1</span>), int64(<span class="dv">3</span>), <span class="bu">object</span>(<span class="dv">1</span>)</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>memory usage: <span class="fl">648.6</span><span class="op">+</span> KB</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Here we see that the <code>DataFrame</code> has 16,602 entries (this is the number of rows in the <code>.csv</code> file), and contains 5 columns that are called <code>Rainfall (mm)</code>, <code>Date</code>, <code>Year</code>, <code>Month</code>, and <code>Day</code>. These column names are taken directly from the <code>.csv</code> header row.</p>
<p><span class="code">Pandas</span> has auto-detected that <code>Year</code>, <code>Month</code>, and <code>Day</code> are all integers and the data in the <code>Rainfall (mm)</code> column are detected to be floating point numbers. The <code>Date</code> column has been categorized as an indeterminant <code>object</code> type (this is the default type, which means <span class="code">pandas</span> has no idea what to do with this column). We will come back to this in a bit, but first let’s keep exploring our new <code>DataFrame</code>.</p>
<p>Let’s take a look at the first few rows of the dataframe using the <code>head()</code> command.</p>
<div class="run">
<pre><code>▶️ &lt;b&gt; Run the cell below. &lt;/b&gt;</code></pre>
</div>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="determine-yearly-rainfall-totals." class="level2">
<h2 class="anchored" data-anchor-id="determine-yearly-rainfall-totals.">Determine yearly rainfall totals.</h2>
<p>The most common – but not always the most useful – interval of rainfall characterization is annual. Let’s see what years we have available to investigate annual rainfall, using the <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.unique.html"><code>pd.unique()</code></a> function.</p>
<div class="example">
<pre><code>✏️ &lt;b&gt; Try it. &lt;/b&gt; 
Use the &lt;code&gt;pd.unique()&lt;/code&gt; function to get a list of the unique years contained in the &lt;code&gt;Year&lt;/code&gt; column of our dataframe, &lt;code&gt;df&lt;/code&gt;. Assign this list of years to a new array called &lt;code&gt;all_years&lt;/code&gt;</code></pre>
</div>
<p>If all goes well, you should get results that look like this:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> <span class="bu">print</span>(all_years)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1972</span> <span class="dv">1973</span> <span class="dv">1974</span> <span class="dv">1975</span> <span class="dv">1976</span> <span class="dv">1977</span> <span class="dv">1978</span> <span class="dv">1979</span> <span class="dv">1980</span> <span class="dv">1981</span> <span class="dv">1982</span> <span class="dv">1983</span> <span class="dv">1984</span> <span class="dv">1985</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a> <span class="dv">1986</span> <span class="dv">1987</span> <span class="dv">1988</span> <span class="dv">1989</span> <span class="dv">1990</span> <span class="dv">1991</span> <span class="dv">1992</span> <span class="dv">1993</span> <span class="dv">1994</span> <span class="dv">1995</span> <span class="dv">1996</span> <span class="dv">1997</span> <span class="dv">1998</span> <span class="dv">1999</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a> <span class="dv">2000</span> <span class="dv">2001</span> <span class="dv">2002</span> <span class="dv">2003</span> <span class="dv">2004</span> <span class="dv">2005</span> <span class="dv">2006</span> <span class="dv">2007</span> <span class="dv">2008</span> <span class="dv">2009</span> <span class="dv">2010</span> <span class="dv">2011</span> <span class="dv">2012</span> <span class="dv">2013</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a> <span class="dv">2014</span> <span class="dv">2015</span> <span class="dv">2016</span> <span class="dv">2017</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>It looks like we have almost five decades of rainfall data. The first thing we might want to do with this data is look at yearly summaries.</p>
<hr style="border-top: 1px solid gray; margin-top: 24px; margin-bottom: 1px">

<div class="practice">
<pre><code>📚  &lt;b&gt; Practice 1. (The following steps can be combined into a single line of code)&lt;/b&gt; </code></pre>
<ol class="alpha">
<li>
Determine the annual rainfall totals for each year.
</li>
<li>
Use method chaining combined with the <code>df.groupby()</code> function to get the sum of every year’s rainfall.
</li>
<li>
Use the argument <code>min_count</code> in the <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.sum.html"><code>sum()</code></a> command to force pandas to only include sums of rainfall for years with at least 350 days of data.
</li>
<li>
Assign these totals to a new <code>Series</code> variable called <code>yearly_rainfall_total</code>.
</li>
</ol>
</div>
<p>If all goes correctly, you should get results that look like this:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> yearly_rainfall_total.head()</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>Year</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="dv">1972</span>    <span class="fl">681.228</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="dv">1973</span>        NaN</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="dv">1974</span>    <span class="fl">378.968</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="dv">1975</span>    <span class="fl">791.464</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="dv">1976</span>    <span class="fl">363.220</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>Name: Rainfall (mm), dtype: float64</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<hr style="border-top: 1px solid gray; margin-top: 24px; margin-bottom: 1px">

</section>
<section id="quantifying-rainfall-variability" class="level2">
<h2 class="anchored" data-anchor-id="quantifying-rainfall-variability">Quantifying rainfall variability</h2>
<p>We can use the <a href="https://en.wikipedia.org/wiki/Coefficient_of_variation">coefficient of variation</a> to describe rainfall variability. The coefficient of variation, <span class="math inline">CV</span>, of a group of numbers is the ratio of the standard deviation, <span class="math inline">\sigma</span>, to the mean, <span class="math inline">\mu</span>. We can calculate the population CV of a sample, <span class="math inline">\widehat{CV}</span>, as the ratio of standard deviation of the sample, <span class="math inline">s</span>, and the sample mean, <span class="math inline">\bar{x}</span>:</p>
<p><span class="math display"> \widehat{CV} = \frac{s}{\bar{x}} </span></p>
<div class="example">
<pre><code>✏️ &lt;b&gt; Try it. &lt;/b&gt;    </code></pre>
<p>Create a histogram of yearly rainfall amounts using the <a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.hist.html"><code>hist()</code></a> command that is a built-in method of any <code>pandas.Series</code>. <br> <br> Note: Your variable, <code>yearly_rainfall_total</code> should be a <code>pandas.Series</code> object.</p>
</div>
<p>We have a very pronounced mode, with a large degree of variation. Let’s calculate the <span class="math inline">\widehat{CV}</span>.</p>
<div class="example">
<pre><code>✏️ &lt;b&gt; Try it. &lt;/b&gt;    </code></pre>
<p>Use the formula above to calculate the <span class="math inline">\widehat{CV}</span> for the data in <code>yearly_rainfall_total</code>.</p>
</div>
<p><span class="math inline">\widehat{CV}</span> has some problems dealing with small sample sizes (n) and tends to be biased low. We can create an unbiased estimator, <span class="math inline">\widehat{CV}^{*}</span> using the following function<span class="math inline">{^1}</span>:</p>
<p><span class="math display"> \widehat{CV}^{*} = \left(1 + \frac{1}{4n}\right)\widehat{CV} </span></p>
<p><span class="math inline">{^1}</span> <em>technically, <span class="math inline">\widehat{CV}^{*}</span> is only valid for normally-distributed data, but we will use it anyway as an example.</em></p>
<div class="practice">
<pre><code>📚  &lt;b&gt; Practice 2.&lt;/b&gt;
Create a function that calculates the $\widehat{CV}^{*}$ for a set of data and use the function to determine the $\widehat{CV}^{*}$ value for our yearly rainfall data.</code></pre>
</div>
</section>
<section id="examining-daily-rainfall-probabilities-and-amounts" class="level2">
<h2 class="anchored" data-anchor-id="examining-daily-rainfall-probabilities-and-amounts">Examining daily rainfall probabilities and amounts</h2>
<p>As we see from the analysis of yearly and monthly rainfall, the climatology of this location is characterized by a fairly high degree of variability. The same is true of many tropical drylands.</p>
<section id="what-is-the-chance-that-it-will-rain" class="level3">
<h3 class="anchored" data-anchor-id="what-is-the-chance-that-it-will-rain">1. What is the chance that it will rain?</h3>
<p>In order to get at the rainfall process itself, let’s look at the distribution of rainfall events. We can find all the days of rainfall by simply filtering our <code>DataFrame</code> to find days when rain was greater than zero. To do this, we can use the <code>loc()</code> function.</p>
<p>The following line of code returns a new dataframe that contains only the rows where <code>'Rainfall (mm)'</code> is greater than zero:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>rainy_days <span class="op">=</span> df.loc[ (df[<span class="st">'Rainfall (mm)'</span>] <span class="op">&gt;</span> <span class="dv">0</span>) ]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="practice">
<pre><code>📚  &lt;b&gt; Practice 3.&lt;/b&gt;
Calculate the overall probability of daily rainfall.
&lt;ol class="alpha"&gt;
    &lt;li&gt; Create a &lt;code&gt;DataFrame&lt;/code&gt; containing only rainy days (when rainfall is greater than zero) called &lt;code&gt;rainy_days&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt; Create a &lt;code&gt;DataFrame&lt;/code&gt; consisting of all observation days (when rainfall is not equal to &lt;code&gt;NaN&lt;/code&gt;) called &lt;code&gt;all_days&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt; Use the ratio of the length of &lt;code&gt;rainy_days&lt;/code&gt; and &lt;code&gt;all_days&lt;/code&gt; to determine the probability of rainfall and save this as a new variable called &lt;code&gt;prob_rain&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;</code></pre>
</div>
<p>If all goes well, then you should get the following value for <code>prob_rain</code>:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span> <span class="bu">print</span>(prob_rain)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="fl">0.13211859564472098</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<hr style="border-top: 1px solid gray; margin-top: 24px; margin-bottom: 1px">

</section>
<section id="monthly-rainfall-totals-and-probabilities" class="level3">
<h3 class="anchored" data-anchor-id="monthly-rainfall-totals-and-probabilities">Monthly Rainfall Totals and Probabilities</h3>
<p>Over the entire time period, the probability of rainfall was about 13%, which means that it rains - on average - a little less than once per week (approximately every 7.7 days). However, most regions have strong seasonality in rainfall. Our data comes from a site that is located very close to the equator in central Kenya. This means that the movement of the ITCZ across the tropics causes changes in the likelihood of rainfall from month to month. We should therefore look at monthly rainfall probabilies rather than simply the annual average.</p>
<div class="practice">
<pre><code>📚  &lt;b&gt; Practice 4.&lt;/b&gt;
&lt;ol class="alpha"&gt;
    &lt;li&gt; Determine the probability of rainfall for each month. Add these values to a list called &lt;code&gt;lambda_by_month&lt;/code&gt;. Hint: You can combine test criteria using logical operators (i.e. &lt;code&gt;&amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;).
    &lt;li&gt;Create a bar graph of the monthly rainfall probabilites. Label your plot appropriately.
&lt;/ol&gt;</code></pre>
</div>
</section>
<section id="what-is-the-amount-that-it-will-rain" class="level3">
<h3 class="anchored" data-anchor-id="what-is-the-amount-that-it-will-rain">2. What is the amount that it will rain?</h3>
<p>We’ve already subsetted all of our data for days with rain and stored this in the variable <code>rainy_days</code>. Let’s look at the distribution of rain amounts:</p>
<div class="run">
<pre><code>▶️ &lt;b&gt; Run the cell below. &lt;/b&gt;</code></pre>
</div>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>rainy_days[<span class="st">'Rainfall (mm)'</span>].hist(bins<span class="op">=</span><span class="dv">50</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>As opposed to the annual rainfall distribution, the distribution of daily storm totals (or daily rainfall) has a much clearer distribution. This pattern of daily rainfall – a positively skewed distribution with a short-tail – is <em>very</em> consistent with what we see across tropical drylands, and even more broadly across any location where rainfall is dominated by convective processes. We might ask what the average storm total is…</p>
<div class="example">
<pre><code>✏️ &lt;b&gt; Try it. &lt;/b&gt;    
Calculate the average rainfall amount on rainy days over the data record. Save this quantity as a new variable called &lt;code&gt;avg_rainfall_depth&lt;/code&gt;.</code></pre>
</div>
</section>
</section>
<section id="fitting-rainfall-depths-to-an-exponential-distribution" class="level2">
<h2 class="anchored" data-anchor-id="fitting-rainfall-depths-to-an-exponential-distribution">Fitting rainfall depths to an exponential distribution</h2>
<p>A simple rainfall model makes two assumptions; (1) that events arrive according to a Poisson process, and (2) that rainfall depths are distributed according to an exponential distribution. These two assumptions are accompanied by the need for two rainfall parameters; (1) the probability of rainfall events, <span class="math inline">\lambda_r</span>, and the average depth of rainfall events <span class="math inline">\alpha</span>. We’ve already seen how to estimate both of these parameters from rainfall data, so here we are going to focus on testing the appropriateness of the model assumptions during the growing season for Laikipia, Kenya.</p>
<section id="step-1.-fit-the-distribution" class="level3">
<h3 class="anchored" data-anchor-id="step-1.-fit-the-distribution">Step 1. Fit the distribution</h3>
<p>To fit the distribution, we are going to use some more functions from <span class="code">python</span>’s suite of numerical analysis. In this case we are going to use some functions from <span class="code">scipy</span>. The <a href="https://docs.scipy.org/doc/scipy/reference/stats.html"><code>scipy.stats</code></a> module has a large suite of distribution functions pre-defined, which we can use to develop a fit for our data. Using any of these distributions for fitting our data is very easy. The distribution we are most interested in is the exponential distribution, which is called <code>expon</code> in the <code>stats</code> module.</p>
<div class="run">
<pre><code>▶️ &lt;b&gt; Run the cell below. &lt;/b&gt;</code></pre>
</div>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.stats <span class="im">as</span> st</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>distribution <span class="op">=</span> st.expon</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> rainy_days[<span class="st">'Rainfall (mm)'</span>]</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>params <span class="op">=</span> distribution.fit(data, loc<span class="op">=</span><span class="dv">0</span>) <span class="co"># Force the distribution to be built off of zero</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(params)</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>arg <span class="op">=</span> params[:<span class="op">-</span><span class="dv">2</span>]</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>loc <span class="op">=</span> params[<span class="op">-</span><span class="dv">2</span>]</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>scale <span class="op">=</span> params[<span class="op">-</span><span class="dv">1</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="step-2.-calculate-fitted-pdf-and-error-with-fit-in-distribution" class="level3">
<h3 class="anchored" data-anchor-id="step-2.-calculate-fitted-pdf-and-error-with-fit-in-distribution">Step 2. Calculate fitted PDF and error with fit in distribution</h3>
<p>To test the fit of our distribution, we can compare the empirical histogram to that predicted by our model. To do this, we first use our <code>data</code> to generate the empirical histogram. In this exampkle, we break the data into <code>30</code> bins, and we generate a histrogram of <code>density</code> rather than counts. This allows for an easier comparison between our empirical data and the fitted probability distribution function. Here are the steps:</p>
<ol type="1">
<li>Generate a histogram, from the <code>data</code>. Save the bin locations in <code>x</code> and the density of values in <code>y</code></li>
<li>Shift the <code>x</code> bin locations generated from the histogram to the center of bins.</li>
<li>Calculate the value of the fitted <code>pdf(x)</code> for each of the bins in <code>x</code>.</li>
<li>Determine the residual sum of the squares, <span class="math inline">SS_{error}</span>, and total sum of squares, <span class="math inline">SS_{yy}</span>, according to:</li>
</ol>
<p><span class="math display"> SS_{error} = \sum_{i=1}^{n} \left(y_i - f(x_i)\right)^2 </span> <span class="math display"> SS_{yy} = \sum_{i=1}^{n} \left(y_i - \bar{y}\right)^2 </span></p>
<ol start="5" type="1">
<li>Calculate the <span class="math inline">r^2</span> of the fit, according to</li>
</ol>
<p><span class="math display"> r^2 = 1- \frac{SS_{error}}{SS_{yy}} </span></p>
<div class="run">
<pre><code>▶️ &lt;b&gt; Run the cell below. &lt;/b&gt;</code></pre>
</div>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 1. Generate a density histogram of the data </span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>y, x <span class="op">=</span> np.histogram(data, bins<span class="op">=</span><span class="dv">30</span>, density<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 2. Shift the x bin locations to the center of bins.</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> (x <span class="op">+</span> np.roll(x, <span class="op">-</span><span class="dv">1</span>))[:<span class="op">-</span><span class="dv">1</span>] <span class="op">/</span> <span class="fl">2.0</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 3. Calculate the values of pdx(x) for all x.</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>pdf <span class="op">=</span> distribution.pdf(x, loc<span class="op">=</span>loc, scale<span class="op">=</span>scale, <span class="op">*</span>arg)</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Step 4. Determine the residual and total sum of the squares.</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>ss_error <span class="op">=</span> np.<span class="bu">sum</span>(np.power(y <span class="op">-</span> pdf, <span class="fl">2.0</span>))</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>ss_yy <span class="op">=</span> np.<span class="bu">sum</span>(np.power(y <span class="op">-</span> y.mean(), <span class="fl">2.0</span>))</span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>r_2 <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> ( ss_error <span class="op">/</span> ss_yy )</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(r_2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>These results suggest that an exponential distribution is a really good fit for our observed data on rainfall amounts.</p>
<hr style="border-top: 1px solid gray; margin-top: 24px; margin-bottom: 1px">

</section>
</section>
<section id="modeling-rainfall" class="level2">
<h2 class="anchored" data-anchor-id="modeling-rainfall">Modeling rainfall</h2>
<p>Let’s make a very simple model of rainfall that assumes a Poisson process (i.e.&nbsp;a memoryless process). We just saw that this approach is probably too simple, and later we will look at how we could improve the model. But it helps to start with the most simple approach and then add complexity as needed.</p>
<p>Our model will be built with the following assumptions:</p>
<ol type="1">
<li><p>The probability of an “event” (i.e.&nbsp;rainfall) occuring on any given day is given by the parameter <span class="math inline">\lambda_r</span>, which has units day<span class="math inline">^{-1}</span></p></li>
<li><p>The total depth of rainfall on days with rain is a random variable, drawn from an exponential distribution with mean, <span class="math inline">\alpha</span>, which has units of mm.</p></li>
</ol>
<p>This type of model is a <a href="http://www.math.kit.edu/stoch/~last/seite/lectures_on_the_poisson_process/media/lastpenrose2017.pdf">“marked Poisson process”</a> and is a special case of a Poisson process on a number line (in our case, the number line is time), where each event is characterized by a random “mark” that is independent of the event.</p>
<section id="step-1.-simulating-poisson-events" class="level3">
<h3 class="anchored" data-anchor-id="step-1.-simulating-poisson-events">Step 1. Simulating Poisson events</h3>
<p>We have a variety of means to simulate a Poisson process, and all of them will require the use of a random number generator. The <span class="code">numpy</span> package has lots of different builtin functions to generate pseudo-random numbers, and we can use one of these.</p>
<p>To simulate the likelihood of a Poisson event, we can draw a sample from a uniform distribution in <span class="math inline">[0,1]</span> and compare that to our probability of an event. If the value we draw is less than or equal to our probability, then an event occurs, otherwise no event occurs. The probability density function, <span class="math inline">f(x)</span> of a uniform distribution sampled over the half open interval from <span class="math inline">a</span> to <span class="math inline">b</span>, <span class="math inline">[a,b)</span> is given by</p>
<p><span class="math display">
f(x) = \frac{1}{b - a}
</span></p>
<p>We can sample from this distribution using the <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.uniform.html"><strong><code>np.random.uniform()</code></strong></a> function:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> np.random.uniform(low<span class="op">=</span><span class="dv">0</span>,high<span class="op">=</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The <code>np.random.uniform()</code> function also takes the optional argument <code>size</code>, which specifies the number of random samples to return. This allows for the generation of large lists of random samples without using a <code>for</code> loop or list comprehension approaches.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Returns an array of 2 random draws.</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> np.random.uniform(low<span class="op">=</span><span class="dv">0</span>, high<span class="op">=</span><span class="dv">1</span>, size<span class="op">=</span><span class="dv">2</span>) </span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Returns an array of 2 rows each with 10 random draws</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>s_mat <span class="op">=</span> np.random.uniform(low<span class="op">=</span><span class="dv">0</span>, high<span class="op">=</span><span class="dv">1</span>, size<span class="op">=</span>[<span class="dv">2</span>, <span class="dv">10</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="example">
<pre><code>✏️ &lt;b&gt; Try it. &lt;/b&gt;    
Using a $\lambda_r$ value equal to your calculated value of &lt;code&gt;prob_rain&lt;/code&gt; and assuming that the length of a growing season, $T_{seas}$, is 160 days, simulate a season of rainfall "events", where the value of a day is &lt;code&gt;1&lt;/code&gt; if rainfall occurs, and &lt;code&gt;0&lt;/code&gt; if not.&lt;/div&gt;</code></pre>
</div>
<div class="alert alert-info">
💡 You can use the <code>pd.astype()</code> command to force Boolean (<code>True</code>/<code>False</code>) values into integers (<code>1</code>,<code>0</code>)
</div>
</section>
<section id="step-2.-adding-marks-to-events" class="level3">
<h3 class="anchored" data-anchor-id="step-2.-adding-marks-to-events">Step 2. Adding marks to events</h3>
<p>Our approach for creating marks (i.e.&nbsp;daily rainfall depths) is to sample them randomly from an exponential distribution with mean <span class="math inline">\alpha</span>. The exponential probability density function <span class="math inline">f(x)</span> for <span class="math inline">x\gt0</span> as a function of <span class="math inline">\alpha</span> is expressed as</p>
<p><span class="math display">
f(x) = \frac{1}{\alpha} \exp\left(-\frac{x}{\alpha}\right),
</span></p>
<p>Just as with sampling from a uniform distribution (and as with most everything in <code>python/pandas</code>), there’s a <strong>function</strong> for that. In this case, we are going to use the… you guessed it… <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.exponential.html"><code>np.random.exponential()</code></a> function. It is used similarly to the <code>np.random.uniform()</code> function, but with a single parameter to describe the distribution:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> np.random.exponential(scale<span class="op">=</span><span class="fl">11.5</span>) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The <code>scale</code> parameter is the mean of the distribution, which in our simulations will be <span class="math inline">\alpha</span> (mm), the average rainfall depth on days with rain. Just as with <code>np.random.uniform()</code>, we can generate lists or arrays of samples from the exponential distribution.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> np.random.exponential(scale<span class="op">=</span><span class="fl">11.5</span>, size<span class="op">=</span><span class="dv">2</span>) <span class="co"># Returns an array of 2 random draws.</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>s_mat <span class="op">=</span> np.random.uniform(scale<span class="op">=</span><span class="fl">11.5</span>, size<span class="op">=</span>[<span class="dv">2</span>, <span class="dv">10</span>]) <span class="co"># Returns an array of 2 rows each with 10 random draws.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="example">
<pre><code>✏️ &lt;b&gt; Try it. &lt;/b&gt;    
Use the average storm depth (&lt;code&gt;avg_rainfall_depth&lt;/code&gt;), probability of rainfall you calculated earlier, and the same $T_{seas}$ as before, generate a season of rainfall.&lt;/div&gt;</code></pre>
<div class="alert alert-info">
💡 The product of <code>0</code> and any rainfall amount is still <code>0</code>. That means you don’t need to worry about which days have rain and which don’t when multiplying a list of <code>rainfall_amounts</code> and a binary list of <code>rain_days</code>.
</div>
</div></section>
<section id="simulating-multiple-years-of-rainfall" class="level3">
<h3 class="anchored" data-anchor-id="simulating-multiple-years-of-rainfall">Simulating multiple years of rainfall</h3>
<div class="practice">
<pre><code>📚  &lt;b&gt; Practice 5.&lt;/b&gt;
Using your &lt;code&gt;prob_rain&lt;/code&gt; and your &lt;code&gt;avg_rainfall_depth&lt;/code&gt;:
&lt;ol class="alpha"&gt;
    &lt;li&gt; Generate 100 years of rainfall.&lt;/li&gt;
    &lt;li&gt; Plot a histogram of the annual totals.&lt;/li&gt;
    &lt;li&gt;Calculate the $\widehat{CV}$ of seasonal rainfall.&lt;/li&gt;
&lt;/ol&gt;</code></pre>
</div>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>                   </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
<section id="conditional-probabilities-given-that-today-was-rainy-will-it-rain-tomorrow" class="level2">
<h2 class="anchored" data-anchor-id="conditional-probabilities-given-that-today-was-rainy-will-it-rain-tomorrow">Conditional Probabilities: Given that today was rainy, will it rain tomorrow?</h2>
<p>Finally, we want to look to see if we can predict rainfall. The easiest way to think about predictability is to ask whether or not knowing what happened today significantly alters our expectation about what will happen tomorrow. There are two options:</p>
<ol type="1">
<li>If every day is random and unpredictable, then rainfall tomorrow will be independent of what happened today.</li>
<li>If what happens today affects tomorrow, then we should see dependency between today and tomorrow’s rainfall.</li>
</ol>
<p>We can test the independence of rainfall likelihood by testing to see if rainfall on day <span class="math inline">t</span> affects the probability of rainfall on day <span class="math inline">t+1</span>.</p>
<p>Formally, we can write the probability that rainfall, <span class="math inline">R</span>, on some day <span class="math inline">t</span>,is greater than zero as <span class="math inline">P[R_t&gt;0]</span>. If $ P[R_t&gt;0] = P[R_t&gt;0 | R_{t-1} &gt;0] $, then we can say that <span class="math inline">P[R_t]</span> and <span class="math inline">P[R_{t-1}]</span> are independent.</p>
<p>First, we use the <strong>index</strong> property of <code>rainy_days</code>, which is just a list of all the index values (or rows) in our original data, <code>df</code>, where rainfall was greater than zero. Then we increment the index and save all these rows from the original data into a new variable, <code>days_after_rain</code>.</p>
<div class="practice">
<pre><code>📚  &lt;b&gt; Practice 6.&lt;/b&gt;
&lt;ol class="alpha"&gt;
    &lt;li&gt; Make a list of the index locations of &lt;code&gt;rainy_days&lt;/code&gt; using the &lt;code&gt;index&lt;/code&gt; attribute of &lt;code&gt;rainy_days&lt;/code&gt;.&lt;/li&gt;
    &lt;li&gt; Create a new dataframe called &lt;code&gt;days_after_rain&lt;/code&gt; that contains only the days after rainy days. You will need to use our original &lt;code&gt;df&lt;/code&gt; dataframe to get this new dataframe.&lt;/li&gt;
    &lt;li&gt;Calculate the probability of rainfall following rainy days using your new &lt;code&gt;days_after_rain&lt;/code&gt; variable. Call this new probability &lt;code&gt;prob_rain_after_rain&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;Compare the probability of rainfall following rainy days (&lt;code&gt;prob_rain_after_rain&lt;/code&gt;) to the overall probability of rainfall (&lt;code&gt;prob_rain&lt;/code&gt;). Based on these values, is an assumption of independence in the rainfall process valid?&lt;/li&gt;
&lt;/ol&gt;</code></pre>
</div>
</section>
<section id="simulating-annual-rainfall-with-monthly-values" class="level2">
<h2 class="anchored" data-anchor-id="simulating-annual-rainfall-with-monthly-values">Simulating annual rainfall with monthly values</h2>
<p>One improvement we can make to our model is to have monthly values for our rainfall probabilities. To get these monthly <span class="math inline">\lambda_r</span> values, we need to determine the probability of rainfall for each month by dividing the number of rainy days per month by the total number of observations in each month, which we did in Practice 4. For now, we assume stationarity in the monthly values, which means that we are assuming that the values of <span class="math inline">\lambda_r</span> in each month are the same through out the entire record (i.e.&nbsp;Jan 1938 has the same properties as Jan 2008).</p>
<div class="alert alert-info">
💡 It’s worth thinking about how you could test our stationarity assumption. If you have an idea of how to do so, go ahead and give it a shot!
</div>
<p>To improve our simulation of annual rainfall, we are going to use our monthly values to specify daily values of <span class="math inline">\lambda_r</span> using the monthly values we just calculated. The use of a variable <span class="math inline">\lambda</span> value in a Poisson process creates what is known as an “inhomogenous Poisson process” (or, alternatively, “nonhomogeneous”… unfortunatetly, there isn’t much homogeneity in what we call it!). These types of processes allow the properties of the process to change in space and time. Our implementation – using monthly values – is a little clunky, and we’d prefer to have the <span class="math inline">\lambda</span> values change more smoothly throughout the year. However, we probably don’t have sufficient data to allow for this, even if we could accomodate the more complicated coding it would require.</p>
<p>In order to generate our nonhomogenous process, we will first generate a daily array of month numbers for the year <code>2018</code>. This is really easy in python using <code>datetime</code> + <code>timedelta</code> (which we need to import).</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>    <span class="im">from</span> datetime <span class="im">import</span> timedelta, datetime</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>    datetimes <span class="op">=</span> np.arange(</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>        datetime(<span class="dv">2018</span>,<span class="dv">1</span>,<span class="dv">1</span>), datetime(<span class="dv">2018</span>,<span class="dv">12</span>,<span class="dv">31</span>),</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>        timedelta(days<span class="op">=</span><span class="dv">1</span>)).astype(datetime)</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>    month_value_by_day <span class="op">=</span> np.array([datetime.month <span class="cf">for</span> datetime <span class="kw">in</span> datetimes])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="run">
<pre><code>▶️ &lt;b&gt; Run the cell below. &lt;/b&gt;</code></pre>
</div>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> datetime <span class="im">import</span> timedelta, datetime</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>datetimes <span class="op">=</span> np.arange(datetime(<span class="dv">2018</span>,<span class="dv">1</span>,<span class="dv">1</span>), datetime(<span class="dv">2019</span>,<span class="dv">1</span>,<span class="dv">1</span>), timedelta(days<span class="op">=</span><span class="dv">1</span>)).astype(datetime)</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>month_value_by_day <span class="op">=</span> np.array([datetime.month <span class="cf">for</span> datetime <span class="kw">in</span> datetimes])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Now we have a 12-element <code>np.array</code> of <span class="math inline">\lambda_r</span> values, organized by month number, which we’ve stored in <code>lambda_by_month</code> and we have a list of 365 days that contains the month number for each day, which we’ve stored in <code>month_value_by_day</code>. We can use these two variables to get a new variable that contains the correct <span class="math inline">\lambda</span> value for each day.</p>
<div class="run">
<pre><code>▶️ &lt;b&gt; Run the cell below. &lt;/b&gt;</code></pre>
</div>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>daily_lambda_values <span class="op">=</span> np.array([lambda_by_month[i<span class="op">-</span><span class="dv">1</span>] <span class="cf">for</span> i <span class="kw">in</span> month_value_by_day])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>With daily values of <span class="math inline">\lambda_r</span>, we only need to follow the same cookbook we used to make the stationary simulation.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>    simulated_rainy_days <span class="op">=</span> (</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>        np.random.uniform(</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>            low<span class="op">=</span><span class="dv">0</span>, high<span class="op">=</span><span class="dv">1</span>, size<span class="op">=</span><span class="bu">len</span>(daily_lambda_values)</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>        ) <span class="op">&lt;=</span> daily_lambda_values).astype(<span class="bu">int</span>)</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>    simulated_rainfall_values <span class="op">=</span> np.random.exponential(</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>        scale<span class="op">=</span>alpha, size<span class="op">=</span><span class="bu">len</span>(daily_lambda_values)</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>    )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="example">
<pre><code>✏️ &lt;b&gt; Try it. &lt;/b&gt;    
Use the code above to create a new daily rainfall simulation using our daily values of $\lambda_r$. Plot the daily rainfall data. You can easily plot your rainfall data using the &lt;code&gt;datetimes&lt;/code&gt; object we already created as the basis of our x-axis.&lt;/div&gt;</code></pre>
</div></section>
</section>
<section id="the-end" class="level1">
<h1>The End</h1>
<p>You’ve made it to the end of the assignment. We’ve covered a ton of material, so definitely go back and play around with the simulations.</p>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="co"># IGNORE THIS CELL</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.core.display <span class="im">import</span> HTML</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> css_styling():</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>    styles <span class="op">=</span> <span class="bu">open</span>(<span class="st">"./styles/exercises.css"</span>, <span class="st">"r"</span>).read()</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> HTML(styles)</span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>css_styling()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
</div> <!-- /content -->



</body></html>